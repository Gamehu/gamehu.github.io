<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>12-Factors</title>
    <url>/2018/07/04/12-Factors/</url>
    <content><![CDATA[<p><strong>背景</strong></p>
<p>现公司是传统的ToB业务公司，现在要新开一条产品线，因为公司的之前的产品已经10年了，因为技术等的限制，无法应对现在的快速迭代，公司高层想用现在流行的玩法，寻求突破，刚好之前那家公司的leader，支付宝出来的刚从公司离职，他和事业部的总经理是高中同学，所以瞌睡遇到枕头，就找到他来领头做个事，事业部研发中心在天津，他想做这个事必须得带几个自己信得过并且好用的人（是滴，我很好用），所以我和另外一个同事就通过他的内推去了天津（我是对现在的公司及其失望），那番场景那真就是，新老两派之间充满爱意的碰撞，我们抛弃了之前事业部的所有技术积累，全部从0开始。</p>
<p>这篇文章讲的就是在开垦一个后端脚手架的过程中发现了12-Factors，其实很早以前就听过12-Factors，这次逮着机会好好了解下，刚好最近看jimmysong翻译的《迁移到云原生应用架构》，里面提到了12-Factors，这套理论看来是没过时的，借机学习学习。</p>
<p><strong>I. 基准代码</strong></p>
<p>一份基准代码（Codebase），多份部署（deploy）</p>
<p>我们项目是采用类似git flow的方式来管理代码，首先每个应用肯定只有一份基准代码（master），不管是新功能的开发、bugfix、hostfix、release、tag等最终都是基于master的。这样就保证了所有部署的基准代码相同，但每份部署可以使用其不同的版本</p>
<img src="/2018/07/04/12-Factors/codebase-deploys.png" class="" title="来源于12factor.net">

<p><strong>II. 依赖</strong></p>
<p>显式声明依赖关系（ dependency ）</p>
<p>每个应用都有自己的依赖清单，前端是package.json，后端是pom.xml。每个应用都会显示的列出依赖。</p>
<p><strong>III. 配置</strong></p>
<p>在环境中存储配置。</p>
<p>每个应用都有自己的配置文件（yaml），针对不同的场景有不同的配置，发布、预发布、测试等。杜绝把配置写死在代码里的情况发生。</p>
<p><strong>IV. 后端服务</strong></p>
<p>把后端服务(backing services)当作附加资源</p>
<p>数据库、消息队列、数据中心等都是作为基础设施存在的，每个应用是与这些组件都是松耦合。不足是现有的客户场景对可能只能做到逻辑上的隔离，比如数据库虽然逻辑上和应用是隔离的但是物理上可能在一个主机上，因为客户现场可能就跟我们提供几台机器。</p>
<img src="/2018/07/04/12-Factors/attached-resources.png" class="" title="来源于12factor.net">

<p>**<br>V. 构建，发布，运行**</p>
<p>严格分离构建和运行。</p>
<p>项目采用的是阿里云的ci&#x2F;cd方案，构建、发布、运行都是分离的。每个版本对应唯一ID。</p>
<img src="/2018/07/04/12-Factors/release.png" class="" title="来源于12factor.net">

<p><strong>VI. 进程</strong></p>
<p>以一个或多个无状态进程运行应用</p>
<p>12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。</p>
<p>项目中，进程中无共享，权限、session等都存到redis中。</p>
<p><strong>VII. 端口绑定</strong></p>
<p>通过端口绑定(Port binding)来提供服务</p>
<p>这点没什么说的，项目所有的应用提供服务都是通过端口与应用绑定的。</p>
<p><strong>VIII. 并发</strong></p>
<p>通过进程模型进行扩展。</p>
<p>这一点没做好，后端采用的java语言，都知道java是典型的线程模式。所以只能给应用分配相应的资源，让其能纵向扩展，但其实效果不是很好。当然我们有比较简单的方式可以使其进行横向扩展，即每个应用部署多实例的方式进行横向扩展，不过目前没有实践。后续会完善。</p>
<img src="/2018/07/04/12-Factors/process-types.png" class="" title="来源于12factor.net">

<p><strong>IX. 易处理</strong></p>
<p>快速启动和优雅终止可最大化健壮性。</p>
<p>该原则要求应用可以瞬间启动和停止，因为这将有利于应用快速进行横向扩展和变更或者故障后的重新部署，而这两者都是程序健壮性的体现。</p>
<p>快速启动是做到了，但是优雅的终止还带完善。</p>
<p><strong>X. 开发环境与线上环境等价</strong></p>
<p>尽可能的保持开发，预发布，线上环境相同。</p>
<p>我们的发布部署统一走的阿里云效的流水线，流水线的配置除了机器不同其他都一样。</p>
<p><strong>XI. 日志</strong></p>
<p>把日志当作事件流。</p>
<p>这块没做好，待完善。个人觉得是很有必要的，后期会酌情加上日志处理分析组件。从日志输出到读取，到分析，到加工，到视图一条龙服务。</p>
<p><strong>XII. 管理进程</strong></p>
<p>后台管理任务当作一次性进程运行</p>
<p><em>官方说明：</em></p>
<p> 开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p>
<ul>
<li>运行数据移植</li>
<li>运行一些提交到代码仓库的一次性脚本。</li>
</ul>
<p>一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p>
<blockquote>
<p>我理解意思就是应用的管理工具应该随产品一起提供，并且管理任务应该从生产环境中运行最新版本的生产代码的机器上执行此任务。换句话说，从与生产相同的环境中运行一次性管理任务。而不要做类似直接对数据库运行更新这种操作，我理解意思应该是有配套的管理工具而且管理工具是与生产环境同步的，如果需要做一些一次性的维护管理任务，比如数据库移植、A&#x2F;B测试等任务时不要做手动去改数据库这样很容易造成环境搞乱的操作。</p>
</blockquote>
<p>这点在我们项目还是比较弱的，0.1阶段基本上没有统一的管理工具，大家都是通过手动改库等操作达到目的。后期会争取做到这一点。</p>
<p><strong>12-factor 到底好不好，适不适用，我觉得不是绝对的，目前我们遵循这套是因为我们觉得它对我们有指导意义而且是有效的够用的。</strong></p>
<p>源引：</p>
<blockquote><footer><strong>12-Factor</strong><cite><a href="https://12factor.net/zh_cn/">https://12factor.net/zh_cn/</a></cite></footer></blockquote>

<blockquote><footer><strong>12-Factor Apps in Plain English | clearlytech</strong><cite><a href="http://www.clearlytech.com/2014/01/04/12-factor-apps-plain-english/">www.clearlytech.com/2014/01/04/12-factor-apps-plain-english</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>12-Factors</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年开始</title>
    <url>/2019/02/19/2019%E5%B9%B4%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>嗯…..19年过了两个月了是时候开始做个19的规划了，为什么一开始没做，因为我相当不专业的忘了…看斗自己都老火，这就体现了我和专业人士的区别，还是比较业余，谁叫我放荡不羁爱浪，需要自我克制一下，所以19规划还是得做。</p>
<img src="/2019/02/19/2019%E5%B9%B4%E5%BC%80%E5%A7%8B/gratisography-421H.jpg" class="" title="from gratisography">


<h2 id="ok-2019年我需要这么规划一下"><a href="#ok-2019年我需要这么规划一下" class="headerlink" title="ok 2019年我需要这么规划一下"></a>ok 2019年我需要这么规划一下</h2><p><strong>知识丰富</strong></p>
<p><em>时间分布：地铁上、睡前半小时、上班的午间休息、周末每天2-3小时</em></p>
<ol>
<li><p>一个季度看2-3本书，根据书的厚薄进行动态调整，内容：技术类（谁叫我时程序员呢）、提升认知类（说起高大上，就是看一些扫盲的）、自个儿国家人文类（你会发现中国人的牛气冲天以及中国文化的博大精深，绝对时认真的）、心理学类（看看自己内心到底有多么黑暗）</p>
</li>
<li><p>几个知识付费的课程学完，花钱买教训（知识）。</p>
</li>
<li><p>国外的几个网站多逛逛，看英文文档。好歹对得起自己高中唯一一次英文及格的辉煌（而且是在高考）。</p>
</li>
</ol>
<p><strong>提升影响力</strong></p>
<ol>
<li><p>用心经营自己的社交圈，别让自己太独孤求败。</p>
</li>
<li><p>让领导清楚自己在干什么，多和领导进行沟通。</p>
</li>
<li><p>把团队内分享这事做得更好</p>
</li>
</ol>
<p><strong>继续坚持</strong></p>
<p>目标笔记小程序：</p>
<ol>
<li><p>小目标定好，每天上班路上做好目标规划以及时间规划。下班回家睡觉前想一想然后回顾一下。</p>
</li>
<li><p>大目标（按月、年）定好，每天看一遍，为其调整为其努力。</p>
</li>
</ol>
<p>番茄土豆APP：</p>
<p>按照番茄土豆的时间节奏进行，注意身体，保持高效。</p>
<p><strong>变得完美</strong></p>
<ol>
<li><p>为成为完美的男人而努力，经常对着镜子反思自己的缺点，把缺点改的不那么缺。</p>
</li>
<li><p>养成早起早睡的习惯，嗯 现在已经比之前提前了一个小时起床，赞一个。要继续加油。</p>
</li>
<li><p>雾霾散去，锻炼身体，一周2-3次，一次20-30分钟，根据自己老的程度，动态调整。</p>
</li>
<li><p>治理拖延症（指生活上的，工作上我从不拖延！！！），想到事情了马上做，听到指令后马上做（这条主要是针对媳妇儿的教导）</p>
</li>
</ol>
<p><strong>休闲清单</strong></p>
<p><em>时间分布：晚上9点半之前、周末3-4小时</em></p>
<ol>
<li><p>除了学习和工作时间外的休息时间（作为凡人，需要偷懒放松），可供选择的休闲方式：</p>
</li>
<li><p>看电影（嗯，一个月怎么滴也得一场）</p>
</li>
<li><p>网络视频（Running Man、圆桌派、这就是街舞）</p>
</li>
<li><p>听音乐（各种直击灵魂和耳朵的音乐）</p>
</li>
<li><p>偶然性看小说（如果阴差阳错发现有喜欢的，就看一部，下班地铁上会看）</p>
</li>
</ol>
<p><strong>心愿清单</strong></p>
<ol>
<li><p>至少给媳妇儿准备一个惊喜，希望她每天都高高兴兴的。</p>
</li>
<li><p>带老婆孩子去海边玩几天（国外）。</p>
</li>
<li><p>双方父母做一个全面体检，根据身体情况配置上对应的保险。</p>
</li>
<li><p>2-3次自驾游。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>AHA</title>
    <url>/2020/12/01/AHA/</url>
    <content><![CDATA[<img src="/2020/12/01/AHA/a.jpg" class="" title="[Collin Armstrong](https:&#x2F;&#x2F;unsplash.com&#x2F;@brazofuerte)">

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>干研发的有个高频词语：<strong>抽象</strong>，这个词语可应用于各种场景，我今天聊的是代码抽象，在此篇就比较low逼的理解成代码复用吧，不然感觉有点虚。</p>
<p>为啥记录这个呢还是源于近段时间遇到的一些矛盾，重复代码该不该都抽出来，在这之前我会毫不犹豫的说应该，包括现在团队里也几乎是这样的声音，但是是不是就一定对呢？现在我觉得这个观点是不对的，因为我发现有些代码抽出来之后反倒变得越来越不可掌控。</p>
<p>所以我在思考<strong>克制抽象</strong>是不是也应该提出来。为了验证这个思考，遂搜了搜，别说还真有那么些大佬早就提出了这个观点。</p>
<h4 id="AHA"><a href="#AHA" class="headerlink" title="AHA"></a>AHA</h4><p><code>AHA</code> (读作”<a href="https://kentcdodds.com/blog/aha-programming">Aha</a>!” ):<strong>Avoid Hasty Abstractions</strong>（避免草率的抽象）</p>
<p>读了几篇文章特别感动，尤其是Sandi Metz的 <a href="https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction">The Wrong Abstraction</a>，特别有共鸣。</p>
<p><strong>核心观点就是</strong></p>
<blockquote>
<p>宁愿复制而不是错误的抽象</p>
</blockquote>
<p>具体的支撑<strong>克制抽象</strong>内容，这几篇文章说的很清楚了，我就不再来一遍了。</p>
<h5 id="我就给个现实的例子"><a href="#我就给个现实的例子" class="headerlink" title="我就给个现实的例子"></a>我就给个现实的例子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取某个CI模型数据 v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; code 模型code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">object</span>&#125;  格式化之后的模型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCi</span> = <span class="keyword">async</span> (<span class="params">code</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="keyword">await</span> request.<span class="title function_">post</span>(<span class="string">&#x27;/api/v1/model/ci/getCi&#x27;</span>, &#123; code &#125;);</span><br><span class="line">  <span class="comment">// 绑定数据字典</span></span><br><span class="line">  meta.<span class="property">attributes</span> = meta.<span class="property">attributes</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> attr = &#123; ...item &#125;;</span><br><span class="line">    <span class="keyword">if</span> (attr.<span class="property">changeValue</span> === <span class="string">&#x27;dict&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable constant_">DICT</span>.<span class="title function_">get</span>(attr.<span class="property">code</span>)) &#123;</span><br><span class="line">        rlog.<span class="title function_">error</span>(<span class="string">`找不到 <span class="subst">$&#123;attr.code&#125;</span> 对应的数据字典`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attr.<span class="property">dict</span> = <span class="variable constant_">DICT</span>.<span class="title function_">get</span>(attr.<span class="property">code</span>).<span class="property">items</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attr;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> meta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取某个CI模型数据  v2.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; code 模型code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; userVisibleFilter 是否按照模型的userVisible过滤，发现页面不过滤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">object</span>&#125;  格式化之后的模型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCi</span> = <span class="keyword">async</span> (<span class="params">code, userVisibleFilter = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="keyword">await</span> request.<span class="title function_">post</span>(<span class="string">&#x27;/api/v1/model/ci/getCi&#x27;</span>, &#123; code &#125;);</span><br><span class="line">  <span class="comment">// 获取过滤userVisible=true的属性(用户可见)</span></span><br><span class="line">  <span class="keyword">const</span> &#123; attributes &#125; = meta;</span><br><span class="line">  <span class="keyword">const</span> visibleAttributes = userVisibleFilter</span><br><span class="line">    ? attributes.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">userVisible</span>)</span><br><span class="line">    : attributes;</span><br><span class="line">  <span class="comment">// 属性绑定数据字典</span></span><br><span class="line">  meta.<span class="property">attributes</span> = visibleAttributes.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> attr = &#123; ...item &#125;;</span><br><span class="line">    <span class="keyword">if</span> (attr.<span class="property">changeValue</span> === <span class="string">&#x27;dict&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable constant_">DICT</span>.<span class="title function_">get</span>(attr.<span class="property">code</span>)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`找不到 <span class="subst">$&#123;attr.code&#125;</span> 对应的数据字典`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attr.<span class="property">dict</span> = <span class="variable constant_">DICT</span>.<span class="title function_">get</span>(attr.<span class="property">code</span>).<span class="property">items</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attr;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> meta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取某个CI模型数据 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; code 模型code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; userVisibleFilter 是否按照模型的userVisible过滤，发现页面不过滤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; dict 是否需要绑定数据字典</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">object</span>&#125; 格式化之后的模型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCi</span> = <span class="keyword">async</span> (<span class="params">code, userVisibleFilter = <span class="literal">true</span>, dict = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; meta, visibleAttributes &#125; = <span class="keyword">await</span> <span class="title function_">formatMeta</span>(code, userVisibleFilter);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dict) &#123;</span><br><span class="line">    meta.<span class="property">attributes</span> = visibleAttributes;</span><br><span class="line">    <span class="keyword">return</span> meta;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性绑定数据字典</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bindDict</span>(meta, visibleAttributes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取某个CI模型数据  v3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; code 模型code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; userVisibleFilter 是否按照模型的userVisible过滤，发现页面不过滤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; dict 是否需要绑定数据字典</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">object</span>&#125;  格式化之后的模型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCi</span> = <span class="keyword">async</span> (<span class="params">code, userVisibleFilter = <span class="literal">true</span>, dict = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="keyword">await</span> <span class="title function_">formatVisibleAttributes</span>(code, userVisibleFilter);</span><br><span class="line">  <span class="keyword">if</span> (!dict) &#123;</span><br><span class="line">    <span class="comment">// 属性绑定数据字典</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bindDict</span>(meta);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> meta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取某个CI模型数据  v4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; code 模型code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; userVisibleFilter 是否按照模型的userVisible过滤，发现页面不过滤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; dict 是否需要绑定数据字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCi</span> = <span class="keyword">async</span> (<span class="params">code, userVisibleFilter = <span class="literal">true</span>, dict = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="keyword">await</span> <span class="title function_">formatVisibleAttributes</span>(code, userVisibleFilter);</span><br><span class="line">  <span class="comment">// 属性绑定数据字典</span></span><br><span class="line">  <span class="keyword">if</span> (dict) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 用户自建属性（数据字典）</span></span><br><span class="line">      <span class="keyword">const</span> userDict = <span class="keyword">await</span> <span class="title function_">getUserDicts</span>(code);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">bindDict</span>(meta, userDict);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      rlog.<span class="title function_">error</span>(error);</span><br><span class="line">      <span class="keyword">return</span> meta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> meta;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤可见属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">code</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; <span class="variable">userVisibleFilter</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">object</span>&#125;  只包含可见属性的模型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">formatVisibleAttributes</span>(<span class="params">code, userVisibleFilter</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="keyword">await</span> request.<span class="title function_">post</span>(<span class="string">&#x27;/api/v1/model/getCi&#x27;</span>, &#123; code &#125;);</span><br><span class="line">  <span class="keyword">if</span> (meta) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; attributes &#125; = meta;</span><br><span class="line">    <span class="keyword">if</span> (!attributes) &#123;</span><br><span class="line">      <span class="keyword">return</span> meta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 适配后端，使属性正序</span></span><br><span class="line">    attributes = attributes.<span class="title function_">reverse</span>();</span><br><span class="line">    <span class="comment">// 获取过滤userVisible=true的属性(用户可见)</span></span><br><span class="line">    <span class="keyword">if</span> (userVisibleFilter) &#123;</span><br><span class="line">      meta.<span class="property">attributes</span> = attributes.<span class="title function_">filter</span>(</span><br><span class="line">        <span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">userVisible</span> === <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="如上所示"><a href="#如上所示" class="headerlink" title="如上所示"></a>如上所示</h6><blockquote>
<p>总共经历了至少4次的改动，逻辑变得越来越复杂，因为需要适配多种场景，本来我一开始抽出来，理由很简单，因为该api是一个获取底层数据的api，大多数前端的功能都需要调用该api，且都是需要有数据字典的，因为要正确的展示数据，所以我抽了一个方法。</p>
<p>这个时候还是很美好的，不过后续就像 <a href="https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction">The Wrong Abstraction</a>里写的一样，各个使用方或找我或自己对该方法进行了扩展，这方法那是叫惨不忍睹啊，就这还是我重构之后的样子，没重构之前更丑。</p>
<p>那有人就问了，为什么就扩展了呢？</p>
<ol>
<li>个人风格问题，该方法之前满足我得需求现在不满足了，所以我要改它，这样最简单，我可不管其它模块需不需要这个逻辑。</li>
<li>我也知道可能在上面加不太合适，因为加的扩展逻辑不是所有模块都需要的，但是也不是我一个人需要的，比如A、B、C、D…，A、B都需要，那为了不重复写代码，在原有方法上扩展我觉得也还行。</li>
<li>…</li>
</ol>
<p>后来当我发现的时候，我就在群里发出了一个共识。</p>
<ol>
<li>这类公共的api原则上不加<em>个性化的扩展</em>但是可加通用性（不影响整体数据结构且没有业务逻辑，比如：对原始数据进行数据筛选（eg:可见、不可见））的扩展，且加的时候需要与该api的最初作者对齐。</li>
<li>如果要扩展个性化，请自行copy一份代码再修改。</li>
</ol>
<p>我的理由是如果再这么搞那我就不维护了爱咋咋滴………………..当然前面是意淫的咱们是一个team，和为贵。</p>
<p><strong>真正的理由是维护成本会越来越高且与当初抽象的意义渐行渐远。</strong></p>
</blockquote>
<p>可能我给的例子不够有足够力量的说服力，但是我还是觉得，抽象不一定就一定时好的必须的，有些时候我们得反过来想想，任何事情都有两面性。虽然咱没有能力提出牛逼得理论和观点，但是我们可以基于大佬们提出得理论和观点，做些反思、验证…。</p>
<p>有句话不是说吗：<strong>站在巨人的肩膀上。这句话我理解不是说巨人的肩膀才稳，而是说能看得更远。</strong></p>
<h5 id="You-Know"><a href="#You-Know" class="headerlink" title="You Know"></a>You Know</h5><p>Duplication is far cheaper than the wrong abstraction</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>AHA</tag>
      </tags>
  </entry>
  <entry>
    <title>CMDB</title>
    <url>/2020/08/27/CMDB/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前有提过现阶段要把之前的产品推翻重做，做带中台调性的新监控。其中一块核心的内容就是CMDB，虽然CMDB的设计主要是架构师以及后端同学的活，但是架不住我爱掺合啊，这块的前端是我来弄，所以也有正当理由摸鱼撒。所以简单也做个记录，稍微深入的了解下CMDB这玩意，也不能细说一个是我没那么精通另一个我不得保护我们的产品知识产权吗不然老板不把我弄死啊…跑题了。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>CMDB刚开始接触的时候我把它笼统的理解为资产管理，当然这种理解肯定是不对的，太局限。</p>
<p>因为我们的产品大多数情况下都是部署在客户的内网，CMDB在我们产品中的定位：</p>
<ul>
<li>运维对象管理系统。</li>
<li>支撑监控能力的基础设施。</li>
<li>以应用为核心对象串联其它资源。</li>
</ul>
<p><strong>识别运维对象，主要分为两个部分：</strong></p>
<p>基础设施层面：网络设备、服务器、存储设备等；</p>
<p>应用层面：应用元信息、告警配置信息等</p>
<p>当我们识别出运维对象和对象间的关系，并形成了统一的标准之后，接下来要做的事情就是将这些标准固化，固化到信息管理平台中，也就形成了我们说的CMDB（配置管理）。</p>
<h4 id="运维对象识别"><a href="#运维对象识别" class="headerlink" title="运维对象识别"></a>运维对象识别</h4><p>思路跟下图很像，从消费场景入手，识别对象以及对象具有的元素应该有哪些。</p>
<img src="/2020/08/27/CMDB/1.jpg" class="" title="公众号-高效运维">

<img src="/2020/08/27/CMDB/2.png" class="" title="公众号-高效运维">

<p>最终细化一下会识别出几种类型，一个是<strong>基础资源对象</strong>，一个是<strong>应用对象</strong>，一个是<strong>逻辑对象</strong>（组织和人），把这几种类型对象按照相应的规则的建立关系，从而管理属性、关系、状态、场景。</p>
<h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><p>前一小结确定了运维对象识别的核心思想，其中一个大的作用就是指导<strong>资源发现</strong>，我们第一版的发现的方式包含两种：</p>
<ul>
<li><p>网络拓扑发现（自动）：通过SNMP扫描网络，发现其中的网络设备，并判定其间的网络连接关系。</p>
</li>
<li><p>指定类型发现（人工或者流程）：用户指定资产类型，发现时不需要依据判定规则。</p>
<p>下图是我傍的一个后端大佬画的，我悄悄盗过来，镇场面。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">	class 发现规则 &#123;</span><br><span class="line">		+ 判定规则</span><br><span class="line">		+ 收集规则</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	任务 &quot;1&quot; -- &quot;N&quot; 任务执行</span><br><span class="line">	发现代理 -- 发现结果</span><br><span class="line">	任务执行 -- 发现代理</span><br><span class="line">	任务执行 -- 资产数据</span><br><span class="line">	资产数据 -- CMDB</span><br><span class="line"></span><br><span class="line">	发现规则 -- 发现代理</span><br><span class="line">	全局例外 -- 发现代理</span><br><span class="line">	SNMP特殊判定 -- 发现规则</span><br><span class="line">	任务 &quot;1&quot; -- &quot;N&quot; 连接信息</span><br></pre></td></tr></table></figure>



<h4 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h4><p>首先明确一点，以<code>应用为中心</code>，从应用的视角去看，从应用的角度构建资源管理的关系（拓扑关系）。</p>
<p>看了几篇相关的文章基本上，关系类型可简化为下面几种：</p>
<ul>
<li>主从关系。这种关系是一种强父子关系，主不存在了，则从就不存在了。比如主机和网卡、硬盘。</li>
<li>依赖关系。是一种对象属性级之间的关联关系，比如说服务器放在机柜上，机柜摆在某个机房内，这是对象级别的关系。通过对象的属性关联来表达。</li>
<li>连接关系。主机和存储、主机和网络设备的关系，是连接关系。这种关系是动态生成的，是一种实例级的关系。</li>
</ul>
<p>依赖关系和连接关系有什么不同？</p>
<ul>
<li>依赖是一对多的关系，并且这个关系是靠人维护的，比如说机柜上放了很多服务器。</li>
<li>连接是多对多关系，并且这个关系是因为某种“连接”产生的，比如说服务器连接了交换机。通常是通过自动发现来实现。</li>
</ul>
<img src="/2020/08/27/CMDB/3.png" class="" title="公众号-互联网运维杂谈">

<p>我们产品第一版关系设计跟上诉差不太多，只是叫法有一些区别。</p>
<blockquote>
<p>比如主从关系：属于、包含。</p>
<p>依赖关系：运行在</p>
<p>连接关系：连接</p>
</blockquote>
<p>由于各种原因，大概就整理这么多。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>大体围绕CMDB的设计思路如下图。</p>
<img src="/2020/08/27/CMDB/4.png" class="" title="me">

<p><strong>设计的时候考虑的要点：</strong></p>
<ol>
<li>领导要参与，团队理解要一致。通过场景带入的方式。</li>
<li><code>领域</code>分析是核心，除非有必要，不然不考虑技术实现。<ol>
<li>为啥DDD，建立研发、产品等各方的通用语言。</li>
<li>为啥DDD，DDD是一套完整而系统的设计方法，基于这套方法使面对高复杂度的业务，设计思路能更加清晰，设计过程也能更加规范。</li>
</ol>
</li>
<li>从应用视角切入，应用是核心。</li>
<li>CMDB最好分为两个维度的内容进行共创：配置管理、资源管理（资源管理 ≠ 资产管理）。</li>
<li>整理的资源都是服务于各种消费场景的，原则上不应该存在游离态的资源。</li>
<li>CMDB的模型定义一定是有层次的，比如分为核心模型和扩展模型。<ol>
<li>核心模型记录业务、应用和主机，有了核心模型系统基本就能跑起来了。</li>
<li>扩展模型是依赖核心模型扩展出来的，比如基于主机找到关联的机柜等信息，这块信息是有核心模型驱动逐步完善的。</li>
</ol>
</li>
</ol>
<p><code>本文引用的图片，如有侵权请联系我删除。</code></p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><blockquote><footer><strong>优维科技 高效运维</strong><cite><a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzg5Nzc5OA==&mid=2651674578&idx=2&sn=939e98e465b7f1a7bb0b241027a46515&chksm=8bcb947bbcbc1d6d5a4928f209f81aede528233f9b0657dd931735d5730c57674885099cd2f7&mpshare=1&scene=1&srcid=0819MkW8c80sVuYCmwUpP13Z&sharer_sharetime=1597831810952&sharer_shareid=77df2eafd0a472623696abf038541666&version=3.0.27.2701&platform=win&rd2werd=1#wechat_redirect">构建应用CMDB需掌握的三个要素：资源、动作和状态</a></cite></footer></blockquote>

<blockquote><footer><strong>老王 互联网运维杂谈</strong><cite><a href="https://mp.weixin.qq.com/s/iSEw5eVrTrHXjrHP0b1K0g?st=E6D56F7C7B073C5CA0BE786C5363D3A81166FAEBE74EB9D48310237737FC81BD8E64D2FFDEEFBC38EDA177DA423B6883F2B6561AE7376BE1C85EFBCD908AA2B3DE7BB684878EFBE2E586376BB913EE53E2D08AA0984CD4DFBD27CCDCF0F8AAB16CBDC85E4AB545F1397E0650A753DB1066E4FC0020796E606A4D511395EC7BC2&vid=1688851803314412&cst=3B9A8FB5F8073A54B16F68BFD18A87478E098A6169FFDD65418DADA3EC51851EC020FA4E767BF96883B70D4BC62638E2&deviceid=c9cb6c9b-5ea8-4bb7-87a6-280f14284b4f&version=3.0.27.2701&platform=win">如何理解CMDB的套路</a></cite></footer></blockquote>



<blockquote><footer><strong>资源模型</strong><cite><a href="https://zstack-cn.readthedocs.io/zh/latest/userManual/resource.html">zstack</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome Tools-Sources</title>
    <url>/2019/09/20/Chrome%20Tools-Sources/</url>
    <content><![CDATA[<p>嗯，跟前端暧昧的时间还是挺长了，是时候展现真正的技术了。</p>
<img src="/2019/09/20/Chrome%20Tools-Sources/1.jpg" class="">

<p>常在写代码哪有不bug的道理，那对于前端朋友来讲chrome的工具栏基本上能满足大多数场景下的bug排查，对于奉行<strong>假如你暂时不够牛逼，那就善用工具</strong>的我来说，我心荡漾啊。必须记录一下，当然chrome提供的工具太多了，今天暂且主要聊聊Sources，也是我使用频率Top 2，结合一些网上的一些说明加自身的实践来说一说。</p>
<img src="/2019/09/20/Chrome%20Tools-Sources/Inked0_LI.jpg" class="" title="就是这玩意">

<p>不用再于数字不好看这些细节，我们走的是放荡不羁的路线，咱们挨个说啊。</p>
<style> table th:first-of-type { width: 80px; } </style>  

<table>
<thead>
<tr>
<th>数字</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>点击该箭头，移动鼠标到页面上定位到页面元素，跳转到Elements 工具栏。</td>
</tr>
<tr>
<td>2</td>
<td>用于模拟移动设备上的效果。</td>
</tr>
<tr>
<td>3</td>
<td>必用的模块，已加载的全部资源，以域名划分文件夹，调试时从这儿下手找源码，当然我通常直接快捷键Ctrl+P定位文件。</td>
</tr>
<tr>
<td>4、5</td>
<td>Filesystem &amp; Overrides 可以加载本地文件夹，把Chrome当成IDE用。</td>
</tr>
<tr>
<td>6</td>
<td>Content scripts 扩展工具的脚本，比如百度翻译插件等</td>
</tr>
<tr>
<td>7</td>
<td>Snippets 代码片段，不会因为刷新丢失，使用：添加&#x3D;&gt;保存(ctrl+s)&#x3D;&gt;运行(Run)&#x3D;&gt;不用则移除(Remove)</td>
</tr>
<tr>
<td>8</td>
<td>源码面板，在此处进行打断点、修改端点等操作</td>
</tr>
<tr>
<td>9</td>
<td>调试的快捷键面板</td>
</tr>
<tr>
<td>10</td>
<td>变量监察：添加个变量后会一直监察这个变量的值，当前作用域无值时显示&lt; not availble &gt;</td>
</tr>
<tr>
<td>11</td>
<td>Call Stack 函数调用栈，会列出断点的调用堆栈列表。</td>
</tr>
<tr>
<td>12</td>
<td>Scope 断点所在作用域列表，级别划分如下： <ul> <li>Local 当前作用域 展示作用域下的变量</li><li>Closure (x) 闭包作用域，x是函数名称</li><li>Script 标签作用域</li><li>Global 全局作用域Window</li></ul></td>
</tr>
<tr>
<td>13</td>
<td>Breakpoints 源码的断点列表。</td>
</tr>
<tr>
<td>14</td>
<td>XHR&#x2F;fetch Breakpoints 请求断点：ajax和fetch请求都可以在这里打断点并在Call Stack显示调用栈，很方便追踪。</td>
</tr>
<tr>
<td>15</td>
<td>DOM Breakpoints 这里列出html的断点。</td>
</tr>
<tr>
<td>16</td>
<td>Global Listeners 全局监听器：指的是绑定在 window 对象上的事件。</td>
</tr>
<tr>
<td>17</td>
<td>Event Listeners Breakpoints 所有事件的断点：勾选指定类型，比如Mouse&#x2F;click，则所有的click事件都会被断住。</td>
</tr>
</tbody></table>
<p>markdown搞出这个表格太费劲，anyway看着舒服就好，下面聊聊对应上面表格中的一些具体的使用场景。    </p>
<ul>
<li>Filesystem Chrome式的IDE，可以编辑各种文件并且在当前页就可以实时刷新看到效果，如果写单个模块时蛮有用的，比较快。修改后ctrl+s保存，修改的是本地文件，刷新可看到效果。</li>
</ul>
<img src="/2019/09/20/Chrome%20Tools-Sources/Filesystem.gif" class="" title="演示一哈">   

<ul>
<li><p>Overrides 覆盖网络请求的资源，即html、js、css、图片等资源，注意一定是同域名同路径同名的文件才能产生覆盖效果。勾选，Enable Local Overrides，修改文件后ctrl+s保存，修改的是Save as Overrides到本地的文件，刷新可看到效果。  </p>
 <img src="/2019/09/20/Chrome%20Tools-Sources/network-overrides.gif" class="" title="这个就不亲自演示了，网上找一个">  
</li>
<li><p><span style=color:#17640E;background-color:#DDA71D;><strong>Snippets</strong></span>，也是我使用比较多的功能，以前不知道的时候都是找网上现场的js编辑器，但是受网络和维护的影响，有些时候不好用，而且很多还要区分ES5、ES6，自从有了Snippets，随便写各种代码片段超级好用。     但是要注意变量的作用域问题，所以最好用IIFE方式写代码，避免出现错误。  <img src="/2019/09/20/Chrome%20Tools-Sources/snippets.gif" class="" title="演示一波"></p>
</li>
</ul>
<h3 id="源码面板"><a href="#源码面板" class="headerlink" title="源码面板"></a>源码面板</h3><ul>
<li>这也是调试的时候使用频率超级高的区域，ctrl+p定位到文件，行号处右键出现对断点操作的一些选项，分新增和编辑两类。</li>
</ul>
<img src="/2019/09/20/Chrome%20Tools-Sources/breakpoints.gif" class="" title="演示一波"> 

<ul>
<li>Add conditional breakpoint&#x2F;edit breakpoint ，添加&#x2F;修改带条件的断点，比如写a&#x3D;&#x3D;&#x3D;”a”，则表示当a等于”a”时才触发断点，如下图。当条件表达式为真时，触发断点（条件性行断点的颜色为橙色）</li>
</ul>
<img src="/2019/09/20/Chrome%20Tools-Sources/debug03.gif" class="">

<ul>
<li><p>Blackbox Script，黑盒脚本，很多时候是要引用第三方库或框架的，当我们调试时，调试的对象应该是我们自己写的代码，但很多时候，我们经常在焦灼地进行下一步下一步时，突然代码跳到了第三方库或框架的源码上去，多数情况下我们不会关注这些地方的内容，但是它就要跳过去，这种是比较蛋疼的。黑盒脚本就是用来解决这个问题的，它能够把一个脚本文件标记为 “Blackbox Script”，那么我们就永远不可能进入这个文件内部，这个文件对我们来讲就是一个黑盒子。为什么要强调“永远”呢？因为不仅普通的断点不能访问这个被标记了的脚本，其他的，比如说 DOM 断点、事件断点等等都无法访问那个脚本文件内部。</p>
</li>
<li><p>调试面板：Pause on exceptions，在发生异常的地方停顿</p>
</li>
</ul>
<img src="/2019/09/20/Chrome%20Tools-Sources/debug04.gif" class="">


<h3 id="Watch面板"><a href="#Watch面板" class="headerlink" title="Watch面板"></a>Watch面板</h3><ul>
<li>用于监视变量的值。<img src="/2019/09/20/Chrome%20Tools-Sources/watch.png" class=""></li>
</ul>
<p>点击<span style=color:red;><strong>1</strong></span>处，将打开一个内联输入框，您可以在输入框中输入要监视的变量名称。输入完毕，按Enter键，即可将其添加到列表中。监视器将显示添加时变量的当前值。如果变量未设置或找不到，值将显示为<Not Available>。</p>
<p>点击<span style=color:red;><strong>2</strong></span>手动刷新变量。注：监视列表不是变量的实时视图，除非逐步执行。当使用断点逐步执行时，监视列表中的值将自动更新</p>
<p>点击<span style=color:red;><strong>3</strong></span>，删除变量。</p>
<h3 id="Call-stack"><a href="#Call-stack" class="headerlink" title="Call stack"></a>Call stack</h3><p>代码暂停时，可以在Call Stack窗口查看当前的调用栈。展示了代码到暂停处的完整执行路径，这让我们能够深入代码去找出导致错误的原因。最后调用函数在最顶上，所以最好别用匿名函数，不利于调用栈查看。</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>作用域：显示断点所在的作用域，级别划分如下：</p>
<p>Local 当前作用域 展开作用域下的变量<br>Closure (x) 闭包作用域，x是函数名称<br>Script 标签作用域<br>Global 全局作用域Window</p>
<h3 id="DOM-Breakpoints"><a href="#DOM-Breakpoints" class="headerlink" title="DOM Breakpoints"></a>DOM Breakpoints</h3><p>当改变一个节点或者其子元素时，可以设置一个DOM断点：</p>
<ol>
<li><p>点击Elements面板 </p>
</li>
<li><p>找到想要设置断点的元素 </p>
</li>
<li><p>在此元素上右键</p>
</li>
<li><p>Break on –&gt; Subtree modifications &#x2F; Attribute modifications &#x2F; Node removal</p>
<p> Subtree modifications（子树修改）：当前选中的元素，删除、增加其子代或者改变其子代的内容。修改子元素的属性或者当前选中元素有任何改变都不会触发此类型断点<br> Attributes modifications（属性修改）：当前选中的元素，增加、删除其属性，或者修改某个属性值<br> Node Removal（节点移除）：移除当前选中的元素</p>
</li>
</ol>
<h3 id="XHR-x2F-Fetch-Breakpoints"><a href="#XHR-x2F-Fetch-Breakpoints" class="headerlink" title="XHR&#x2F;Fetch Breakpoints"></a>XHR&#x2F;Fetch Breakpoints</h3><p>当XHR的请求URL包含某一特定的字符串时，可以暂停调试代码。DevTools会在XHR调用send()那行代码的地方暂停。</p>
<ol>
<li>点击Sources面板 </li>
<li>展开XHR Breakpoints小窗口</li>
<li>点击“增加断点（Add breakpoint）”</li>
<li>输入一个字符串，只要在某个XHR的请求URL中包含此字符串， 会进入断点（暂停），如下图。</li>
</ol>
<img src="/2019/09/20/Chrome%20Tools-Sources/xhr.gif" class="">

<h3 id="Event-Listeners-Breakpoints"><a href="#Event-Listeners-Breakpoints" class="headerlink" title="Event Listeners Breakpoints"></a>Event Listeners Breakpoints</h3><p>这个断点类型也算是比较常用的一个了，特别是当我们调试别人的代码时，触发某个事件，想找到对应的代码。事件类型可以是很具体的，比如click事件，也可以是某一类别的事件，比如“鼠标事件”。</p>
<ol>
<li>点击Sources面板</li>
<li>展开Event Listener Breakpoints小窗口</li>
<li>勾选某一类别的事件或者是某一具体的事件</li>
</ol>
<p>PS：</p>
<img src="/2019/09/20/Chrome%20Tools-Sources/point_types.png" class="" title="南风一溅-https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5754e1575bbb500064496593">

<p>感谢：</p>
<blockquote><footer><strong>无名小贝勒</strong><cite><a href="https://segmentfault.com/a/1190000008396389">Chrome DevTools — JS调试</a></cite></footer></blockquote>
<blockquote><footer><strong>lsc183</strong><cite><a href="https://www.cnblogs.com/lsc183/p/9915285.html">Chrome DevTools 的 Sources 调试</a></cite></footer></blockquote>
<blockquote><footer><strong>QAQ-YS</strong><cite><a href="https://zhuanlan.zhihu.com/p/80768870">使用 chrome-devtools Sources 面板</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Triggers</title>
    <url>/2018/09/11/CSS%20Triggers/</url>
    <content><![CDATA[<p>在学习浏览器那块，有一块时关于渲染的。</p>
<img src="/2018/09/11/CSS%20Triggers/render.png" class="">

<p>在此过程中发现了一个<a href="https://csstriggers.com/">网站 CSS Triggers</a>，说明哪些css可以触发浏览器的重新渲染（<code>layout</code>、<code>Paint</code>、<code>Composite</code>），所以这个网站是用来告诉开发者不同内核浏览器对css属性修改的重绘&#x2F;回流情况，开发者知道了这些细节可以提高页面性能。</p>
<p>小而美的网站，感谢这两位大佬 <a href="https://twitter.com/aerotwist">Paul</a> and <a href="https://twitter.com/DasSurma">Surma</a>。</p>
<p>我在此简单做个记录，方便后续的使用。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>紫色代表如果layout，中文一般翻译成布局。</li>
<li>浅绿色代表Paint，一般翻译成重绘。</li>
<li>深墨绿色代表Composite，翻译成混合或者合成，重绘和回流任意发生一个就会引起Composite。</li>
</ul>
<h4 id="触发时间："><a href="#触发时间：" class="headerlink" title="触发时间："></a>触发时间：</h4><ul>
<li>Change from default：设置属性(从默认值修改，相当于一开始没设置css)</li>
<li>Subsequernt updates：修改属性(对现有的属性值进行修改)。</li>
</ul>
<p>如图所示，点击每个属性会有详细的说明。</p>
<img src="/2018/09/11/CSS%20Triggers/css.png" class="">]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>The Clean Architecture</title>
    <url>/2021/06/04/Clean%20Architecture/</url>
    <content><![CDATA[<p><a href="https://www.phodal.com/blog/clean-frontend-architecture-in-action/">https://www.phodal.com/blog/clean-frontend-architecture-in-action/</a></p>
<p><a href="https://github.com/WebHu/clean-frontend/tree/master/src/app">https://github.com/WebHu/clean-frontend/tree/master/src/app</a></p>
<p><a href="https://phodal.github.io/clean-frontend/#clean-frontend-architecture%EF%BC%9A%E6%95%B4%E6%B4%81%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84">https://phodal.github.io/clean-frontend/#clean-frontend-architecture%EF%BC%9A%E6%95%B4%E6%B4%81%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84</a></p>
<p><a href="https://medium.com/sharenowtech/front-end-architecture-making-rebuild-from-scratch-not-so-painful-7b2232dc1666#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjZhMWQyNmQ5OTJiZTdhNGI2ODliZGNlMTkxMWY0ZTlhZGM3NWQ5ZjEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2MjMxMzU0NTUsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExNzc4NDE0MDYzNzYyMDYwMjU0NSIsImVtYWlsIjoiZ2FtZWh1NTIwQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJhenAiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJuYW1lIjoiR2FtZSBIdSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS0vQU9oMTRHZ2IyRm1vcGVMX3BISDVGcGg1NWxSN0hNWlJKdDVZZlU1bndNRT1zOTYtYyIsImdpdmVuX25hbWUiOiJHYW1lIiwiZmFtaWx5X25hbWUiOiJIdSIsImlhdCI6MTYyMzEzNTc1NSwiZXhwIjoxNjIzMTM5MzU1LCJqdGkiOiIzZDlmOGE1ZDQ4YjVhNzU4NjE4OTU0MGUxNjhhNWE2MDY5MTgyNTFjIn0.PhtrQiCnK5BF7FUt8pXbs9iEnGe1myxq7jX_ddIqheaCtej9-Hg0vXb1fT179frQHFdMvSZVdUZclegeZBd-YuMIBYNnuDLu0aATYMNljPUjKGgbTllM0Fqe2RYZqJuFP7ij4_0yyeFsGodOIac6eNcrOliR7kVj61SV_dpHwy1oF_gT3Qr9Ci8GHGuFipm-YV0Sc0yqlPuNr8zIQAnPK-c7I2bN1Oc1O8ikaLLCpZasidUAmP22yvHehwcR6WvdjA8ZEKJAaUCBzoYQlFrxTD9onHx8MhDvf503h3J8ti3ss4IXTT9kz97K3-im5SVCIHrcjC61TYMFfUPaHZN95A">https://medium.com/sharenowtech/front-end-architecture-making-rebuild-from-scratch-not-so-painful-7b2232dc1666#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjZhMWQyNmQ5OTJiZTdhNGI2ODliZGNlMTkxMWY0ZTlhZGM3NWQ5ZjEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2MjMxMzU0NTUsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExNzc4NDE0MDYzNzYyMDYwMjU0NSIsImVtYWlsIjoiZ2FtZWh1NTIwQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJhenAiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJuYW1lIjoiR2FtZSBIdSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS0vQU9oMTRHZ2IyRm1vcGVMX3BISDVGcGg1NWxSN0hNWlJKdDVZZlU1bndNRT1zOTYtYyIsImdpdmVuX25hbWUiOiJHYW1lIiwiZmFtaWx5X25hbWUiOiJIdSIsImlhdCI6MTYyMzEzNTc1NSwiZXhwIjoxNjIzMTM5MzU1LCJqdGkiOiIzZDlmOGE1ZDQ4YjVhNzU4NjE4OTU0MGUxNjhhNWE2MDY5MTgyNTFjIn0.PhtrQiCnK5BF7FUt8pXbs9iEnGe1myxq7jX_ddIqheaCtej9-Hg0vXb1fT179frQHFdMvSZVdUZclegeZBd-YuMIBYNnuDLu0aATYMNljPUjKGgbTllM0Fqe2RYZqJuFP7ij4_0yyeFsGodOIac6eNcrOliR7kVj61SV_dpHwy1oF_gT3Qr9Ci8GHGuFipm-YV0Sc0yqlPuNr8zIQAnPK-c7I2bN1Oc1O8ikaLLCpZasidUAmP22yvHehwcR6WvdjA8ZEKJAaUCBzoYQlFrxTD9onHx8MhDvf503h3J8ti3ss4IXTT9kz97K3-im5SVCIHrcjC61TYMFfUPaHZN95A</a></p>
<p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Code Review</title>
    <url>/2018/08/01/Code%20Review/</url>
    <content><![CDATA[<p>以前我对code review是抗拒的，原因在于两方面：</p>
<ol>
<li>总感觉有点脱光了让人看的感觉，没脸。</li>
<li>觉得是浪费时间，研发周期时间都不够还做什么code review。</li>
</ol>
<p>不过后来发现之前的自己是多么愚蠢</p>
<img src="/2018/08/01/Code%20Review/code_review_hierarchy.png" class="">



<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><ul>
<li><p>倒逼团队成员写出更有质量的代码</p>
<blockquote>
<p>（基于编码规范等），让代码可以更好的组织起来，有更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品</p>
</blockquote>
</li>
<li><p>确认自己的设计和实现是一个清楚和简单、正确的</p>
<blockquote>
<p>并且通过review找到问题代码，减少错误和暗坑</p>
</blockquote>
</li>
<li><p>让更多的人了解你所写的模块，并能促进相互学习对方的长处和优点。</p>
</li>
<li><p>提前暴露影响性能和安全的问题</p>
</li>
</ul>
<img src="/2018/08/01/Code%20Review/cr001.png" class="">


<h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><ul>
<li>自动化测试之后，提测之前</li>
<li>前后端联调之后（如果自动化测试还没实现）</li>
</ul>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>评判标准</p>
<ul>
<li>编码规范（比如后端《阿里编程规范》，前端ESLint）</li>
<li>需求覆盖度是否100%</li>
<li>测试用例覆盖度至少满足80&#x2F;20原则</li>
</ul>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ul>
<li>提升团队意识，让大家知道code review的好处和重要性，切忌别把时间安排与code review拿在一起说，它们是两回事，时间够不够条件够不够跟code review好不好无关。</li>
<li>code review落实到产线的专项目标，指定责任人。 </li>
<li>组件core view 团队，定义code view的关注点，持续改进。</li>
</ul>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD(1)</title>
    <url>/2020/09/09/DDD-1/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前面提到过我们要从头做一个产品，暂定代号”新监控“，现阶段是进行概设、预研等阶段，因为涉及到很多模块做概设，业务专家、产品经理、研发、测试等在参与，为了能更有效的产出，所以架构组拎出来了DDD，借用DDD这一套东西期望能让大家跑的更顺一些，当然DDD也仅仅是当成工具来使用，不生搬硬套。</p>
<h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>我知道DDD是，前几年突然就有很多文章提了这个概念挺火的（后面好像有段时间又有很多吐槽DDD的文章），为了了解是个啥玩意，我还还专门买了本书<code>领域驱动设计</code>，说实话没看完，对当年的我来说有点抽象了，因为经历的少了，找不到对应的场景来理解DDD，所以暂时就搁置了，刚好借这个机会，基于实践来学习这玩意，看到底咋样。</p>
<p>先把架构师给的一些资料做个记录</p>
<img src="/2020/09/09/DDD-1/1.png" class="">]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实践</title>
    <url>/2020/03/06/DevOps%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>搬运<a href="https://devops.phodal.com/manual#%E6%80%BB%E8%A7%88">DevOps实施手册</a></p>
<ol>
<li><a href="https://devops.phodal.com/manual#%E5%BB%BA%E7%AB%8B%E6%84%BF%E6%99%AF%E4%B8%8E%E6%96%B9%E5%90%91">建立愿景与方向</a></li>
<li><a href="https://devops.phodal.com/manual#%E5%BA%A6%E9%87%8F">度量：组织、系统现状</a></li>
<li><a href="https://devops.phodal.com/manual#%E5%87%86%E5%85%A5%E6%9D%A1%E4%BB%B6">准入条件</a>。查看是否满足实施 DevOps 的准入条件。</li>
<li><a href="https://devops.phodal.com/manual#%E6%8E%A2%E7%B4%A2%E5%8F%AF%E8%A1%8C%E6%96%B9%E6%A1%88">探索可行方案</a>。即 MVP 尝试</li>
<li><a href="https://devops.phodal.com/manual#mvp">MVP</a>。一次快速的 DevOps 过程和结果的 showcase。</li>
<li><a href="https://devops.phodal.com/manual#%E5%AE%9E%E6%96%BD%E8%90%BD%E5%9C%B0">精细化 DevOps 实施</a></li>
<li><a href="https://devops.phodal.com/manual#%E5%9B%9E%E9%A1%BE%E4%BC%98%E5%8C%96">回顾优化</a></li>
<li><a href="https://devops.phodal.com/manual#%E8%A7%84%E6%A8%A1%E5%8C%96">规模化 DevOps 落地</a></li>
</ol>
<p>对于技术债务，它的利息表现为系统的不稳定性，以及由于临时性手段和缺乏合适的设计、文档工作和测试带来的不断攀升的维护成本。 —— 《架构师应该知道的 97 件事》</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 一点点</title>
    <url>/2019/11/26/Docker%20%E4%B8%80%E7%82%B9%E7%82%B9/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于我们产品是基于docker做的部署，所以不管在开发过程中还是在处理客户现场问题时，多多少少都要用到一些docker命令，此篇做个简单的记录，把我用到的命令记录下来。</p>
<h3 id="先看图"><a href="#先看图" class="headerlink" title="先看图"></a>先看图</h3><p>说命令之前先看图了解下便于更有代入感。</p>
<p><strong>架构图</strong>（不包含Dokcer Engine等细节）</p>
<img src="/2019/11/26/Docker%20%E4%B8%80%E7%82%B9%E7%82%B9/architecture.png" class="" title="docs.docker.com">

<img src="/2019/11/26/Docker%20%E4%B8%80%E7%82%B9%E7%82%B9/docker-arch1.jpg" class="" title="运维之美 -www.hi-linux.com">

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="各种查看"><a href="#各种查看" class="headerlink" title="各种查看"></a>各种查看</h4><h5 id="docker-COMMAND-help"><a href="#docker-COMMAND-help" class="headerlink" title="docker COMMAND --help"></a><code>docker COMMAND --help</code></h5><p>查看docker相关命令的信息，里面有每个命令的说明。</p>
<h5 id="docker-ps、docker-ps-a"><a href="#docker-ps、docker-ps-a" class="headerlink" title="docker ps、docker ps -a"></a><code>docker ps、docker ps -a</code></h5><p>docker ps 这是最常用的，查看容器的运行状态，查问题时不ps一下心里都没底，该命令会列出所有正在运行的容器，当然 等同于docker container ls。</p>
<p>另外docker ps -a，可用于显示所有正在运行和退出的容器。</p>
<h5 id="docker-info、docker-version"><a href="#docker-info、docker-version" class="headerlink" title="docker info、docker version"></a><code>docker info、docker version</code></h5><p>docker info 该命令用于获取当前安装的docker版本以及有关操作系统的几条信息。</p>
<img src="/2019/11/26/Docker%20%E4%B8%80%E7%82%B9%E7%82%B9/1.png" class="">

<p>docker version 列出有关Docker客户端和服务器版本的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Version:           18.09.7</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.1</span><br><span class="line"> Git commit:        2d0083d</span><br><span class="line"> Built:             Fri Aug 16 14:20:06 2019</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.7</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.1</span><br><span class="line">  Git commit:       2d0083d</span><br><span class="line">  Built:            Wed Aug 14 19:41:23 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure>

<h5 id="docker-search-xxx"><a href="#docker-search-xxx" class="headerlink" title="docker search xxx"></a><code>docker search xxx</code></h5><p>该命令只有在我自己玩得时候用过（不想重复造轮子），搜索registry上得镜像。</p>
<h5 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a><code>docker images</code></h5><p> 列出所有的镜像，通常只需要关注REPOSITORY、TAG两列就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@feature1_dev:~# docker images</span><br><span class="line">REPOSITORY                                     TAG                                  IMAGE ID            CREATED             SIZE</span><br><span class="line">172.17.162.141:5000/baymax-nginx               1.17.6                               231d40e811cd        6 months ago        126MB</span><br><span class="line">172.17.162.141:5000/pg10-cmdb                  1.3.0                                284de991364f        10 months ago       370MB</span><br><span class="line">172.17.162.141:5000/myflink                    1.8.1                                96c4d2af10fc        10 months ago       449MB</span><br><span class="line">172.17.162.141:5000/yandex/clickhouse-server   19                                   58006c9044b7        13 months ago       514MB</span><br><span class="line">172.17.162.141:5000/zookeeper                  latest                               f336949ce7a1        19 months ago       148MB</span><br><span class="line">172.17.162.141:5000/redis                      latest                               1babb1dde7e1        20 months ago       94.9MB</span><br><span class="line">172.17.162.141:5000/kafka                      latest                               568143d73a6b        20 months ago       339MB</span><br><span class="line">172.17.162.141:5000/dubbo-admin                latest                               954bf5f29e96        2 years ago         492MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="docker-logs-f-container-name"><a href="#docker-logs-f-container-name" class="headerlink" title="docker logs -f container_name "></a><code>docker logs -f container_name </code></h5><p>查看容器的日志，我用的也较少。</p>
<h5 id="docker-commit-a-quot-gamehu-quot-m-quot-what-f-quot-container-id-IMAGE-REPOSITORY-TAG-96"><a href="#docker-commit-a-quot-gamehu-quot-m-quot-what-f-quot-container-id-IMAGE-REPOSITORY-TAG-96" class="headerlink" title="docker commit -a &quot;gamehu&quot; -m &quot;what f&quot; container_id  IMAGE_REPOSITORY:TAG&#96;"></a><code>docker commit -a &quot;gamehu&quot; -m &quot;what f&quot; container_id </code> IMAGE_REPOSITORY:TAG&#96;</h5><p>通过容器id创建一个新的镜像，</p>
<h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><h5 id="docker-start-、stop、restart、rm、kill"><a href="#docker-start-、stop、restart、rm、kill" class="headerlink" title="docker start 、stop、restart、rm、kill"></a><code>docker start 、stop、restart、rm、kill</code></h5><p>高频使用了，后接 container_id&#x2F;container_name，依次分别为：启动（已存在）容器、停止容器（会进行正常时间等待其停止）、重启重启、删除（已停止）容器、立即停止容器</p>
<h5 id="docker-exec-it-container-id"><a href="#docker-exec-it-container-id" class="headerlink" title="docker exec -it container_id"></a><code>docker exec -it container_id</code></h5><p>使用的较多，通常是为了测试而替换容器内的内容，命令用于访问正在运行的容器，并启用交互模式，可用一些基本的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@feature1_dev:~# docker exec -it 58f5d79c10a3 /bin/bash</span><br><span class="line">root@58f5d79c10a3:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@58f5d79c10a3:/#</span><br></pre></td></tr></table></figure>

<h5 id="docker-inspect-container-id"><a href="#docker-inspect-container-id" class="headerlink" title="docker inspect container_id"></a><code>docker inspect container_id</code></h5><p>查看容器的相关信息，用的也较少。</p>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><h5 id="docker-run、create"><a href="#docker-run、create" class="headerlink" title="docker run、create"></a><code>docker run、create</code></h5><p>基于镜像创建一个新的容器，<code>run</code>是创建并启动，<code>create</code>是创建但不启动。</p>
<p>示例：<code>docker  run -i -t -p 1000:8000  image_name/image_id:TAG</code>，使用镜像，以后台模式启动一个容器,将容器的 8000 端口映射到主机的 1000 端口</p>
<h5 id="docker-build-lt-path-to-docker-file-gt"><a href="#docker-build-lt-path-to-docker-file-gt" class="headerlink" title="docker build &lt;path to docker file&gt;"></a><code>docker build &lt;path to docker file&gt;</code></h5><p>此命令用于从指定的dockerfile构建镜像。</p>
<h5 id="docker-push-IMAGE-NAME-TAG"><a href="#docker-push-IMAGE-NAME-TAG" class="headerlink" title="docker push IMAGE_NAME:TAG"></a><code>docker push IMAGE_NAME:TAG</code></h5><p>做完镜像推送到镜像仓库。</p>
<h5 id="docker-rmi-image-id-image-name"><a href="#docker-rmi-image-id-image-name" class="headerlink" title="docker rmi image_id/image_name"></a><code>docker rmi image_id/image_name</code></h5><p>删除镜像，通常是处理现场问题，要替换镜像的时候用一用。</p>
<h5 id="docker-inspect-image-id"><a href="#docker-inspect-image-id" class="headerlink" title="docker inspect image_id"></a><code>docker inspect image_id</code></h5><p>查看镜像相关信息，我制作镜像的时候会用一用，用的很少。</p>
<h5 id="docker-save-image-id-gt-xx-tar"><a href="#docker-save-image-id-gt-xx-tar" class="headerlink" title="docker save image_id&gt; xx.tar"></a><code>docker save image_id&gt; xx.tar</code></h5><p>导出镜像，通常是修复现场问题时做该操作，导出已修复的镜像。</p>
<h5 id="docker-load-lt-xx-tar"><a href="#docker-load-lt-xx-tar" class="headerlink" title="docker load &lt; xx.tar"></a><code>docker load &lt; xx.tar</code></h5><p>导入镜像，通常是修复现场问题时做该操作，载入已修复后的镜像。</p>
<h5 id="docker-tag-image-id-tag-name"><a href="#docker-tag-image-id-tag-name" class="headerlink" title="docker tag image_id tag_name"></a><code>docker tag image_id tag_name</code></h5><p>修改镜像的TAG，通常是修复现场问题时做该操作。</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><blockquote><footer><strong>Jeff Hale</strong><cite><a href="https://towardsdatascience.com/15-docker-commands-you-should-know-970ea5203421">15 Docker Commands You Should Know</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ES Module</title>
    <url>/2020/02/23/ES%20Module/</url>
    <content><![CDATA[<p>单独记录一下ES Module，听得太多用的也多，但是一直没深刻的认识一下它。</p>
<p>同样的节奏先Google找是否有大佬写这方面的文章。</p>
<p>幸运的是被我找到了<a href="https://twitter.com/linclark">Lin Clark</a>（之前我学习浏览器方面的知识就是读的她的文章）写的，很喜欢她的文章，讲的很生动和具体。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>来来来，搬运一下这一篇<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a>。</p>
<h4 id="模块如何提供帮助？"><a href="#模块如何提供帮助？" class="headerlink" title="模块如何提供帮助？"></a>模块如何提供帮助？</h4><p>模块为您提供了更好的方式来组织这些变量和函数。使用模块，您可以将有意义的变量和函数组合在一起。</p>
<p>这会将这些函数和变量放入模块范围。模块作用域可用于在模块中的功能之间共享变量。</p>
<p>但是与函数作用域不同，模块作用域具有一种使其变量也可用于其他模块的方式。他们可以明确地说出模块中的哪些变量，类或函数应该可用。</p>
<p>当其他模块可以使用某些东西时，这称为导出。导出后，其他模块可以明确地说它们依赖于该变量，类或函数。</p>
<img src="/2020/02/23/ES%20Module/1.png" class="">

<p>因为这是一种明确的关系，所以您可以知道如果删除另一个模块，哪个模块将中断。</p>
<p>一旦能够在模块之间导出和导入变量，就可以更轻松地将代码分解为可以相互独立工作的小块。然后，您可以组合并重组这些块（类似于积木），以从同一组模块创建所有不同种类的应用程序。</p>
<h4 id="ES模块如何工作"><a href="#ES模块如何工作" class="headerlink" title="ES模块如何工作"></a>ES模块如何工作</h4><p>在使用模块进行开发时，您将建立一个依赖关系图。不同依赖项之间的连接来自您使用的任何导入语句。</p>
<p>这些导入语句是浏览器或Node如何确切知道其需要加载哪些代码的方式。您给它一个文件，以用作图形的入口点。从那里开始，它紧随任何import语句以查找其余代码。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/04_import_graph.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/04_import_graph-500x291.png" alt="具有两个依赖关系的模块。 顶部模块是条目。 另外两个使用import语句关联"></a></p>
<p>但是文件本身不是浏览器可以使用的东西。它需要解析所有这些文件，以将它们转换为称为模块记录的数据结构。这样，它实际上知道文件中正在发生什么。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/05_module_record.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/05_module_record-500x287.png" alt="具有各种字段的模块记录，包括RequestedModules和ImportEntries"></a></p>
<p>之后，需要将模块记录转换为模块实例。实例结合了两件事：代码和状态。</p>
<p>该代码基本上是一组指令。这就像如何做某食物的食谱。但是就其本身而言，您不能使用该代码执行任何操作。您需要原材料才能与这些代码一起使用。</p>
<p>什么是状态？就像做食物的原材料。状态是变量在任何时间点的实际值。当然，这些变量只是内存中保存值的空间的昵称。</p>
<p>因此，模块实例将代码（指令列表）与状态（所有变量的值）组合在一起。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/06_module_instance.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/06_module_instance-500x372.png" alt="结合了代码和状态的模块实例"></a></p>
<p>我们需要的是每个模块的模块实例。模块加载的过程将从此入口点文件变为具有模块实例的完整图。</p>
<p>对于ES模块，这分为三个步骤。</p>
<ol>
<li>构造—查找，下载所有文件并将其解析为模块记录。</li>
<li>实例化—查找内存中的空间以放置所有导出的值（但尚未用值填充它们）。然后使导出和导入都指向内存中的那些空间的位置（地址）。这称为链接（引用）。</li>
<li>求值—运行代码以将变量的实际值填写在对应的内存空间。</li>
</ol>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_3_phases.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_3_phases-500x184.png" alt="三个阶段。 构建从单个JS文件到多个模块记录。 实例化链接那些记录。 评估执行代码。"></a></p>
<p>人们谈论ES模块是异步的。您可以将其视为异步的，因为工作分为三个不同的阶段（加载，实例化和评估），并且这些阶段可以分别完成。</p>
<p>这意味着规范确实引入了CommonJS中不存在的一种异步。我将在后面解释，但是在CommonJS中，模块及其下面的依赖项一次全部被加载，实例化和求值，而中间没有任何中断。</p>
<p>但是，步骤本身不一定是异步的。它们可以以同步方式完成。这取决于正在执行的加载。这是因为并非所有内容都由ES模块规范控制。实际上有两部分工作，分别由不同的规范涵盖。</p>
<p>在<a href="https://tc39.github.io/ecma262/#sec-modules">ES模块规范</a>说，你应该如何解析文件到模块的记录，你应该如何实例化和评估模块。但是，它并没有说明如何首先获取文件。</p>
<p>加载程序将获取文件。加载程序在其他规范中指定。对于浏览器，该规范是<a href="https://html.spec.whatwg.org/#fetch-a-module-script-tree">HTML规范</a>。但是您可以根据所使用的平台使用不同的装载程序。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_loader_vs_es.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_loader_vs_es-500x286.png" alt="两个卡通人物。 一个代表说明如何加载模块的规范（即HTML规范）。 另一个代表ES模块规范。"></a></p>
<p>加载程序还精确控制模块的加载方式。它调用ES模块的方法- <code>ParseModule</code>，<code>Module.Instantiate</code>和<code>Module.Evaluate</code>。有点像操纵JS引擎的字符串的p。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/08_loader_as_puppeteer.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/08_loader_as_puppeteer-500x330.png" alt="加载程序图形充当ES模块规范图形的伪造者。"></a></p>
<p>现在，让我们详细介绍每个步骤。</p>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>在构建阶段，每个模块发生三件事。</p>
<ol>
<li>找出从哪里下载包含模块的文件</li>
<li>提取文件（通过从URL下载文件或从文件系统加载文件）</li>
<li>将文件解析为模块记录</li>
</ol>
<h4 id="查找并获取文件"><a href="#查找并获取文件" class="headerlink" title="查找并获取文件"></a>查找并获取文件</h4><p>加载程序将负责查找文件并下载。首先，它需要找到入口点文件。在HTML中，您可以通过脚本标记告诉加载程序在哪里找到它。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/08_script_entry.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/08_script_entry-500x188.png" alt="具有type = module属性和src URL的脚本标记。 src URL有一个文件，它是条目"></a></p>
<p>但是，如何找到下一组模块- <code>main.js</code>直接依赖的模块呢？</p>
<p>这就是导入语句的来源。导入语句的一部分称为模块说明符。它告诉加载程序可以在哪里找到每个下一个模块。</p>
<img src="/2020/02/23/ES%20Module/2.png" class="">

<p>有关模块说明符的一件事：在浏览器和Node之间有时需要对它们进行不同的处理。每个主机都有自己的解释模块说明符字符串的方式。为此，它使用一种称为模块解析算法的模块，该算法在平台之间有所不同。当前，某些可在Node中工作的模块说明符在浏览器中将无法工作，但<a href="https://github.com/domenic/package-name-maps">仍在进行修复</a>。</p>
<p>在此问题修复之前，浏览器仅接受URL作为模块说明符。他们将从该URL加载模块文件。但这不会同时出现在整个图表上。在解析文件之前，您不知道模块需要获取哪些依赖项，并且在获取文件之前无法解析文件。</p>
<p>这意味着我们必须逐层遍历该树，解析一个文件，然后找出其依赖项，然后查找并加载这些依赖项。</p>
<img src="/2020/02/23/ES%20Module/3.png" class="">

<p>如果主线程要等待这些文件中的每一个下载，则许多其他任务将堆积在其队列中。</p>
<img src="/2020/02/23/ES%20Module/4.png" class="">

<p>这样阻塞主线程会使使用模块的应用程序使用起来太慢。这是ES模块规范将算法分为多个阶段的原因之一。将构造分为自己的阶段，使浏览器可以在开始实例化的同步工作之前获取文件并增强对模块图的理解。</p>
<p>这种方法（算法分为多个阶段）是ES模块和CommonJS模块之间的主要区别之一。</p>
<p>CommonJS可以做不同的事情，因为从文件系统加载文件比通过Internet下载花费的时间少得多。这意味着Node可以在加载文件时阻止主线程。并且由于文件已经加载，因此仅实例化和求值（在CommonJS中不是单独的阶段）是有意义的。这也意味着在返回模块实例之前，您要遍历整棵树，加载，实例化和评估任何依赖项。</p>
<img src="/2020/02/23/ES%20Module/5.png" class="">

<p>CommonJS方法有一些含义，我将在后面详细解释。但是，这意味着一件事，就是在带有CommonJS模块的Node中，可以在模块说明符中使用变量。<code>require</code>在寻找下一个模块之前，您正在执行该模块中的所有代码（直到语句）。这意味着当您进行模块解析时，变量将具有一个值。</p>
<p>但是，使用ES模块，您可以在进行任何计算（求值）之前预先建立整个模块图。这意味着您不能在模块说明符中包含变量，因为这些变量尚无值。</p>
<img src="/2020/02/23/ES%20Module/6.png" class="">

<p>但是有时将变量用于模块路径确实很有用。例如，您可能想根据代码在做什么或在什么环境中运行来切换加载的模块。</p>
<p>为了使ES模块成为可能，有一个建议叫做<a href="https://github.com/tc39/proposal-dynamic-import">动态导入</a>。有了它，您可以使用类似的导入语句<code>import(</code>${path}&#x2F;foo.js<code>)</code>。</p>
<p>动态导入的工作原理是，任何使用<code>import()</code>来导入的文件，都会作为一个入口文件从而创建一棵单独的依赖树，被单独处理。</p>
<img src="/2020/02/23/ES%20Module/7.png" class="">

<p>但是要注意一件事–这两棵树中的任何模块都将共享一个模块实例。这是因为加载程序会缓存模块实例。对于特定全局范围内的每个模块，将只有一个模块实例。</p>
<p>这意味着浏览器的工作量更少。例如，这意味着即使多个模块依赖该模块文件，该模块文件也只会被提取一次。（这是缓存模块的一个原因。我们将在评估部分中看到另一个原因。）</p>
<p>加载程序使用称为<a href="https://html.spec.whatwg.org/multipage/webappapis.html#module-map">模块映射的内容</a>来管理此缓存。每个全局变量在单独的模块图中跟踪其模块。</p>
<p>当加载程序获取一个URL时，它将把该URL放入模块映射中，并记下它当前正在获取文件。然后它将发出请求并继续以开始获取下一个文件。</p>
<img src="/2020/02/23/ES%20Module/8.png" class="">

<p>如果另一个模块依赖于同一文件会怎样？加载程序将在模块映射中查找每个URL。如果在其中看到<code>fetching</code>，它将继续前进到下一个URL。</p>
<p>但是模块图不仅跟踪正在获取的文件。模块映射还充当模块的缓存，如下所示。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>现在我们已经获取了该文件，我们需要将其解析为模块记录。这有助于浏览器了解模块的不同部分。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/25_file_to_module_record.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/25_file_to_module_record-500x199.png" alt="该图显示了被解析成模块记录的main.js文件"></a></p>
<p>创建模块记录后，将其放置在模块映射中。这意味着无论何时从此处请求，加载程序都可以将其从该映射中拉出。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/25_module_map.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/25_module_map-500x239.png" alt="模块映射图中的“获取”占位符被模块记录填充"></a></p>
<p>解析有一个细节看似微不足道，但实际上有很大的含义。所有模块都像<strong>严格模式</strong>来解析的。也还有其他的小细节，比如，关键字 <code>await</code> 在模块的最顶层是保留字， <code>this</code> 的值为 <code>undefinded</code>。</p>
<p>这种不同的解析方式称为“解析目标”。如果您解析相同的文件但使用不同的目标，那么最终将得到不同的结果。因此，在开始解析之前就需要知道要解析的文件类型，不管是否是模块。</p>
<p>在浏览器中，这非常简单。您只需放入<code>type=&quot;module&quot;</code>script标签。这告诉浏览器应将此文件解析为模块。并且由于只能导入模块，因此浏览器知道任何导入也是模块。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/26_parse_goal.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/26_parse_goal-500x311.png" alt="加载程序确定main.js是一个模块，因为script标签上的type属性表明是这样，而counter.js必须是一个模块，因为它已导入"></a></p>
<p>但是在Node中，您不使用HTML标记，因此无法选择使用<code>type</code>属性。社区尝试解决此问题的一种方法是使用 <code>.mjs</code>扩展。使用该扩展名告诉Node，“此文件是一个模块”。您会看到人们将其视为解析目标的信号。目前讨论仍在进行中，因此尚不清楚Node社区最终决定使用什么信号。</p>
<p>无论哪种方式，加载程序都将确定是否将文件解析为模块。如果它是一个模块并且有imports，它将重新开始该过程，直到提取并解析了所有文件。</p>
<p>在加载过程的最后，您已经从只有一个入口点文件变成了拥有许多模块记录。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/27_construction.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/27_construction-500x406.png" alt="建设阶段的结果，左侧为JS文件，右侧为3个已解析的模块记录"></a></p>
<p>下一步是实例化此模块并将所有实例连接在一起。</p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>就像我之前提到的，实例化是将代码与状态结合在一起。该状态存在于内存中，因此实例化步骤就是将所有状态链接到内存。</p>
<p>首先，JS引擎创建一个<strong>模块环境记录</strong>（Module Environment Record）。它是管理所有模块记录的变量。然后，它会在内存中找到所有export对应的的地址。模块环境记录将跟踪内存中与每个export相关联的地址。</p>
<p>内存中的这些地址对应的空间尚无法获取其值。只有在运行之后，它们的实际值才会被填写。需要注意的一点是：在此阶段中将初始化所有导出的函数声明。这将使后面的执行阶段变得更加容易。</p>
<p>为了实例化<strong>模块关系图</strong>，引擎会采用<strong>深度优先的后序遍历方式</strong>。这意味着它将到达关系图的最底部（底部不依赖于其他任何东西），并设置其导出。</p>
<img src="/2020/02/23/ES%20Module/9.png" class="">

<p>最终，引擎会把模块下的所有依赖导出连接到当前模块。接着回到上一层把模块的导入连接起来。</p>
<p>请注意，导出和导入均指向内存中的同一位置。</p>
<img src="/2020/02/23/ES%20Module/10.png" class="">

<p>这不同于CommonJS模块。在CommonJS中，整个导出对象在导出时被复制。这意味着导出的任何值（如数字）都是副本，所以在CommonJS如果导出模块以后更改了该值，则导入模块将看不到该更改。</p>
<p>这意味着，如果导出模块以后更改了该值，则导入模块将看不到该更改。</p>
<img src="/2020/02/23/ES%20Module/11.png" class="">

<p>相反，ES模块使用<strong>实时绑定</strong>（Live Binding）。两个模块都指向内存中的相同位置（引用）。这意味着，当导出模块更改值时，该更改将显示在导入模块中。</p>
<p>导出值的模块可以随时更改这些值，但是导入模块不能更改其导入的值，因为是导入的是<strong>只读引用</strong>。不过如果模块导入了一个对象，则它可以更改该对象上的属性值。</p>
<img src="/2020/02/23/ES%20Module/12.png" class="">

<p>之所以ESM采用实时绑定，是因为可以在不运行任何代码的情况下链接到所有模块。这有助于解决循环依赖的问题，在后面的运行(evaluation)阶段会细说。</p>
<p>OK，当实例化结束时，我们得到了所有模块实例，并知道了已完成链接的导出&#x2F;导入变量的内存地址。</p>
<p>现在我们可以开始评估代码，并使用它们的值填充这些内存位置。</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>最后一步是往解析阶段获取的内存地址所在的空间里填充值。JS 引擎通过运行顶层代码（函数外的代码）来完成填充。</p>
<p>除了填充值以外，运行代码还可能引发副作用。例如，一个模块可能会请求服务器。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/40_top_level_code.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/40_top_level_code-500x146.png" alt="模块将在功能之外进行编码，标记为顶级代码"></a></p>
<p>因为这些潜在副作用的存在，所以<strong>模块代码只能运行一次</strong>。<br>前面我们看到，实例化阶段中发生的链接过程可以多次进行，并且每次的结果都一样。但是，如果运行阶段进行多次的话，则可能会每次都得到不一样的结果。</p>
<p>这正是为什么需要有模块映射的原因之一。模块映射通过规范URL，缓存模块，因此每个模块只有一个模块记录。这样可以确保每个模块仅执行一次。与实例化一样，这是深度优先的后遍历。</p>
<p>那我们之前谈到的循环依赖怎么处理呢？</p>
<p>在循环依赖关系中，您最终会在模块关系图中出现循环。你依赖我我依赖你，通常，这会变成很大的循环。</p>
<p>为了解释这个问题，我举个例子。</p>
 <img src="/2020/02/23/ES%20Module/13.png" class="">

<p>首先让我们看一下如果时CommonJS模块会时什么样的。首先，main模块将执行到require语句。然后它将去加载counter模块。</p>
 <img src="/2020/02/23/ES%20Module/14.png" class="">

<p>然后，counter模块将尝试从访问导出的对象<code>message</code>。但是由于尚未在main模块中执行，因此它将返回undefined。JS引擎将在内存中为局部变量分配空间，并将该值设置为undefined。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/42_cjs_variable_2.png"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/42_cjs_variable_2-500x113.png" alt="中间的内存，main.js和内存之间没有连接，但是从counter.js到未定义的内存位置的导入链接"></a></p>
<p>此时会一直运行持续到counter模块顶级代码的末尾。我们想看看是否最终将获得正确的message（在执行main.js之后），因此我们设置了超时时间。然后继续运行到<code>main.js</code>。</p>
 <img src="/2020/02/23/ES%20Module/15.png" class="">

<p>message变量将被初始化并添加到内存中。但是由于两者之间没有连接，因此message在counter模块中仍然是时undefined。</p>
 <img src="/2020/02/23/ES%20Module/16.png" class="">

<p>如果使用实时绑定处理导出，则counter模块最终将看到正确的值。到超时运行时，<code>main.js</code>的执行就已经完成并填充了值。</p>
<p>支持循环依赖是 ESM 设计之初就考虑到的一大因素。也正是这种分（三）阶段设计使其成为可能。</p>
<h4 id="原文地址："><a href="#原文地址：" class="headerlink" title="原文地址："></a>原文地址：</h4><blockquote><footer><strong>Lin Clark</strong><cite><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES Module</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2020/2021</title>
    <url>/2021/07/09/ES2020-2021/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天看阮老师的科技周刊的时候，里头提到了ES2021（作者默认所有的提案最终都会被通过），正好借此梳理一下，ES2020和ES2021，个人使用过的以及后续可能会使用的一些功能，所以这篇不是科普类型，纯属个人喜好的记录。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h5 id="空值合并运算符："><a href="#空值合并运算符：" class="headerlink" title="空值合并运算符：??"></a>空值合并运算符：??</h5><blockquote>
<p>**??**是一个逻辑操作符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 时，则返回右侧操作数，否则返回左侧操作数。所以该运算符完美适配默认值的场景。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="literal">null</span> ?? <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="comment">// expected output: &quot;default string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">0</span> ?? <span class="number">42</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz);</span><br><span class="line"><span class="comment">// expected output: 0</span></span><br></pre></td></tr></table></figure>

<p>多说一句：</p>
<blockquote>
<p>设置默认值以前常用的是：**||**（逻辑或操作符），但是都知道不用用它作为有false和0的情况（因为||**判断时，会把值转换为布尔值，而false和0转为布尔值时都是false，所以对于数字类型和布尔类型的用||设置默认值是不合理的+）</p>
</blockquote>
<h5 id="可选的链接运算符："><a href="#可选的链接运算符：" class="headerlink" title="可选的链接运算符：?."></a>可选的链接运算符：?.</h5><blockquote>
<p>嵌套对象时特别好用。表达式还短。</p>
<p>如果引用为空（null 或 undefined），则表达式会短路返回 undefined。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a &amp;&amp; a.<span class="property">b</span>  &amp;&amp; a.<span class="property">b</span>.<span class="property">c</span>)&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可换成：</span></span><br><span class="line"><span class="keyword">if</span>( a?.<span class="property">b</span>?c)&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a=&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> test=a?.<span class="property">b</span>?.<span class="property">c</span></span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="Promise-any-and-AggregateError"><a href="#Promise-any-and-AggregateError" class="headerlink" title="Promise.any() and AggregateError"></a>Promise.any() and AggregateError</h5><p><code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态</p>
<p><a href="https://www.bookstack.cn/read/es6-3rd/spilt.9.docs-promise.md">阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版</a></p>
<p><a href="https://stackoverflow.com/questions/61732049/what-is-the-difference-between-promise-any-and-promise-race">Promise.race和Promise.any</a></p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;Third&#x27;</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;Second&#x27;</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;First&#x27;</span>)),</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Result: <span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line">.<span class="property">catch</span> (<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"><span class="comment">// expected output: Third</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;Third&#x27;</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;Second&#x27;</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;First&#x27;</span>)),</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Result: <span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line">.<span class="property">catch</span> (<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"><span class="comment">// expected output: Second</span></span><br></pre></td></tr></table></figure>

<h5 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h5><p>全局属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis"><code>globalThis</code></a> 包含全局的 <code>this</code> 值，类似于全局对象（global object）。<code>globalThis</code> 提供了一个标准的方式来获取不同环境下的全局 <code>this</code> 对象（也就是全局对象自身）不用在考虑不同的环境获取方式不一样的问题。</p>
<h5 id="String-replaceAll"><a href="#String-replaceAll" class="headerlink" title="String replaceAll()"></a>String replaceAll()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const newStr = str.replaceAll(regexp|substr, newSubstr|function).</span><br><span class="line">// 当使用一个 `regex`时，您必须设置全局（“ g”）标志</span><br></pre></td></tr></table></figure>

<p><strong><code>replaceAll(pattern,replacement)</code></strong> 方法返回一个新字符串，新字符串所有满足 <code>pattern</code> 的部分都已被<code>replacement</code> 替换。<code>pattern</code>可以是一个字符串或一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a>， <code>replacement</code>可以是一个字符串或一个在每次匹配被调用的函数。</p>
<p> <strong>old：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;zhangsan is wangmazi&#x27;s 舅子,wangmazi is zhangsan&#x27;s 妹夫&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">replace</span>(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;isn&#x27;t&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); </span><br><span class="line"><span class="comment">// expected output:zhangsan isn&#x27;t wangmazi&#x27;s 舅子,wangmazi is zhangsan&#x27;s 妹夫</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换所有,只能用正则</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/is/g</span>, <span class="string">&quot;isn&#x27;t&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr);</span><br><span class="line"><span class="comment">//expected output: zhangsan isn&#x27;t wangmazi&#x27;s 舅子,wangmazi isn&#x27;t zhangsan&#x27;s 妹夫</span></span><br></pre></td></tr></table></figure>

<p><strong>new:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;zhangsan is wangmazi&#x27;s 舅子,wangmazi is zhangsan&#x27;s 妹夫&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">replaceAll</span>(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;isn&#x27;t&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); </span><br><span class="line"><span class="comment">// expected output: zhangsan isn&#x27;t wangmazi&#x27;s 舅子,wangmazi isn&#x27;t zhangsan&#x27;s 妹夫</span></span><br></pre></td></tr></table></figure>



<h5 id="逻辑赋值运算符：-amp-amp-x3D-x3D-x3D"><a href="#逻辑赋值运算符：-amp-amp-x3D-x3D-x3D" class="headerlink" title="逻辑赋值运算符：(&amp;&amp;&#x3D; ||&#x3D; ??&#x3D;)"></a>逻辑赋值运算符：(&amp;&amp;&#x3D; ||&#x3D; ??&#x3D;)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x ||= y;</span><br><span class="line"><span class="comment">// 等同</span></span><br><span class="line">x || (x = y);</span><br><span class="line"> </span><br><span class="line">x &amp;&amp;= y;</span><br><span class="line"><span class="comment">// 等同</span></span><br><span class="line">x &amp;&amp; (x = y); </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span>(x) &#123;</span><br><span class="line">  x = y</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">x ??= y;</span><br><span class="line"><span class="comment">// 等同</span></span><br><span class="line">x ?? (x = y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">x &amp;&amp;= y;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"><span class="comment">//expected output: 2</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h5 id="下划线作为数字分隔符"><a href="#下划线作为数字分隔符" class="headerlink" title="下划线作为数字分隔符"></a>下划线作为数字分隔符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> billion = <span class="number">1000_000_000</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(billion); </span><br><span class="line"><span class="comment">//expected output:1000000000</span></span><br><span class="line"><span class="keyword">const</span> trillion = <span class="number">1000_000_000_000n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trillion.<span class="title function_">toString</span>()); </span><br><span class="line"><span class="comment">//expected output: &quot;1000000000000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000_000_000</span> === <span class="number">1000000000</span>); </span><br><span class="line"><span class="comment">//expected output: true</span></span><br></pre></td></tr></table></figure>

<p><a href="https://backbencher.dev/javascript/numeric-separators">了解更多</a></p>
<h5 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h5><p>我通常在页面初始化需要多个数据且相互之间又没联系的时候会用它。</p>
<blockquote>
<p>**Promise.allSettled()**方法接受一组Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果（不管是<code>fulfilled</code>还是<code>rejected</code>），返回结果是一个对象数组，每个对象表示对应的promise结果。</p>
<p>当有多个彼此不依赖的异步任务成功完成时，或者我们不关心异步操作的结果，只关心每个<code>promise</code>的结果时，通常使用它。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>,<span class="string">&#x27;failed&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">2000</span>,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>,<span class="string">&#x27;b&#x27;</span>));</span><br><span class="line"><span class="comment">// 返回值对象：fulfilled时，对象有value属性，rejected时有reason属性</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//expected output: Array</span></span><br><span class="line"><span class="comment">// 0: &#123;status: &quot;fulfilled&quot;, value: &quot;failed&quot;&#125;</span></span><br><span class="line"><span class="comment">// 1: &#123;status: &quot;rejected&quot;, reason: &quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">// 2: &#123;status: &quot;fulfilled&quot;, value: &quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相比之下，<code>Promise.all()</code> 更适合彼此相互依赖或者在其中任何一个<code>reject</code>时就需要立即结束的场景。即<code>Promise.all()</code> 其实无法确定所有请求都结束。</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://github.com/tc39/ecma262/releases">https://github.com/tc39/ecma262/releases</a></p>
<p><a href="https://backbencher.dev/javascript/es2021-new-features">https://backbencher.dev/javascript/es2021-new-features</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247494289&amp;idx=2&amp;sn=d8a0ef1443954b7a5bae79ec90411cbd&amp;chksm=f9525fd2ce25d6c4f1d1ac2ab8ce6b7034f68f484881a3548549648dfe5aedd427c7b930385b&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247494289&amp;idx=2&amp;sn=d8a0ef1443954b7a5bae79ec90411cbd&amp;chksm=f9525fd2ce25d6c4f1d1ac2ab8ce6b7034f68f484881a3548549648dfe5aedd427c7b930385b&amp;scene=21#wechat_redirect</a></p>
<p><a href="https://tc39.es/ecma262/2021/#sec-web-scripting">https://tc39.es/ecma262/2021/#sec-web-scripting</a></p>
<p><a href="https://www.telerik.com/blogs/learn-new-features-introduced-javascript-es2021">https://www.telerik.com/blogs/learn-new-features-introduced-javascript-es2021</a></p>
<p><a href="https://blog.fundebug.com/2019/08/28/javascript-nullish-coalescing/">https://blog.fundebug.com/2019/08/28/javascript-nullish-coalescing/</a></p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint(no-prototype-builtins)</title>
    <url>/2020/11/24/ESLint-no-prototype-builtins/</url>
    <content><![CDATA[<p>  &#x2F;&#x2F; eslint-disable-next-line no-prototype-builtins</p>
<p>​    if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0;</p>
<p><a href="https://eslint.org/docs/rules/no-prototype-builtins">no-prototype-builtins - Rules - ESLint - Pluggable JavaScript linter</a></p>
<h2 id="Rule-Details"><a href="#Rule-Details" class="headerlink" title="Rule Details"></a>Rule Details</h2><p>This rule disallows calling some <code>Object.prototype</code> methods directly on object instances.</p>
<p>Examples of <strong>incorrect</strong> code for this rule:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*eslint no-prototype-builtins: &quot;error&quot;*/</span><br><span class="line"></span><br><span class="line">var hasBarProperty = foo.hasOwnProperty(&quot;bar&quot;);</span><br><span class="line"></span><br><span class="line">var isPrototypeOfBar = foo.isPrototypeOf(bar);</span><br><span class="line"></span><br><span class="line">var barIsEnumerable = foo.propertyIsEnumerable(&quot;bar&quot;);</span><br></pre></td></tr></table></figure>

<p>Examples of <strong>correct</strong> code for this rule:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*eslint no-prototype-builtins: &quot;error&quot;*/</span><br><span class="line"></span><br><span class="line">var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, &quot;bar&quot;);</span><br><span class="line"></span><br><span class="line">var isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);</span><br><span class="line"></span><br><span class="line">var barIsEnumerable = &#123;&#125;.propertyIsEnumerable.call(foo, &quot;bar&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Event loops</title>
    <url>/2021/07/19/Event-loops/</url>
    <content><![CDATA[<p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">https://html.spec.whatwg.org/multipage/webappapis.html#event-loops</a></p>
<p><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">https://www.w3.org/TR/DOM-Level-3-Events/#event-flow</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>Event loops</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/2022/06/09/GC/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>现场排查OOM，对于GC的一些理解。</p>
<h3 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h3><p><a href="https://vladmihalcea.com/improve-statement-caching-efficiency-in-clause-parameter-padding/">https://vladmihalcea.com/improve-statement-caching-efficiency-in-clause-parameter-padding/</a></p>
<p><a href="http://technodibble.blogspot.com/2015/02/hibernate-in-clause-outofmemory.html">http://technodibble.blogspot.com/2015/02/hibernate-in-clause-outofmemory.html</a></p>
<p><a href="http://xmlandmore.blogspot.com/2014/10/jdk-8-is-tuning-maxnewsize-in-g1-gc.html">http://xmlandmore.blogspot.com/2014/10/jdk-8-is-tuning-maxnewsize-in-g1-gc.html</a></p>
<p>heap内存归还给操作系统:G1GC <a href="https://openjdk.org/jeps/346">https://openjdk.org/jeps/346</a></p>
<p><a href="https://www.youtube.com/watch?v=BTIcja5xcK0">https://www.youtube.com/watch?v=BTIcja5xcK0</a></p>
<p><a href="https://www.youtube.com/watch?v=IB7oFVYTOJ0">https://www.youtube.com/watch?v=IB7oFVYTOJ0</a></p>
<p><a href="https://gceasy.io/gc-recommendations/important-g1-gc-arguments.jsp">https://gceasy.io/gc-recommendations/important-g1-gc-arguments.jsp</a><br><a href="https://github.com/Snailclimb/JavaGuide/blob/83efb36fb56d197f2c4b471084b884c6a4f23e37/docs/books/java.md">https://github.com/Snailclimb/JavaGuide/blob/83efb36fb56d197f2c4b471084b884c6a4f23e37/docs/books/java.md</a></p>
<p><a href="https://www.douban.com/doulist/2545443/">https://www.douban.com/doulist/2545443/</a></p>
<p><a href="https://www.baeldung.com/jvm-parameters">https://www.baeldung.com/jvm-parameters</a><br><a href="https://blog.csdn.net/myth_g/article/details/119855832">https://blog.csdn.net/myth_g/article/details/119855832</a><br><a href="https://docs.oracle.com/en/java/javase/11/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304">https://docs.oracle.com/en/java/javase/11/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304</a></p>
<p><a href="https://programmer.ink/think/jvm-series-jvm-tuning-jps-jstat-jmap-jhat-jstack-jinfo.html">https://programmer.ink/think/jvm-series-jvm-tuning-jps-jstat-jmap-jhat-jstack-jinfo.html</a></p>
<p><a href="https://docs.oracle.com/javase/10/jrockit-hotspot/logging.htm#JRHMG121">https://docs.oracle.com/javase/10/jrockit-hotspot/logging.htm#JRHMG121</a><br><a href="https://confluence.atlassian.com/confkb/unrecognized-jvm-gc-options-when-using-java-11-1002472841.html">https://confluence.atlassian.com/confkb/unrecognized-jvm-gc-options-when-using-java-11-1002472841.html</a></p>
<p><a href="https://dzone.com/articles/understanding-garbage-collection-log">https://dzone.com/articles/understanding-garbage-collection-log</a></p>
<p><a href="https://sematext.com/blog/java-garbage-collection-tuning/">https://sematext.com/blog/java-garbage-collection-tuning/</a></p>
<p><a href="https://sematext.com/blog/java-garbage-collection-tuning/">https://sematext.com/blog/java-garbage-collection-tuning/</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1811734">https://cloud.tencent.com/developer/article/1811734</a></p>
<p><a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5">https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5</a></p>
<p><a href="https://www.javatang.com/archives/2017/10/19/51301886.html">https://www.javatang.com/archives/2017/10/19/51301886.html</a></p>
<p><a href="https://morioh.com/p/935f204ccc1a">https://morioh.com/p/935f204ccc1a</a></p>
<p><a href="https://dzone.com/articles/jvm-tuning-using-jcmd">https://dzone.com/articles/jvm-tuning-using-jcmd</a></p>
<p><a href="https://sematext.com/blog/java-garbage-collection-logs/">https://sematext.com/blog/java-garbage-collection-logs/</a></p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>dump文件分析用的MAT。</p>
<p><a href="https://zhanglvmeng.gitbooks.io/mat-usage/content/kai-shi-shi-yong/yan-shen-yue-du/shi-yong-mat-de-10-ge-jian-yi.html">https://zhanglvmeng.gitbooks.io/mat-usage/content/kai-shi-shi-yong/yan-shen-yue-du/shi-yong-mat-de-10-ge-jian-yi.html</a></p>
<h3 id="线程分析"><a href="#线程分析" class="headerlink" title="线程分析"></a>线程分析</h3><p><a href="https://geekflare.com/generate-analyze-thread-dumps/">https://geekflare.com/generate-analyze-thread-dumps/</a></p>
<p><a href="https://blog.fastthread.io/2016/02/22/thread-dump-analysis-pattern-repetitive-strain-injury-rsi/">https://blog.fastthread.io/2016/02/22/thread-dump-analysis-pattern-repetitive-strain-injury-rsi/</a></p>
<p>当应用程序出现性能瓶颈时，大部分线程将开始在有问题的瓶颈区域累积。这些线程将具有相同的堆栈跟踪。因此，每当大量线程表现出相同&#x2F;重复的堆栈跟踪时，就应该调查这些堆栈跟踪。这可能表示性能问题。</p>
<p>以下是一些这样的场景：</p>
<ul>
<li>假设您的 SOR 或外部服务正在变慢，那么大量线程将开始等待其响应。在这种情况下，这些线程将显示相同的堆栈跟踪。</li>
<li>假设一个线程获得了一个锁并且它从未释放，那么在同一执行路径中的其他几个线程将进入阻塞状态，显示相同的堆栈跟踪。</li>
<li>如果循环（for 循环、while 循环、do..while 循环）条件未终止，则执行该循环的多个线程将显示相同的堆栈跟踪。<br>当出现上述任何一种情况时，应用程序的性能和可用性都会受到质疑。</li>
</ul>
<p>重点关注：Troubleshooting Tools、Monitoring Tools<br><a href="https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html">https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html</a></p>
<p><a href="https://programmer.ink/think/jvm-series-jvm-tuning-jps-jstat-jmap-jhat-jstack-jinfo.html">https://programmer.ink/think/jvm-series-jvm-tuning-jps-jstat-jmap-jhat-jstack-jinfo.html</a></p>
<p><a href="https://www.hollischuang.com/archives/110">https://www.hollischuang.com/archives/110</a></p>
<p>线程状态产生的原因</p>
<ul>
<li><p>runnable:状态一般为RUNNABLE。</p>
</li>
<li><p>in Object.wait():等待区等待,状态为WAITING或TIMED_WAITING。</p>
</li>
<li><p>waiting for monitor entry:进入区等待,状态为BLOCKED。</p>
</li>
<li><p>waiting on condition:等待区等待、被park。</p>
</li>
<li><p>sleeping:休眠的线程,调用了Thread.sleep()。</p>
</li>
</ul>
<p><a href="https://jakubstransky.com/2017/12/19/hotspot-jvm-internal-threads/">https://jakubstransky.com/2017/12/19/hotspot-jvm-internal-threads/</a></p>
<h4 id="Tomcat线程模型"><a href="#Tomcat线程模型" class="headerlink" title="Tomcat线程模型"></a>Tomcat线程模型</h4><blockquote>
<p>NIO: synchronous and non blocking. It can support large concurrency better than traditional bio. This mode is adopted by default after Tomcat 8.0.</p>
</blockquote>
<h5 id="NiO"><a href="#NiO" class="headerlink" title="NiO"></a>NiO</h5><p><a href="https://developpaper.com/nio-optimization-principle-and-tomcat-thread-model/">https://developpaper.com/nio-optimization-principle-and-tomcat-thread-model/</a></p>
<p>Tomcat’s NiO model has more poller rolesAcceptor、PollerandHandler worker thread pool。 Are these three roles very familiar? If poller is replaced by reactor, is it the reactor model. Yes, Tomcat’s NiO model is based onMaster slave reactor modelIt’s just a change of name.</p>
<p>AcceptorThe: accepter thread is specifically responsible for establishing network connections（accept）。 After the new connection is created, instead of directly using the worker thread to process the request, the request is first sent to the poller buffer queue.<br>Poller: in poller, a selector object is maintained. After poller takes the connection from the buffer queue, it registers in the selector and blocks to wait for read and write ready（Read wait ready, send wait ready）。<br>Handlers: traverse the selector to find out the ready IO operations in the selector and hand them over to the worker thread for processing（Read memory read, decode, process, encode, send memory write）。</p>
<p>  <a href="https://www.cnblogs.com/grey-wolf/p/13740845.html">https://www.cnblogs.com/grey-wolf/p/13740845.html</a></p>
<p>调优<br>  <a href="https://tomcat.apache.org/tomcat-9.0-doc/config/http.html">https://tomcat.apache.org/tomcat-9.0-doc/config/http.html</a><br>  <a href="https://www.datadoghq.com/blog/tomcat-architecture-and-performance/">https://www.datadoghq.com/blog/tomcat-architecture-and-performance/</a></p>
]]></content>
  </entry>
  <entry>
    <title>GraphQL</title>
    <url>/2018/08/06/GraphQL/</url>
    <content><![CDATA[<p>前后端关于CMDB的交互决定选用GraphQL，因为第一次听说就抓紧时间了解了以下是个什么东西。</p>
<h2 id="GraphQL干嘛的？"><a href="#GraphQL干嘛的？" class="headerlink" title="GraphQL干嘛的？"></a>GraphQL干嘛的？</h2><blockquote><footer><strong>Overview</strong><cite><a href="http://spec.graphql.cn/#sec-Overview-">spec.graphql.cn/#sec-Overview-</a></cite></footer></blockquote>

<p><em>GraphQL语言致力于提供一种直观的弹性语法系统，用以描述客户端程序设计时的数据需求以及数据交互行为。</em></p>
<p>说的直白点就是能让API设计变得更加的灵活，你想要什么数据就给你什么数据，不多不少。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>目前只有CMDB那一块使用的GraphQL，其它的前后端交互还是用的传统的方式。</p>
<p>不过这并不影响我对它的兴趣，新东西总是喜欢琢磨琢磨，更何况GraphQL有大厂的背书，那证明它的潜力是巨大地。</p>
<ul>
<li>传统的api设计，如果想要多种场景公用一个接口，比如都是获取用户信息，A场景需要name，B场景需要name+sex，C场景需要name+introduction，很显然都是获取用户信息，但是每个场景要求的数据不一样，如果简单粗暴的直接返回整个用户信息，很显然不太科学，极端一点假设用户有20个字段，调用方只需要一个字段，你给20个字段完全是浪费，另一种方案是写三个接口，但是三个接口很显然太冗余了，所以通常是公用一个接口，但是共有一个接口就肯定免不了一堆逻辑判断,此外，这样还会造成不同业务之间的耦合，每次发布都需要各个业务场景一起测试和回归。</li>
</ul>
<p><strong>这种时候痛点就出现了，不重用接口则没法提高开发效率，重用接口则会有这些问题。</strong></p>
<p>这个时候GraphQL就体现它的优势了，我认为它的出现就是为了解决上面的痛点。出现上面的问题的根本原因我认为在于，前端不能直白的告诉后端我要什么数据，必须通过后端经过对应的翻译转换，因为前端没有合适的方式来告诉我们A只需要name，B只需要name+sex，它可能就给我们一个userId然后给个businessCase然后我们根据businessCase来进行逻辑判断，进行数据查询，进行数据筛选以及过滤。</p>
<h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>花点时间写这个，是因为觉得GraphQL算是开阔了我的技术视野，我们其实还用的很浅，他的<strong>一切皆是图</strong>、<strong>API无版本（某些场景）</strong>的思想，以及schema、别名、片段、指令、mutation、元字段等概念让GraphQL灵活的像猴哥，至少目前我们没有遇到有什么场景是满足不了的，至少对于技术浅薄的我来说是有开到脑洞。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247501981&idx=1&sn=4cefea59913ac291f7fafcf4a3a007a0&chksm=ebd5f7b1dca27ea779ea35b8521d91b85239d9b5d64489e394be76347c72a0968ce616b1597d&mpshare=1&scene=1&srcid=0108kwmT37WixQYNhMCOnZQ4&sharer_sharetime=1610066466233&sharer_shareid=77df2eafd0a472623696abf038541666&version=3.1.1.3001&platform=win#rd">我为什么要放弃RESTful，选择拥抱GraphQL</a></p>
<p><a href="https://github.com/chentsulin/awesome-graphql">graphql工具社区</a></p>
<p>学习地址：</p>
<blockquote><footer><strong>learn</strong><cite><a href="http://graphql.cn/learn/">graphql.cn/learn</a></cite></footer></blockquote>

<blockquote><footer><strong>learn</strong><cite><a href="https://www.howtographql.com">www.howtographql.com</a></cite></footer></blockquote>

<blockquote><footer><strong>graphql-up</strong><cite><a href="https://github.com/prisma/graphql-up">github.com/prisma/graphql-up</a></cite></footer></blockquote>



<p>这是我用nodejs实现的很简单的demo：</p>
<blockquote><footer><strong>demo</strong><cite><a href="https://github.com/WebHu/graph_demo.git">github.com/WebHu/graph_demo.git</a></cite></footer></blockquote>

<p>这是通过howtographql搭建的demo</p>
<blockquote><footer><strong>demo</strong><cite><a href="https://github.com/WebHu/graph_apollo_demo.git">github.com/WebHu/graph_apollo_demo.git</a></cite></footer></blockquote>



<p><a href="https://flaviocopes.com/graphql-vs-rest/">https://flaviocopes.com/graphql-vs-rest/</a></p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp</title>
    <url>/2020/02/28/Gulp/</url>
    <content><![CDATA[<p>是这样的，最近呢在捣鼓一系列升级的问题，刚好就遇到了Gulp从3升到4的过程，所以借机呢稍微深入的了解了一下Gulp，在此做个简单的记录。</p>
<p>Gulp我一开始理解的他就是个样式处理工具，但实际了解下来，才发现它原来跟Grunt一样是个构建工具。</p>
<p>那就开整吧，我按我的节奏来哈：</p>
<ol>
<li><strong>了解一些底层</strong>，知道是怎么来的。</li>
<li><strong>了解基本概念</strong>，不但要知道是怎么来的，还要知道是干啥的。</li>
<li><strong>了解语法</strong> ，3-&gt;4升级实操</li>
</ol>
<h3 id="一些底层"><a href="#一些底层" class="headerlink" title="一些底层"></a>一些底层</h3><p>Gulp 是基于 <a href="http://nodejs.org/">Node.js</a> 的项目，它的核心使用的是Node.js四种流中的<a href="http://nodejs.cn/s/fhVJQM">Transform</a> - <code>在读写过程中可以修改或转换数据的 Duplex流</code> 。即可读又可写的流，它会对传给它的对象做一些转换的操作。</p>
<p>因为基于Streams，而Streams和其它数据处理方法相比最大的优点：</p>
<ol>
<li>内存效率：我们无需先将大量数据加载到内存中即可进行处理。它就像往河里（Pipe）倒水一样，一桶水你可以分很多次倒。</li>
<li>时间效率：拥有数据后立即开始处理数据所需的时间大大减少，而不必等到整个有效负载都传输完成才开始处理。还是倒水的例子，你倒入河里（Pipe）马上就流走了不会等着一桶水倒完之后才流走。</li>
</ol>
<p>Streams的<em>cheatsheet</em>：</p>
<img src="/2020/02/28/Gulp/stream_cc.png" class="" title="from https:&#x2F;&#x2F;devhints.io&#x2F;nodejs-stream">



<p>Duplex：</p>
<img src="/2020/02/28/Gulp/duplex.png" class="" title="from [Duplex](http:&#x2F;&#x2F;codewinds.com&#x2F;blog&#x2F;2013-08-31-nodejs-duplex-streams.html)">



<p>Streams内部实现流程图：</p>
<img src="/2020/02/28/Gulp/stream01.png" class="" title="from [DauleDK](https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;3694288&#x2F;dauledk)">



<p>想了解细节的推荐去看<a href="https://github.com/substack/stream-handbook">stream-handbook</a>、<a href="http://www.youtube.com/watch?v=QgEuZ52OZtU">Video introduction to node.js streams</a>。通过学习之后我真的认为Node的Streams是正儿八经牛X的存在，对我来说简直是一颗遗珠啊。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>Task</strong></p>
<p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable (<a href="https://www.gulpjs.com.cn/docs/getting-started/async-completion">后面会详细讲解</a>) 类型值的函数。 </p>
<p>任务（tasks）可以是 <strong>public（公开）</strong> 或 <strong>private（私有）</strong> 类型的。</p>
<ul>
<li><strong>公开任务（Public tasks）</strong> 从 gulpfile 中被导出（export），可以通过 <code>gulp</code> 命令直接调用。</li>
<li><strong>私有任务（Private tasks）</strong> 被设计为在内部使用，通常作为 <code>series()</code> 或 <code>parallel()</code> 组合的组成部分。</li>
</ul>
<p><strong>Gulpfile</strong></p>
<p>Gulp 允许你使用现有 JavaScript 知识来书写 gulpfile 文，gulpfile 是项目目录下名为 <code>gulpfile.js</code> （或者首字母大写 <code>Gulpfile.js</code>，就像 Makefile 一样命名）的文件，在运行 <code>gulp</code> 命令时会被自动加载。在这个文件中，你经常会看到类似 <code>src()</code>、<code>dest()</code>、<code>series()</code> 或 <code>parallel()</code> 函数之类的 gulp API，除此之外，纯 JavaScript 代码或 Node 模块也会被使用。任何导出（export）的函数都将注册到 gulp 的任务（task）系统中。</p>
<p><strong>处理文件</strong></p>
<p>gulp 暴露了 <code>src()</code> 和 <code>dest()</code> 方法用于处理计算机上存放的文件。</p>
<p><code>src()</code> 接受 <a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs">glob</a> 参数，并从文件系统中读取文件然后生成一个 <a href="https://nodejs.org/api/stream.html">Node 流（stream）</a>。它将所有匹配的文件读取到内存中并通过流（stream）进行处理。</p>
<p>流（stream）所提供的主要的 API 是 <code>.pipe()</code> 方法，用于连接转换流（Transform streams）或可写流（Writable streams）。</p>
<p><code>dest()</code> 接受一个输出目录作为参数，并且它还会产生一个 <a href="https://nodejs.org/api/stream.html">Node 流（stream）</a>，通常作为终止流（terminator stream）。当它接收到通过管道（pipeline）传输的文件时，它会将文件内容及文件属性写入到指定的目录中。gulp 还提供了 <code>symlink()</code> 方法，其操作方式类似 <code>dest()</code>，但是创建的是链接而不是文件（ 详情请参阅 <a href="https://www.gulpjs.com.cn/docs/api/symlink"><code>symlink()</code></a> ）。</p>
<p>大多数情况下，利用 <code>.pipe()</code> 方法将插件放置在 <code>src()</code> 和 <code>dest()</code> 之间，并转换流（stream）中的文件。</p>
<p><strong>Glob</strong></p>
<p>glob 是由普通字符和&#x2F;或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件。</p>
<blockquote>
<p>*(一个星号)：在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用。</p>
<p>** (两个星号)：在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用。请确保适当地限制带有两个星号的 glob 的使用，以避免匹配大量不必要的目录。</p>
<p> ! (取反)：由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面。第一个 glob 匹配到一组匹配项，然后后面的取反 glob 删除这些匹配项中的一部分。如果取反 glob 只是由普通字符组成的字符串，则执行效率是最高的。</p>
</blockquote>
<p><strong>插件</strong></p>
<p>Gulp 插件实质上是 <a href="https://github.com/rvagg/through2">Node 转换流（Transform Streams）</a>，它封装了通过管道（pipeline）转换文件的常见功能，通常是使用 <code>.pipe()</code> 方法并放在 <code>src()</code> 和 <code>dest()</code> 之间。他们可以更改经过流（stream）的每个文件的文件名、元数据或文件内容。</p>
<p><strong>Gulp</strong></p>
<img src="/2020/02/28/Gulp/Gulp.png" class="" title="from 我">



<p>Gulp的<em>cheatsheet</em>：</p>
<img src="/2020/02/28/Gulp/gulp01.png" class="" title="from https:&#x2F;&#x2F;github.com&#x2F;osscafe&#x2F;gulp-cheatsheet">



<img src="/2020/02/28/Gulp/gulp02.png" class="" title="from https:&#x2F;&#x2F;github.com&#x2F;osscafe&#x2F;gulp-cheatsheet">



<h3 id="Gulp-3-gt-4-实操"><a href="#Gulp-3-gt-4-实操" class="headerlink" title="Gulp 3 - &gt; 4 实操"></a>Gulp 3 - &gt; 4 实操</h3><p>3其实算是废弃了，当然还是可以用的，只是不维护了。所以升一升还是极好的。</p>
<ol>
<li>现卸载现有的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall gulp --save-dev</span><br><span class="line">npm uninstall gulp -g</span><br></pre></td></tr></table></figure>

<p>你以为升级完之后是这样色儿的</p>
<img src="/2020/02/28/Gulp/a.gif" class="">

<p>但是一执行是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AssertionError [ERR_ASSERTION]: Task function must be specified</span><br></pre></td></tr></table></figure>

<img src="/2020/02/28/Gulp/b.jpeg" class="">

<p>这是因为Gulp4只支持 2 个参数的 <code>gulp.task</code>了，所以就意味着咱们以前的代码得改了，那咱们就有疑问了怎么改呢？先了解下改了什么。</p>
<h4 id="series、parallel"><a href="#series、parallel" class="headerlink" title="series、parallel"></a><strong>series、parallel</strong></h4><p>官网说了：Gulp.js 4.0引入了series（）和parallel（）方法来组合任务： </p>
<ul>
<li><p>series（…）按指定的顺序一次运行一个任务，并返回一个按给定的任务 &#x2F; 函数的顺序执行的函数。</p>
</li>
<li><p>parallel（…）以任何顺序同时运行任务，并返回一个能并行执行给定的任务&#x2F;函数的函数</p>
<p>可见Gulp做出了很大的努力来实现对任务运行方式的更多控制，提供了选择顺序或并行执行任务的能力，避免之前需要添加别的依赖（传统上是使用 <a href="https://www.npmjs.com/package/run-sequence">run-sequence</a>）或者丧心病狂地手动分配任务执行的依赖。。</p>
</li>
</ul>
<p>所以，如果之前你有这样一个任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;copy_css&#x27;, [&#x27;clean_temp&#x27;], function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>它将会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;copy_css&#x27;, gulp.series(&#x27;clean_temp&#x27;, function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>当做出这个改变时，不要忘了你的任务函数现在在 <code>gulp.series</code> 的回调函数里。所以你需要在尾部多出来的那个括号。这很容易被忽略。</p>
<p>注意到 <code>gulp.sereis</code> 与 <code>gulp.parallel</code> 会返回函数，所以它们可以被嵌套。当你的任务有多个依赖时，你可能需要经常地嵌套它们。</p>
<p>例如，这个常见的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;default&#x27;, [&#x27;copy_css&#x27;, &#x27;copy_image&#x27;], function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;default&#x27;, gulp.series(gulp.parallel(&#x27;copy_css&#x27;, &#x27;copy_image&#x27;), function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h4><p>这是一个坑点，在 Gulp 3 中，如果你为多个任务指定了同一个依赖，并且它们都在运行时，Gulp 会意识到它们都依赖相同的任务，然后只执行一次这个被依赖的任务。而在 Gulp 4 中，我们不再指定”依赖”，而是使用 <code>series</code> 或 <code>parallel</code> 来组合函数，这导致 Gulp 不能判断哪些任务在当它只应运行一次时会被多次运行。所以我们需要改变我们对依赖的处理方式。我们需要把依赖从任务中抽离出来，并在一个更大的“父级”任务中把依赖指明成一个 <code>series</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这些任务不再有任何依赖</span><br><span class="line">gulp.task(&#x27;copy_css&#x27;, function() &#123;...&#125;);</span><br><span class="line">gulp.task(&#x27;copy_image&#x27;, function() &#123;...&#125;);</span><br><span class="line">gulp.task(&#x27;clean_temp&#x27;, function() &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">// default 依赖于 copy_css 与 copy_image</span><br><span class="line">gulp.task(&#x27;default&#x27;, gulp.series(&#x27;clean_temp&#x27;, gulp.parallel(&#x27;copy_css&#x27;, &#x27;copy_image&#x27;)));</span><br></pre></td></tr></table></figure>



<h4 id="使用普通函数"><a href="#使用普通函数" class="headerlink" title="使用普通函数"></a>使用普通函数</h4><p>因为现在每一个任务实际上都只是一个函数，也并没有依赖或者其他特别的东西。所以我们不必每个任务都用 <code>gulp.task</code> 来完成。开始拥抱独立的函数而不用再像之前通过传入 <code>gulp.task</code> 的回调函数来写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp.task(&#x27;copyGlobalImage&#x27;, function() &#123;...&#125;);</span><br><span class="line">gulp.task(&#x27;copyCss&#x27;, function() &#123;...&#125;);</span><br><span class="line">gulp.task(&#x27;copyGlobalFont&#x27;, function() &#123;...&#125;);</span><br><span class="line">gulp.task(&#x27;copyAllImage&#x27;, function() &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;copy&#x27;, series([&#x27;copy-static&#x27;], gulp.parallel(&#x27;copyGlobalImage&#x27;, &#x27;copyCss&#x27;,&#x27;copyGlobalFont&#x27;,&#x27;copyAllImage&#x27;)));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//改成以下这样</span><br><span class="line">function themeResourcesCopy(srcPath, destPath, infoMsg) &#123;</span><br><span class="line">  let res = null;</span><br><span class="line">  for (let i = 0; i &lt; theme.length; i += 1) &#123;</span><br><span class="line">    for (let j = 0; j &lt; color.length; j += 1) &#123;</span><br><span class="line">      res = gulp</span><br><span class="line">        .src(srcPath)</span><br><span class="line">        .pipe(info(infoMsg))</span><br><span class="line">        .pipe(gulp.dest(`$&#123;buildTargetPath + color[j]&#125;/$&#123;theme[i]&#125;$&#123;destPath&#125;`));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyGlobalImage() &#123;</span><br><span class="line">  // 目前不考虑同步情况</span><br><span class="line">  const g_image = &#x27;_global/image/&#x27;;</span><br><span class="line">  info(`$&#123;targetTemp + g_image&#125;**`);</span><br><span class="line">  return themeResourcesCopy(`$&#123;targetTemp + g_image&#125;**`, &#x27;/image/&#x27;, DIS.image_copy_g);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 记得去掉引号</span><br><span class="line">gulp.task(&#x27;copy&#x27;, series([&#x27;copy-static&#x27;], parallel(copyGlobalImage, copyCss, copyGlobalFont, copyAllImage)));</span><br></pre></td></tr></table></figure>



<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>第一次接触所以就这样吧，后续会对这块进行优化，因为我发现之前的同事这块写的太复杂了且没有用一些压缩之类的插件，也是一开始都是大家都是开荒，可能都不是专业的，反正团队里比较open，只要不影响原有的功能，优化没人管。</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><blockquote><footer><strong>少年阿布DX</strong><cite><a href="https://www.zcfy.cc/article/the-complete-ish-guide-to-upgrading-to-gulp-4">升级至 Gulp 4 的近完整指南</a></cite></footer></blockquote>



<blockquote><footer><strong>少年阿布DX</strong><cite><a href="https://www.zcfy.cc/article/the-complete-ish-guide-to-upgrading-to-gulp-4">升级至 Gulp 4 的近完整指南</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>How To Master A Skill In A Short Period Of Time?</title>
    <url>/2019/08/22/How-To-Master-A-Skill-In-A-Short-Period-Of-Time/</url>
    <content><![CDATA[<p>都怪我放荡不羁爱打野。</p>
<p>今天看了一个Dan lok的视频</p>
<p><a href="https://www.youtube.com/watch?v=cC9DOCs4lo0&t=136s" title="How To Master A Skill In A Short Period Of Time?">https://www.youtube.com/watch?v=cC9DOCs4lo0&t=136s</a></p>
<h2 id="Best-way-Have-a-mentor"><a href="#Best-way-Have-a-mentor" class="headerlink" title="Best way : Have a mentor"></a>Best way : Have a mentor</h2><ol>
<li>it takes repetition</li>
<li>learning and practice</li>
</ol>
<p><strong>transformation is doesn’t happen in islation</strong></p>
<p><strong>communicate with others</strong></p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>IPD</title>
    <url>/2021/03/01/IPD/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>IPD</tag>
      </tags>
  </entry>
  <entry>
    <title>Ice.js单元测试</title>
    <url>/2020/08/06/Ice-js%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>新建构是基于Ice.js搭建的，在写单元测试的时候遇到一些问题，此篇作为填坑记录。</p>
<p>一开始ice是不支持运行单元测试，因为暴露出来的ice是alias出来的虚包，所以直接在单元测试里import是没法运行的，遂到社区提了issue，前几天传来利好，有了alpha版本能支持写单元测试了，所以下面实践一把。</p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="services"><a href="#services" class="headerlink" title="services"></a><strong>services</strong></h4><p>测试services（ice框架）里的方法</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; request &#125; from &quot;ice&quot;;</span><br><span class="line"></span><br><span class="line">const mockId = &quot;00000000-0d00-0000-0000-000000000000&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  async fetchList(params, config=&#123;&#125;) &#123;</span><br><span class="line">    return await request.post(</span><br><span class="line">      &quot;/api/v1/domain/getResourcesByDomainId&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        ...params,</span><br><span class="line">        id: mockId,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; ...config &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @jest-environment node</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//@jest-environment node 表示测试环境你，默认为jsdom(类浏览器)，node表示为node服务的方式(测试跨域请求时需要用到)</span><br><span class="line">import listService from &#x27;../../../../src/pages/ResourceCenter/services/list&#x27;</span><br><span class="line">import getCookie from &#x27;../../../_helper/getCookie&#x27;</span><br><span class="line"></span><br><span class="line">let headers = &#123;&#125;</span><br><span class="line">beforeEach(async () =&gt; &#123;</span><br><span class="line">	const Cookie = await getCookie()</span><br><span class="line">	headers = &#123; Cookie &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(&#x27;fetchList&#x27;, () =&gt; &#123;</span><br><span class="line">	test(&#x27;listService fetchList&#x27;, async () =&gt; &#123;</span><br><span class="line">		const params = &#123; pageNum: 1, pageSize: 10 &#125;</span><br><span class="line">		const config = &#123;</span><br><span class="line">			withCredentials: true,</span><br><span class="line">			headers: &#123; ...headers &#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		const data = await listService.fetchList(params, config)</span><br><span class="line">		expect(data).not.toBeNull()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="带store的组件"><a href="#带store的组件" class="headerlink" title="带store的组件"></a>带store的组件</h4><p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Grid, Tab &#125; from &#x27;@alifd/next&#x27;;</span><br><span class="line">import &#123; store as pageStore &#125; from &#x27;ice/ResourceCenter&#x27;;</span><br><span class="line">import ResourceList from &#x27;./components/list.jsx&#x27;;</span><br><span class="line">import styles from &#x27;./index.module.scss&#x27;;</span><br><span class="line">import ResourceTypeTree from &#x27;./components/tree.jsx&#x27;;</span><br><span class="line">import DetailConfig from &#x27;./components/detail_config.jsx&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Row, Col &#125; = Grid;</span><br><span class="line"></span><br><span class="line">const AlarmAnalyze = () =&gt; &#123;</span><br><span class="line">  const [treeState, treeDispatchers] = pageStore.useModel(&#x27;tree&#x27;);</span><br><span class="line">  const [listState, listDispatchers] = pageStore.useModel(&#x27;list&#x27;);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    treeDispatchers.fetchTree();</span><br><span class="line">    listDispatchers.fetchList();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Row&gt;</span><br><span class="line">        &lt;Col span=&quot;4&quot;&gt;</span><br><span class="line">          &lt;div className=&#123;styles[&#x27;layout-aside&#x27;]&#125;&gt;</span><br><span class="line">            &lt;ResourceTypeTree data=&#123;treeState.data&#125; /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/Col&gt;</span><br><span class="line">        &lt;Col span=&quot;20&quot;&gt;</span><br><span class="line">          &lt;div className=&quot;layout-content&quot;&gt;</span><br><span class="line">            &lt;Tab&gt;</span><br><span class="line">              &lt;Tab.Item title=&quot;xxx&quot; key=&quot;1&quot;&gt;</span><br><span class="line">                &lt;ResourceList data=&#123;listState&#125; /&gt;</span><br><span class="line">              &lt;/Tab.Item&gt;</span><br><span class="line">              &lt;Tab.Item title=&quot;xxx&quot; key=&quot;2&quot;&gt;</span><br><span class="line">                &lt;DetailConfig data=&#123;listState&#125; /&gt;</span><br><span class="line">              &lt;/Tab.Item&gt;</span><br><span class="line">            &lt;/Tab&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/Col&gt;</span><br><span class="line">      &lt;/Row&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default AlarmAnalyze;</span><br><span class="line">AlarmAnalyze.pageConfig=&#123;</span><br><span class="line">  auth:[&quot;/resourceCenter&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import AlarmAnalyze from &#x27;../../../src/pages/ResourceCenter/index&#x27;</span><br><span class="line">import &#123; store as pageStore &#125; from &#x27;ice/ResourceCenter&#x27;</span><br><span class="line">import &#123; shallow, mount &#125; from &#x27;enzyme&#x27;</span><br><span class="line">//测试内容中需要处理store时，需要用provider包裹</span><br><span class="line">const PageProvider = pageStore.Provider</span><br><span class="line"></span><br><span class="line">const WithPageModel = (props) =&gt; &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;PageProvider&gt;</span><br><span class="line">			&lt;AlarmAnalyze &#123;...props&#125; /&gt;</span><br><span class="line">		&lt;/PageProvider&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let wrapper</span><br><span class="line">beforeEach(() =&gt; &#123;</span><br><span class="line">	wrapper = mount(&lt;WithPageModel /&gt;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(&#x27;render&#x27;, () =&gt; &#123;</span><br><span class="line">	test(&#x27;Test ResourceList  &#x27;, () =&gt; &#123;</span><br><span class="line">		const cwrapper = wrapper.find(&#x27;ResourceList&#x27;)</span><br><span class="line">		expect(cwrapper.prop(&#x27;data&#x27;)).toEqual(&#123; ciType: &#x27;&#x27;, current: 1, keyword: &#x27;&#x27;, list: [], pageSize: 10, total: 0 &#125;)</span><br><span class="line">		//取消挂载</span><br><span class="line">		wrapper.unmount()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	test(&#x27;Test pagination  &#x27;, () =&gt; &#123;</span><br><span class="line">		const pagination = wrapper.find(&#x27;Pagination&#x27;)</span><br><span class="line">		expect(pagination.prop(&#x27;total&#x27;)).toBe(0)</span><br><span class="line">		//取消挂载</span><br><span class="line">		wrapper.unmount()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	test(&#x27;Test ResourceTypeTree  &#x27;, () =&gt; &#123;</span><br><span class="line">		const cwrapper = wrapper.find(&#x27;ResourceTypeTree&#x27;)</span><br><span class="line">		expect(cwrapper.prop(&#x27;data&#x27;)).toEqual(expect.arrayContaining([]))</span><br><span class="line">		//取消挂载</span><br><span class="line">		wrapper.unmount()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>注意只能用icejs来运行，想想也是应该的，因为你要测的东西就是ice那一套的，不可能随便拽个Jest就能跑，Jest咋知道哪跟哪呢。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;icetest:watch&quot;: &quot;icejs test --jest-watch&quot;,</span><br><span class="line">&quot;ice:coverage&quot;: &quot;icejs test --jest-coverage&quot;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ice.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/06/11/JVM/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于最近在查一个OOM问题，所以借机读起了《深入理解Java虚拟机》第三版。简单做个记录。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>大多数垃圾收集器的都应用的理论。</p>
<blockquote>
<p>弱分代假说（年轻代）：绝大多数朝生夕灭的对象。<br>强分代假说（老年代）：熬过越多次垃圾收集就越难消亡。<br>跨代引用假说</p>
</blockquote>
<p> Partial GC（部分收集）:</p>
<ul>
<li>Minor GC&#x2F;Young GC(年轻代收集)</li>
<li>Major GC&#x2F;Old GC（老年代收集）</li>
<li>Mixed GC(混合收集)：JDK 11 ，只有G1有，针对年轻代和部分老年代。<br> Full GC（整堆收集）：整个堆和方法区</li>
</ul>
<span id="more"></span>
<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记需要回收的对象，然后清除。这是最基础算法，后续的其它算法都是针对其缺点的改进而来的。所以其实放在这个目录纬度可能有点不太合适，不过不纠结了。</p>
<img src="/2022/06/11/JVM/1.jpeg" class="" title="stackoverflow">

<p>缺点：</p>
<ol>
<li>随着对象增加而效率降低。</li>
<li>内存碎片</li>
</ol>
<h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5><p>年轻代内存均分两个区域，一个使用完了，就将还存活的对象复制到另一个。避免内存碎片。</p>
<img src="/2022/06/11/JVM/2.png" class="" title="opengenus">

<p>缺点：</p>
<ol>
<li>内存缩小了一半 。</li>
<li>存活对象越多，复制的开销越大，效率降低。</li>
<li>需要担保机制，保证剩下的区域也不够时，也能正常运行，即需要依赖其它内存区域（年老代）。</li>
</ol>
<p>Appel式回收：优化了标记-复制算法，使内存的分配更加合理，比如分成了1个Eden、2个Survivor，Eden、Survivor默认比例为8:1，一开始使用1个Eden、1个Survivor，即剩下未使用的内存只占10%。</p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>主要针对年老代。标记后，让存活对象往内存的一端移动，然后再清理除此以外的内存。</p>
<img src="/2022/06/11/JVM/gc_compact.png" class="" title="opengenus">

<p>缺点：</p>
<ol>
<li>移动就意味着需要更新引用地址，增加了回收的复杂度。</li>
</ol>
<p>所以需要权衡（如果移动则回收更复杂，如果不移动则内存分配更复杂）。比如如果更关注吞吐量则选择“移动”，如果更关注延迟则“不移动”。</p>
<h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><p>上面说的是一些理论，现在说一些细节，垃圾收集的前置知识。</p>
<p>可达性分析：追踪通过“根”对象的一系列参考链可以到达哪些对象。算法中定义了几个GC Root对象。这些根对象在GC时不会被JVM回收，然后通过这些对象像分支一样向外扩展。引用的对象表示它们仍在使用中，不会被使用。</p>
<h5 id="根结点枚举"><a href="#根结点枚举" class="headerlink" title="根结点枚举"></a>根结点枚举</h5><p>即找出所有的GC Roots，且该过程是STW。所谓GC根是垃圾收集器专用的对象。垃圾收集器收集那些不是GC根并且不能通过GC根的引用访问的对象。</p>
<p>固定的可做为GC Roots的节点主要在全局性的引用（常量，类静态属性）与执行上下文（栈桢的本地变量表），</p>
<p><strong>OopMap</strong><br>快速完成根结点枚举的实现方式：OopMap。</p>
<p>一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，</p>
<p>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</p>
<p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找</p>
<p>所以OopMap的作用就是存储内存中哪些位置存储了对象引用。</p>
<h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><blockquote>
<p>OopMap记录的位置（不是随时随地都记录，不然空间占用又是个大问题）<br>控制用户执行程序不能任意位置停顿下来执行垃圾收集。而是强制要求在安全点才能停顿。</p>
</blockquote>
<p>这些特定安全点的主要位置如下：</p>
<ul>
<li>在方法返回之前</li>
<li>调用方法后</li>
<li>抛出异常的位置</li>
<li>循环结束</li>
<li>…</li>
</ul>
<p>咋个保证到了位置就能停呢，HotSpot采用主动式中断方式，即不直接操作线程而是设置一个标志位，线程轮询这个标志位，当为真时，则线程主动中断挂起。<br>为了使轮询高效，HotSpot使用内存保护陷阱的方式，把轮询操作精简为一条指令，当应该听顿时，设置对应的内存页为只读，则该指令会产生一个自陷异常信号，使线程能挂起。</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>扩展拉伸了的安全点。用于程序不执行的时候，即没法触发安全点的情况，该区域里引用关系不会发生变化，因此只要在区域内就能进行垃圾收集。</p>
<h5 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h5><blockquote>
<p>跨代引用的记录方案，避免为了找跨代引用关系时扫描整个老年代。<br>记忆集:用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。<br>卡表：记忆集的具体的实现。</p>
</blockquote>
<h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>为的是维护卡表的元素，比如其它代的对象引用了本区域的对象，即赋值操作，这个时候需要更新卡表，但是怎么保证卡表的更新呢，特别是在已经编译为机器码时。<br>写屏障就是机器码层面的一个手段，在每个赋值操作形成一个AOP切面，赋值前后都属于写屏障，这个时候就能把更新卡表放在赋值之后了，从而保证卡表的更新。</p>
<h5 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h5><p><strong>三色标记</strong></p>
<blockquote>
<p>标记对象的状态。用于后续是否被回收的输入条件。<br>白色: 未被GC访问过的对象。<br>灰色: 被GC访问过，但是至少还存在一个引用没有被扫描。<br>黑色: 被GC访问过，且所有引用都被扫描过。<br><strong>并发扫描对象消失问题</strong><br>即把原本存活的对象标记为已消亡。</p>
</blockquote>
<p>解决办法：</p>
<ol>
<li>增量更新（插入引用）</li>
<li>原始快照（删除引用）</li>
</ol>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>里程碑式的收集器，源于开创了基于Region的堆内存布局，可对任何区域进行回收即不区分老年代、新生代。</p>
<p>虽然还是遵循分代理论，但是目标范围不再像以前的收集器，分隔新生代、老年代或者整个堆，而是可以对任何区域进行回收，因为Region布局里的每个区域都可作为新生代或者老年代的空间。</p>
<p>即新生代、老年代不再是固定的。而是一系列Region的动态集合（不需要连续）。</p>
<p>G1追求的不是一次扫描整个新生代或者老年代甚至整个堆，G1通过计算只会扫某些Region，理论上来讲只要收集的速度跟上分配的速度那就能完美一直运行。</p>
<img src="/2022/06/11/JVM/g1-011.png" class="" title="g1">
<h3 id="JVM-Architecture"><a href="#JVM-Architecture" class="headerlink" title="JVM Architecture"></a>JVM Architecture</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/jvms11.pdf">https://docs.oracle.com/javase/specs/jvms/se11/jvms11.pdf</a></p>
<p><img src="https://www.freecodecamp.org/news/content/images/size/w600/2021/01/image-39.png" alt="img"></p>
<p><img src="https://www.freecodecamp.org/news/content/images/size/w600/2021/01/image-32.png" alt="img"></p>
<p>   JVM中的类的加载器主要有三种:<em><strong>*启动类加载器*<em><strong>，</strong></em>*拓展类加载器*<em><strong>，</strong></em>*应用类加载器。*</strong></em></p>
<p>   **启动类加载器(Bootstrap classLoader):**又称为引导类加载器，由C++编写，无法通过程序得到。主要负责加载JAVA中的一些核心类库，主要是位于<JAVA_HOME>&#x2F;lib&#x2F;rt.jar中。</p>
<p>   **拓展类加载器(Extension classLoader):**主要加载JAVA中的一些拓展类，位于<JAVA_HOME>&#x2F;lib&#x2F;ext中,是启动类加载器的子类。</p>
<p>   <strong>应用类加载器(System classLoader):</strong>  又称为系统类加载器,主要用于加载CLASSPATH路径下我们自己写的类，是拓展类加载器的子类。</p>
<p><a href="https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/">https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/</a></p>
<h4 id="Types-of-Java-Garbage-Collectors"><a href="#Types-of-Java-Garbage-Collectors" class="headerlink" title="Types of Java Garbage Collectors"></a>Types of Java Garbage Collectors</h4><p><a href="https://www.cnblogs.com/woshimrf/p/jvm-garbage.html">https://www.cnblogs.com/woshimrf/p/jvm-garbage.html</a></p>
<p><a href="https://javapapers.com/java/types-of-java-garbage-collectors/">https://javapapers.com/java/types-of-java-garbage-collectors/</a></p>
<p><img src="https://i.stack.imgur.com/XHfx0.jpg" alt="img"></p>
<p><img src="https://static001.infoq.cn/resource/image/75/a4/754f1ab05e6527107cfd8578d98a80a4.png" alt="img"></p>
<p><a href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">https://www.infoq.cn/article/3wyretkqrhivtw4frmr3</a></p>
<p> <a href="https://www.cnblogs.com/dolphin0520/p/3784171.html">Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
<p>Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide：<a href="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573</a></p>
<p>Java Garbage Collection handbook  ：<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/g1">https://plumbr.io/handbook/garbage-collection-algorithms-implementations/g1</a></p>
<p>Shenandoah GC：<a href="https://shipilev.net/talks/javazone-Sep2018-shenandoah.pdf">https://shipilev.net/talks/javazone-Sep2018-shenandoah.pdf</a></p>
<p><a href="https://stuefe.de/posts/metaspace/what-is-compressed-class-space/">https://stuefe.de/posts/metaspace/what-is-compressed-class-space/</a><br><a href="https://shipilev.net/jvm/anatomy-quarks/23-compressed-references/">https://shipilev.net/jvm/anatomy-quarks/23-compressed-references/</a><br><a href="https://stuefe.de/posts/metaspace/analyze-metaspace-with-jcmd/">https://stuefe.de/posts/metaspace/analyze-metaspace-with-jcmd/</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java">Understanding the Java Memory Model and Garbage Collection</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 Streams</title>
    <url>/2020/03/22/Java%208%20Stream/</url>
    <content><![CDATA[<img src="/2020/03/22/Java%208%20Stream/computer-keyboard-34153.jpg" class="" title="Photo by Negative Space from Pexels">

<p>最近两周被平台组指名道姓拉去当了两周的苦力，写业务层代码，因为逻辑比较复杂数据输入比较多样，所以导致使用集合的概率很高，且常常伴随着过滤、排序等操作，继而用到了很多Streams提供的方法，遂做个简单记录。</p>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>Stream是Java 8中引入的新的抽象层，它提供了一些类似SQL语句的声明性方式处理数据。</p>
<p>流操作分为中间操作和最终操作，元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 流管道由一个源（例如Collection，数组，生成器函数或I &#x2F; O通道）组成； 随后是零个或多个中间操作，例如Stream.filter或Stream.map； 以及诸如Stream.forEach或Stream.reduce之类的终端操作。</p>
<img src="/2020/03/22/Java%208%20Stream/java-streams.png" class="">

<p>即将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道中插入节点上进行处理， 比如筛选， 排序，聚合等。</p>
<p>当然为什么喜欢用它还是因为Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。会让代码看起来更加简洁当然通常也会更加高效。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><img src="/2020/03/22/Java%208%20Stream/apis.png" class="" title="api">

<p>如上图api很多，其中又可以按照最开始说的分为中间操作、最终操作两类，中间（<strong>Intermediate</strong>）操作是可以零个或者多个但是最终（<strong>Terminal</strong>）操作只能有一个，能力有限我就列举一下我常用的。</p>
<p><strong>可能我们需要注意的一个概念</strong>：因为一个 Stream 可以进行多次中间操作，那是不是就会对 Stream 的每个元素进行转换多次，即时间复杂度就是 N（转换次数）个 ？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。</p>
<h4 id="中间操作（intermediate-operation）"><a href="#中间操作（intermediate-operation）" class="headerlink" title="中间操作（intermediate operation）"></a>中间操作（intermediate operation）</h4><table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>用于按指定条件过滤元素</td>
</tr>
<tr>
<td>map</td>
<td>map方法将每个元素映射到其相应的结果，通常用于list转换为map</td>
</tr>
<tr>
<td>limit</td>
<td>limit返回流中的前N个元素，同SQL的limit</td>
</tr>
<tr>
<td>sorted</td>
<td>对Stream中的元素进行排序</td>
</tr>
<tr>
<td>distinct</td>
<td>删除重复项</td>
</tr>
</tbody></table>
<h4 id="最终操作（terminal-operation）"><a href="#最终操作（terminal-operation）" class="headerlink" title="最终操作（terminal operation）"></a>最终操作（terminal operation）</h4><table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>迭代Stream中的元素</td>
</tr>
<tr>
<td>sum</td>
<td>对Stream中的元素求和</td>
</tr>
<tr>
<td>collect</td>
<td>可以接受各种参数并将流元素累加成集合</td>
</tr>
<tr>
<td>reduce</td>
<td>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。其实sum等这类也可以说是reduce。</td>
</tr>
<tr>
<td>max</td>
<td>获取Stream中符合条件的最大值</td>
</tr>
<tr>
<td>findAny</td>
<td>这是一个 termimal 操作，它总是返回 Stream 的符合条件的元素，或者空。注意它的返回值类型是Optional（为了避免空指针）。</td>
</tr>
<tr>
<td>anyMatch</td>
<td>Stream 中只要有一个元素符合传入的 条件。</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>列出几个工作中实践的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用于按指定条件过滤元素并且把符合条件的添加到指定的集合</span><br><span class="line">List&lt;CiStrategy&gt; sorted = new ArrayList&lt;&gt;(cis.size());</span><br><span class="line">cis.stream().filter(it -&gt; it.getType() == StrategyType.GLOBAL).forEach(sorted::add);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 拿输入的id到stream中比较是否存在，如果不存在则返回null</span><br><span class="line">final List&lt;String&gt; agentEnableIds = getEnableAgenIdsByApp(query.getAppId());</span><br><span class="line"></span><br><span class="line">String enableId = agentEnableIds.stream()</span><br><span class="line">        .filter(id -&gt; agentId.equals(id))</span><br><span class="line">        .findAny()</span><br><span class="line">        .orElse(null);</span><br><span class="line">//未开启xx</span><br><span class="line">if (isNullOrEmpty(enableId)) &#123;</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 两个集合中，集合B中找到符合集合A中的数据，最终得到符合条件的元素集合</span><br><span class="line">agentCmsList.stream().filter(ag -&gt; agentEnableIds.contains(ag.getId())).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// checkList的元素作为IpV4Ranges中toRange方法的参数，最终把toRange返回值转换为集合</span><br><span class="line">List&lt;String&gt; checkList = splitter.splitToList(scopesToCheck);</span><br><span class="line">List&lt;IpRange&gt; rangesToCheck = checkList.stream().map(IpV4Ranges::toRange).collect(toList());</span><br><span class="line"></span><br><span class="line">// failed集合中，去重后的类型失败的有哪些</span><br><span class="line">List&lt;String&gt; types = failed.stream().map(Quality.Metric::getType).distinct().collect(toList());</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Alarm的list集合，转换为map，key为Alarm的appId，value为Alarm</span><br><span class="line">List&lt;Alarm&gt; dealingAlarms = dealingAlarmPage.getList();</span><br><span class="line">Map&lt;String, Alarm&gt; dealingAlarmMap = dealingAlarms.stream().collect(Collectors.</span><br><span class="line">toMap(Alarm::getAppId, Function.identity()));</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据状态排序，如果状态一样按照名称排序</span><br><span class="line">    public IBoardAppDataList sortByAppStatus(String[] statusOrder) &#123;</span><br><span class="line">        return new BoardAppDataList(this.stream().sorted(new Comparator&lt;BoardAppData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            private int findStatus(String[] a, BoardAppData target) &#123;</span><br><span class="line">                return IntStream.range(0, a.length)</span><br><span class="line">                        .filter(i -&gt; String.valueOf(target.getStatus()).equals(a[i]))</span><br><span class="line">                        .findFirst()</span><br><span class="line">                        .orElse(-1);    // return -1 if target is not found</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int compare(BoardAppData o1, BoardAppData o2) &#123;</span><br><span class="line">                int c = findStatus(statusOrder, o1) - findStatus(statusOrder, o2);</span><br><span class="line">                if (c == 0) &#123;</span><br><span class="line">                    return o1.getAppName().compareTo(o2.getAppName());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断输入参数里是否存在任意一个满足haveXssCondition</span><br><span class="line">Set&lt;String&gt; keys = paramsObj.keySet();</span><br><span class="line">return keys.stream().anyMatch(key -&gt; haveXssCondition(uri, paramsObj, key));</span><br></pre></td></tr></table></figure>



<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>很显然我这篇仅仅是一个简单的记录文档，如果需要深入了解，还是系统的看相关的文档和源码。而且我主要用的是stream其实还有parallelStream，有兴趣的大家可以看看。</p>
<h4 id="感谢："><a href="#感谢：" class="headerlink" title="感谢："></a>感谢：</h4><blockquote><footer><strong>陈 争云, 占 宇剑, 和 司 磊</strong><cite><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">Java 8 中的 Streams API 详解</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HotSpot VM Options</title>
    <url>/2022/06/09/Java-HotSpot-VM-Options/</url>
    <content><![CDATA[<p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
<p><a href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_14_jvm_param_gc_log.html">https://www.cnblogs.com/chanshuyi/p/jvm_serial_14_jvm_param_gc_log.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>How Does JavaScript Really Work</title>
    <url>/2018/09/07/JavaScript%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p><a href="https://blog.bitsrc.io/how-does-javascript-really-work-part-1-7681dd54a36d">https://blog.bitsrc.io/how-does-javascript-really-work-part-1-7681dd54a36d</a></p>
]]></content>
      <categories>
        <category>闲扯</category>
      </categories>
      <tags>
        <tag>心理</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest</title>
    <url>/2020/07/13/Jest/</url>
    <content><![CDATA[<h3 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h3><h5 id="skip，only，each修饰符"><a href="#skip，only，each修饰符" class="headerlink" title="skip，only，each修饰符"></a>skip，only，each修饰符</h5><p><code>describe</code>与<code>test</code>可以连接<code>skip</code>，<code>only</code>，<code>each</code>修饰符。如<code>describe.skip(&#39;something&#39;, testFunction)</code>，会在测试时跳过这一个<code>describe</code>。<code>only</code>会使测试只运行指定的测试用例，这在某个测试用例出错Debug时非常好用。<code>each</code>修饰符可以执行多次参数不同的测试，它接受一个数组<code>table</code>和一个测试函数，<code>table</code>里的元素会作为参数传入测试函数。具体语法可以参见<a href="https://jestjs.io/docs/zh-Hans/api#describeeachtable-name-fn-timeout">文档</a>。</p>
<h5 id="beforeAll，afterAll，beforeEach，afterAll钩子函数"><a href="#beforeAll，afterAll，beforeEach，afterAll钩子函数" class="headerlink" title="beforeAll，afterAll，beforeEach，afterAll钩子函数"></a>beforeAll，afterAll，beforeEach，afterAll钩子函数</h5><p>Jest也支持在执行测试用例之前以及之后执行一些代码来做一些工作，像在测试前设置好测试数据、在测试后清理测试数据。这些工作可以作为<code>beforeAll</code>、<code>afterAll</code>、<code>beforeEach</code>、<code>afterAll</code>的回调函数。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>Jest支持<code>expect</code>式的断言，像<code>expect(1).toBe(1)</code>，其中<code>toBe</code>就是断言部分。Jest支持很丰富的断言。</p>
<h5 id="相等断言"><a href="#相等断言" class="headerlink" title="相等断言"></a>相等断言</h5><p>断言两个基本类型的值相等使用<code>expect(val1).toBe(val2)</code>。注意<code>toBe</code>断言使用<code>Object.is()</code>判断相等。它与<code>==</code>以及<code>===</code>都有不同。</p>
<p>如果要断言数组或者Object相等，使用<code>toEqual</code>断言。它会递归地判断每个属性&#x2F;元素是否是相等的。</p>
<p>如果要断言数组或者Object相等，使用<code>toEqual</code>断言。它会递归地判断每个属性&#x2F;元素是否是相等的。</p>
<blockquote>
<p><code>toStrictEqual(value)</code></p>
<p>测试对象具有相同的类型和结构</p>
<p>和<code>.toEqual</code>不同在于:</p>
<ol>
<li>检查具有未定义属性的键。 例如 使用.toStrictEqual时，{a：未定义，b：2}与{b：2}不匹配。</li>
<li>检查数组。 例如 使用.toStrictEqual时，[，1]与[undefined，1]不匹配</li>
<li>检查对象类型是否相等。 例如 具有字段a和b的类实例将不等于具有字段a和b的文字对象。</li>
</ol>
</blockquote>
<h5 id="数字大小断言"><a href="#数字大小断言" class="headerlink" title="数字大小断言"></a>数字大小断言</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test(&#x27;two plus two&#x27;, () =&gt; &#123;</span><br><span class="line">  const value = 2 + 2;</span><br><span class="line">  expect(value).toBeGreaterThan(3);//大于</span><br><span class="line">  expect(value).toBeGreaterThanOrEqual(3.5);//大于等于</span><br><span class="line">  expect(value).toBeLessThan(5);//小于</span><br><span class="line">  expect(value).toBeLessThanOrEqual(4.5);//小于等于</span><br><span class="line"></span><br><span class="line">  //等于</span><br><span class="line">  expect(value).toBe(4);</span><br><span class="line">  expect(value).toEqual(4);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于浮点数，不能使用<code>toBe</code>或者<code>toEqual</code>进行相等断言。Jest提供了<code>toBeCloseTo</code>断言，可以在忽略一定误差的情况下，断言浮点数相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test(&#x27;adding floating point numbers&#x27;, () =&gt; &#123;</span><br><span class="line">  const value = 0.1 + 0.2;</span><br><span class="line">  //expect(value).toBe(0.3);           This won&#x27;t work because of rounding error</span><br><span class="line">  expect(value).toBeCloseTo(0.3); // This works.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h5 id="真值断言（Truthiness）"><a href="#真值断言（Truthiness）" class="headerlink" title="真值断言（Truthiness）"></a>真值断言（Truthiness）</h5><ul>
<li><p><code>toBeNull</code> 用于 <code>null</code></p>
</li>
<li><p><code>toBeUndefined</code>  用于<code>undefined</code></p>
</li>
<li><p><code>toBeDefined</code> 与<code>toBeUndefined</code> 相反</p>
</li>
<li><p><code>toBeTruthy</code> 用于值为 true</p>
</li>
<li><p><code>toBeFalsy</code>  用于值为 false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test(&#x27;null&#x27;, () =&gt; &#123;</span><br><span class="line">  const n = null;</span><br><span class="line">  expect(n).toBeNull();//pass</span><br><span class="line">  expect(n).toBeDefined();//pass</span><br><span class="line">  expect(n).toBeUndefined();// faild</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h5><p>Jest提供<code>toMatch</code>断言被测试的字符串是否匹配给定正则表达式。</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test(&#x27;but there is a &quot;stop&quot; in Christoph&#x27;, () =&gt; &#123;</span><br><span class="line">  expect(&#x27;Christoph&#x27;).toMatch(/stop/) // pass</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>要断言数组中包含某个子项可以使用<code>toContain</code>断言。</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const shoppingList = [</span><br><span class="line">  &#x27;diapers&#x27;,</span><br><span class="line">  &#x27;kleenex&#x27;,</span><br><span class="line">  &#x27;trash bags&#x27;,</span><br><span class="line">  &#x27;paper towels&#x27;,</span><br><span class="line">  &#x27;beer&#x27;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">test(&#x27;购物清单（shopping list）里面有啤酒（beer）&#x27;, () =&gt; &#123;</span><br><span class="line">  expect(shoppingList).toContain(&#x27;beer&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h5><p>要断言对函数的某些操作会抛出异常可以使用<code>toThrow</code>断言。</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test(&#x27;throws on octopus&#x27;, () =&gt; &#123;</span><br><span class="line">  expect(() =&gt; &#123;</span><br><span class="line">    drinkFlavor(&#x27;octopus&#x27;);</span><br><span class="line">  &#125;).toThrow();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="not修饰符"><a href="#not修饰符" class="headerlink" title="not修饰符"></a>not修饰符</h5><p><code>not</code>修饰符可以把所有的断言反向，像<code>expect(1).not.toBe(2)</code>。</p>
<p>Jest提供的断言不止上面提到那么多。常用到的还有像断言长度的<code>toHaveLength</code>，断言对象有某个属性以及属性的值的<code>toHaveProperty</code>。更多断言的可以参见<a href="https://jestjs.io/docs/zh-Hans/expect">Expect文档</a>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S IPTABLES</title>
    <url>/2023/09/07/K8S-IPTABLES/</url>
    <content><![CDATA[<p>最近处理一个现场，80端口正常开放，但是从外部curl无法访问，pod内部是没问题的</p>
<p>初步判断时k8s内部的转发出了问题</p>
<p><a href="https://www.tkng.io/services/clusterip/dataplane/iptables/">https://www.tkng.io/services/clusterip/dataplane/iptables/</a><br><a href="https://kubernetes.io/blog/2022/09/07/iptables-chains-not-api/">https://kubernetes.io/blog/2022/09/07/iptables-chains-not-api/</a><br><a href="https://dustinspecker.com/posts/iptables-how-kubernetes-services-direct-traffic-to-pods/">https://dustinspecker.com/posts/iptables-how-kubernetes-services-direct-traffic-to-pods/</a><br><a href="https://medium.com/swlh/manage-iptables-firewall-for-docker-kubernetes-daa5870aca4d">https://medium.com/swlh/manage-iptables-firewall-for-docker-kubernetes-daa5870aca4d</a><br><a href="https://livebook.manning.com/concept/kubernetes/iptable">https://livebook.manning.com/concept/kubernetes/iptable</a><br><a href="https://serenafeng.github.io/2020/03/26/kube-proxy-in-iptables-mode/">https://serenafeng.github.io/2020/03/26/kube-proxy-in-iptables-mode/</a><br><a href="https://jimmysong.io/en/blog/understanding-iptables/">https://jimmysong.io/en/blog/understanding-iptables/</a><br><a href="https://blog.csdn.net/cloudvtech/article/details/79728920">https://blog.csdn.net/cloudvtech/article/details/79728920</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Lint笔记-ESLint</title>
    <url>/2019/09/03/Lint%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>由于尽量不想让自己在编码路上留下的足迹会让后人觉得像屎一样…年初到现在断断续续的都在想办法提升个人的工程能力</p>
<p>关于Lint最早是前两年写了一段时间的nodejs，然后知道了一个叫ESLint的玩意…这东西好用啊，让代码可以不太像屎一样了所以最近就捡起来了，当然工具是辅助最重要的还是基础。</p>
<p>伴随着格言 do not BB，show me code。刚好同事让我帮忙跟他弄一下ESLint，那我想着干脆整个文档，那不就简单了，大家都能用。</p>
<p>以下就是跟我们项目贴合度比较高的ESLint简单的配置教程出来（为博客凑个数，话说确实太懒了文章写的少），然后有时间再分析其原理的东西。</p>
<h2 id="ESLint-配置"><a href="#ESLint-配置" class="headerlink" title="ESLint 配置"></a>ESLint 配置</h2><h3 id="安装ESLint相关库"><a href="#安装ESLint相关库" class="headerlink" title="安装ESLint相关库"></a>安装ESLint相关库</h3><pre><code>npm install -g eslint 
// 用了 React 需要再安一个babel-eslint  
npm install -D eslint babel-eslint
//如果要用大厂的需安装对应的库，比如用airbnb的
npm install -D eslint-config-airbnb
// 因为要校验 Reac 语法，所以这里需要下载一个 React 语法规则的包  
npm install -D eslint-plugin-react
</code></pre>
<p>可能不全，但是总之一句话，别想太多提示差什么包就装什么包就对了。</p>
<h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><pre><code>node_modules/.bin/eslint --init
//如果全局安装了 可以直接
eslint --init  
</code></pre>
<p>会出现一个界面，根据模板创建ESLint的配置文件，最终填完之后大概就是下面这样</p>
<img src="/2019/09/03/Lint%E7%AC%94%E8%AE%B0/eslint.png" class="">

<p><strong>演示一把：</strong></p>
<p>选一种方式生成配置文件，可根据需求选择，建议第一个问题选第二种Use a popular style guide（使用大厂的），然后选一个，通常用airbnb的. 跟着界面依次填写下面的内容，最终会在你根目录下生成一个文件名为.eslintrc.js的配置文件 。</p>
<p>根据模板创建配置文件，可以选个模板，也可以自己回答问题</p>
<pre><code>PS E:\eslint&gt; eslint --init
? How would you like to configure ESLint? Use a popular style guide
? Which style guide do you want to follow? (Use arrow keys)
&gt; Airbnb (https://github.com/airbnb/javascript)
  Standard (https://github.com/standard/standard)
  Google (https://github.com/google/eslint-config-google)
</code></pre>
<p>比如选airbnb</p>
<pre><code>module.exports = &#123;
&quot;extends&quot;: &quot;airbnb&quot;
&#125;;
</code></pre>
<p>也可以自己回答问题来创建</p>
<pre><code>&gt; eslint --init

? How would you like to configure ESLint? Answer questions about your style
// 是否校验 Es6 语法
? Are you using ECMAScript 6 features? Yes  
// 是否校验 Es6 模块语法
? Are you using ES6 modules? Yes   
// 代码运行环境，Browser 指浏览器 
? Where will your code run? Browser   
// 是否校验 CommonJs 语法  
? Do you use CommonJS? Yes  
// 是否校验 JSX 语法
? Do you use JSX? Yes   
// 是否校验 React 语法
? Do you use React? Yes 
// 首行空白选择 Tab 键还是 Space
? What style of indentation do you use? Tabs
// 字符串使用单引号 &#39;string&#39; 还是双引号 &quot;string&quot;
? What quotes do you use for strings? Double
// 操作系统
? What line endings do you use? Windows 
// 每行代码结尾是否校验加分号 ;
? Do you require semicolons? Yes
// 以 .js 格式生成配置文件
? What format do you want your config file to be in? JavaScript   
</code></pre>
<p><em>PS</em>：也可以直接在根目录下手动建一个文件.eslintrc.js（后缀也可以是JSON、YAML等），然后手动写配置</p>
<p><em><strong>贴一个我的（手动写的）</strong></em></p>
<p>如果只用于JS语法类扫描，可参考但不建议直接使用，因为配置的东西有点多</p>
<pre><code>module.exports = &#123;
&quot;extends&quot;: [&quot;airbnb&quot;, &quot;prettier&quot;,&quot;prettier/react&quot;],
&quot;parser&quot;: &quot;babel-eslint&quot;,
//如果我们想对一些非标准 JS 语法添加 Lint 怎么办呢？有办法，ESLint 还支持我们自定义 parser。 parser是为了非标准语法能生的，plugin是针对符合js语法的规则集合的扩展。
&quot;plugins&quot;: [
    &quot;prettier&quot;,
    &quot;react&quot;,
    &quot;jsx-a11y&quot;,
    &quot;import&quot;],
//自定义规则，可以覆盖掉extends的配置。
&quot;rules&quot;: &#123;
    &quot;jsx-a11y/click-events-have-key-events&quot;:0,
    &quot;jsx-a11y/interactive-supports-focus&quot;:0,
    &quot;jsx-a11y/no-static-element-interactions &quot;:0,
    // &#39;one-var&#39;:2,//&quot;error&quot; 或 2 开启规则，使用错误级别的错误
    // 强制驼峰命名规则
    &quot;camelcase&quot;: [0, &#123;
        &quot;properties&quot;: &quot;never&quot;
    &#125;],
    &quot;prettier/prettier&quot;: [&quot;error&quot;],
    &quot;react/prop-types&quot;: [&quot;warn&quot;],
    &quot;react/jsx-uses-react&quot;: &quot;error&quot;,
    &quot;react/jsx-uses-vars&quot;: &quot;error&quot;,
    &quot;no-unused-vars&quot;: 1,//&quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误
    &quot;global-require&quot;: 0,//&quot;off&quot; 或 0 - 关闭规则
    &quot;prefer-destructuring&quot;: 0,
    &quot;class-methods-use-this&quot;: 0,
    &quot;react/no-unused-state&quot;: 1,
    &quot;jsx-a11y/no-static-element-interactions&quot;:0,
    &quot;import/extensions&quot;:0
&#125;,
&quot;env&quot;:&#123;
    //定义env会带进来一些全局变量，browser会添加所有的浏览器变量比如Windows
    &quot;browser&quot;: true,
    &quot;es6&quot;: true
&#125;,
//当我们将默认的解析器从Espree改为babel-eslint的时候，我们需要指定parseOptions，这个是必须的。parserOptions ESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。你可以覆盖该设置，以启用对 ECMAScript 其它版本和 JSX 的支持。
&quot;parserOptions&quot;: &#123;
    &quot;sourceType&quot;: &quot;module&quot;,
    &quot;ecmaFeatures&quot;: &#123;
        &quot;jsx&quot;: true// 启用 JSX
    &#125;,
    &quot;ecmaVersion&quot;: 6
&#125;,

&#125;;`
</code></pre>
<h3 id="配置IDE"><a href="#配置IDE" class="headerlink" title="配置IDE"></a>配置IDE</h3><p><em>VSCode配置需自行上网搜索</em></p>
<p>启用ESLint插件</p>
<img src="/2019/09/03/Lint%E7%AC%94%E8%AE%B0/idea_eslint.png" class="">

<p>配置触发ESLint自动修复的快捷键</p>
<img src="/2019/09/03/Lint%E7%AC%94%E8%AE%B0/idea_eslint01.png" class="">

<p>ESLint的使用方法</p>
<img src="/2019/09/03/Lint%E7%AC%94%E8%AE%B0/idea_eslint02.png" class="">
<img src="/2019/09/03/Lint%E7%AC%94%E8%AE%B0/idea_eslint03.png" class="">

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Source命令</title>
    <url>/2019/05/15/Linux%20Source%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>项目前期运维工具没有铺开的时候很多时候都是直接上服务器敲命令，这里记录一下source命令，也是某段时间很常用的一个命令。</p>
<p>我用source命令主要是为了刷新环境变量。刚好前段时间看到一篇文章</p>
<p><a href="https://linuxhandbook.com/source-command/%EF%BC%8C%E5%AF%B9source%E5%91%BD%E4%BB%A4%E6%9C%89%E4%BA%86%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%9C%A8%E8%BF%99%E6%90%AC%E8%BF%90%E4%B8%80%E4%B8%8B%E3%80%82">https://linuxhandbook.com/source-command/，对source命令有了更深入的了解，在这搬运一下。</a></p>
<h3 id="Linux中的源命令是什么"><a href="#Linux中的源命令是什么" class="headerlink" title="Linux中的源命令是什么?"></a>Linux中的源命令是什么?</h3><p>source命令的是从当前shell中的文件执行。它也可以用于刷新环境变量，通常source命令的主要用途是刷新环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source filename [options]</span><br></pre></td></tr></table></figure>

<p>您也可以使用.（点）代替这样的源命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. filename [options]</span><br></pre></td></tr></table></figure>

<h3 id="源命令如何工作？"><a href="#源命令如何工作？" class="headerlink" title="源命令如何工作？"></a>源命令如何工作？</h3><img src="/2019/05/15/Linux%20Source%E5%91%BD%E4%BB%A4/source.png" class="" title="https:&#x2F;&#x2F;linuxhandbook.com&#x2F;source-command&#x2F;">

<p>该命令的语法很简单，但是要理解它，需要更深入地了解一些Linux概念。</p>
<p>在继续之前，我先对变量给出一个简短的解释。</p>
<h4 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h4><p>您可以打开任何bash终端并创建新变量。变量可以被视为占位符，可用于将系统指向一条信息（字母，数字或符号）。</p>
<p>让我们来看一个例子。我将创建一个名为name的新变量，并将为值Christopher赋值。</p>
<p>在bash中，这是使用公式完成的：<strong>variable_name &#x3D; your_variable</strong>。请勿在**&#x3D;**符号和您的文本之间添加任何空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ name=Christopher</span><br><span class="line">christopher@linuxhandbook:~$ echo $name</span><br><span class="line">Christopher</span><br></pre></td></tr></table></figure>

<p>如果我只输入变量名会怎样？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ echo name</span><br><span class="line">name</span><br></pre></td></tr></table></figure>

<p>如果您忘记了该符号，bash将返回您输入的文本。在这里，我告诉它回显或打印“名称”。没有$符号，bash无法识别您要使用已创建的变量。</p>
<p>您的变量将被插入到调用它的位置。因此，我也可以将其包含在这样的句子中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ echo &quot;Hello, $name. $name is a great name. It&#x27;s good to meet you.&quot;</span><br><span class="line">Hello, Christopher. Christopher is a great name. It&#x27;s good to meet you.</span><br></pre></td></tr></table></figure>

<p>您可以使用变量做很多事情，但是我希望该入门足以使任何阅读本文的人都能理解它们的工作原理。</p>
<h4 id="环境变量与shell（本地）变量"><a href="#环境变量与shell（本地）变量" class="headerlink" title="环境变量与shell（本地）变量"></a>环境变量与shell（本地）变量</h4><p>对于理解源命令的下一个关键，让我们谈谈持久性。这是考虑shell变量和环境变量之间差异的简便方法。您可能还根据上下文根据“可移植性”来考虑它。</p>
<p>简而言之，如果在终端shell中创建变量，则退出该shell后该变量将丢失。</p>
<p>相反，<a href="https://help.ubuntu.com/community/EnvironmentVariables">环境变量</a>在您的操作系统中具有持久性。这些变量通常使用所有大写字母来区分自己。</p>
<p>例如，您的用户名被操作系统称为$ USER。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ echo $USER</span><br><span class="line">christopher</span><br></pre></td></tr></table></figure>

<p>好的，因此您花了很多时间来研究环境变量和shell变量之间的差异。这与source有什么关系？如果不了解这块则，运行<strong>source</strong>和<strong>bash</strong>不会有任何区别。</p>
<h4 id="Source-vs-Bash"><a href="#Source-vs-Bash" class="headerlink" title="Source vs Bash"></a>Source vs Bash</h4><p>如果您使用Linux已有一段时间，那么您可能会遇到这些命令，并认为它们做了相同的事情。毕竟，这两个命令都可以用来执行脚本。</p>
<p><strong>source</strong>在当前shell中工作，与运行bash会创建一个新shell不同。这并不明显，因为没有显示新窗口。</p>
<p>比如编写一个非常简单的脚本（将其称为echo.sh），如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! bin/bash</span><br><span class="line"></span><br><span class="line">echo $USER</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>

<p>在终端中执行其他任何操作之前，请将值分配给变量名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ name=chris</span><br></pre></td></tr></table></figure>

<p>接下来，我将向您展示在分配变量的同一终端中尝试所有3条命令时会发生什么。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ bash echo.sh </span><br><span class="line">christopher</span><br><span class="line"></span><br><span class="line">christopher@linuxhandbook:~$ source echo.sh </span><br><span class="line">christopher</span><br><span class="line">chris</span><br><span class="line">christopher@linuxhandbook:~$ . echo.sh </span><br><span class="line">christopher</span><br><span class="line">chris</span><br></pre></td></tr></table></figure>

<p>如您所见，通过<strong>bash</strong>执行脚本时，无法识别本地变量。</p>
<h3 id="使用source命令刷新环境变量"><a href="#使用source命令刷新环境变量" class="headerlink" title="使用source命令刷新环境变量"></a>使用source命令刷新环境变量</h3><p>Source也可以用于更新当前Shell中的环境变量。此任务的常见应用程序是在当前shell中更新bash配置文件。</p>
<p>用户可能想要修改其bash配置文件以<a href="https://linuxhandbook.com/linux-alias-command/">创建别名</a>。通常，一旦保存了配置，您将需要打开一个新的终端窗口以进行更改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">christopher@linuxhandbook:~$ source .bashrc </span><br></pre></td></tr></table></figure>

<p>运行此命令将刷新当前外壳程序中的设置，而不会强制您打开新终端。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux ls命令</title>
    <url>/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前面的文章已经说过很多了，因为经常会到服务器上操作，所以记录几个常用的Linux命令。</p>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>ls命令应该说是我接触的linux的第一批命令之一，属于没事就敲个ls装逼的程度，但是用下来发现也是一个宝藏命令，实用性很强。</p>
<h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h5><p>直接输入ls，不带任何其它选项，该<code>ls</code>命令提供有关由命令行上给定路径指向的每个文件对象的信息：</p>
<ul>
<li>只显示路径指向的文件对象的名称；</li>
<li>如果该路径指向目录（或指向目录的符号链接），则该<code>ls</code>命令还会列出该目录的内容；</li>
<li>如果显示多个条目，则将按文件名的字母顺序对其进行排序。</li>
</ul>
<p>最后，当在命令行上未给出路径时，这些<code>ls</code>命令将采用<code>./</code>–即当前目录。</p>
<img src="/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/1.png" class="" title="ls">

<h5 id="ls-l-长格式显示"><a href="#ls-l-长格式显示" class="headerlink" title="ls -l: 长格式显示"></a><code>ls -l: 长格式显示</code></h5><p>除文件名称外，亦将日期和时间、权限、拥有者、文件大小等资讯详细列出，我们经常使用的<code>ll</code>其实就是它的别名。</p>
<img src="/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/2.png" class="" title="ls -l">

<h5 id="ls-a-显示所有文件"><a href="#ls-a-显示所有文件" class="headerlink" title="ls -a: 显示所有文件"></a><code>ls -a: 显示所有文件</code></h5><p>使用该<code>-a</code>选项时，在显示目录内容时<code>ls</code>包括<a href="https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory">隐藏文件</a>。但是什么是隐藏文件？</p>
<p>隐藏文件：名称以点开头的文件被视为隐藏文件。此外，每个目录还包含两个特殊的，通常为隐藏的条目：<code>.</code>和<code>..</code></p>
<p>在每个目录中：</p>
<ul>
<li>该<code>.</code>条目指向目录本身。这种自我指称似乎很奇怪。但这有时很有用，有点像将自己的电话号码存储到智能手机库中。</li>
<li>该<code>..</code>条目指向父目录。由于类Unix系统上的文件层次结构严格地组织为一<a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">棵树</a>，因此每个目录只有一个父目录。</li>
</ul>
<img src="/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/3.png" class="">

<h5 id="ls-s-显示文件分配的大小"><a href="#ls-s-显示文件分配的大小" class="headerlink" title="ls -s: 显示文件分配的大小"></a><code>ls -s: 显示文件分配的大小</code></h5><p>这里大小的单位是<strong>块</strong>，在linux中一块可以看作是1024字节，该大小指的不是逻辑大小而是实际大小。如下所示，a、b都是2097152，但是通过块的方式查看b只有1028，因为b目录下由 <a href="https://en.wikipedia.org/wiki/Sparse_file">sparse files</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh:~/ls$ ls -ls a b</span><br><span class="line">2052 -rw-r--r-- 1 sylvain sylvain 2097152 Sep 19 22:18 a</span><br><span class="line">1028 -rw-r--r-- 1 sylvain sylvain 2097152 Sep 19 22:18 b</span><br></pre></td></tr></table></figure>

<h5 id="ls-h-可读性强的方式显示文件大小"><a href="#ls-h-可读性强的方式显示文件大小" class="headerlink" title="ls -h: 可读性强的方式显示文件大小"></a><code>ls -h: 可读性强的方式显示文件大小</code></h5><p>使用-h选项，ls将使用单位后缀显示文件大小，以使其更加用户友好。如图直接使用-h是没用的，结合l和s使用。</p>
<img src="/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/4.png" class="">

<h5 id="ls-d-只显示目录（文件夹）"><a href="#ls-d-只显示目录（文件夹）" class="headerlink" title="ls -d */: 只显示目录（文件夹）"></a><code>ls -d */: 只显示目录（文件夹）</code></h5><img src="/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/5.png" class="">

<h5 id="ls-i-显示文件的索引号"><a href="#ls-i-显示文件的索引号" class="headerlink" title="ls -i: 显示文件的索引号"></a><code>ls -i: 显示文件的索引号</code></h5><p>有点我们说的引用地址的意思，该选项在查看文件的硬、软链接时比较有用。比如查看某几个文件是否引用同一基础文件系统对象。</p>
<p>比如下图，切换到根目录，然后<code>ls -ia</code>你会发现<code>.</code>和<code>..</code> 的索引号都是2，证明指向的是同一个目录，这刚好可以解释根目录的父目录就是根目录自身。</p>
<img src="/2020/06/02/Linux%20ls%E5%91%BD%E4%BB%A4/6.png" class="">

<h5 id="ls-1"><a href="#ls-1" class="headerlink" title="ls ../"></a><code>ls ../</code></h5><p>查看父目录文件。</p>
<h5 id="ls-2"><a href="#ls-2" class="headerlink" title="ls ~"></a><code>ls ~</code></h5><p>查看主目录的文件。</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><code>ls -t </code>：按修改时间倒序，最近修改的在前。</p>
<p><code>ls -S</code>： 按文件大小正序，最小在前。</p>
<p><code>ls -r</code>：反转排序。比如<code>ls -rS</code>，则会变成最大的在前。</p>
<p><code>ls -R</code>：递归列出子目录，跟<code>find .</code>效果类似。</p>
<p><strong>时间完整显示</strong></p>
<p><code>ls --full-time</code>：显示完整日期及时间。</p>
<h3 id="OK"><a href="#OK" class="headerlink" title="OK"></a>OK</h3><p>结束了，以上列举的80%都是我日常经常用的，希望对大家有帮助。</p>
<p><strong>感谢</strong></p>
<blockquote><footer><strong>ls Command in Linux: 17 Useful Examples Explained</strong><cite><a href="https://linuxhandbook.com/ls-command/#_a_sample_file_hierarchy">Sylvain Leroux</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title>Macbook Pro M1选购</title>
    <url>/2021/11/15/Macbook%20Pro%20M1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>苹果出第一代M1的时候就想入手来着，不过还是忍了忍。</p>
<ul>
<li>等一下M1的生态。</li>
<li>不想做第一个吃螃蟹的人，反正也不急。</li>
</ul>
<p>10月份M1 Pro和M1 Max来了，这回忍不了了，从命名能看出其实等M2是最好的，不过确实不想等了，手里的小米笔记本已经不能满足我了….，这里不得不吐槽下，小米笔记本我就是当了第一个吃螃蟹的人，体验很差（换主板、换屏幕…）。我儿豁，对于消费品真的不想再当吃螃蟹的人了。</p>
<h3 id="选购"><a href="#选购" class="headerlink" title="选购"></a>选购</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>因为M1 Pro和M1 Max有很多配置可选，把我整懵逼了，所以想一想还是做些功课再买。<br><strong>需求先列出来：</strong></p>
<ol>
<li>编程，屏幕不能太小</li>
<li>好看</li>
<li>有逼格</li>
<li>不能超过2万</li>
</ol>
<blockquote>
<p> 注：其实理智的码农应该选择Linux和x86</p>
</blockquote>
<p>另外顺便说一下关于ARM和X86，这里有篇文章我觉得是很客观的：<a href="*https://www.leiphone.com/category/chips/4iqXwfxodkvGHl8s.html*">苹果 M1 革了 Intel x86 的命？</a></p>
<p><strong>功课如下：</strong></p>
<ol>
<li><a href="https://doesitarm.com/">M1软件支持列表</a></li>
<li><a href="https://markellisreviews.com/8-core-or-10-core-m1-pro-macbook-pro-14/">8-core-or-10-core-m1-pro-macbook-pro-14</a></li>
<li><a href="https://www.youtube.com/watch?v=gqiYSt4nAFs">16GB vs 32GB RAM M1 Pro MacBook</a></li>
<li><a href="https://www.youtube.com/watch?v=T6qQ7cM--B4">M1 Pro MacBook - 8 vs 10 CPU Cores </a></li>
<li><a href="https://b23.tv/x2TdnXg">M1 Max性能全解密! 凑齐7台Mac</a></li>
</ol>
<h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p>方方面面看下来，只能说幸好啊。</p>
<blockquote>
<p>大体结论是， 8核cpu和10核cpu，差别不大，没必要上。</p>
<p>16G和32G，贵了小3千块钱，没有特别的必要上，还不如用这个钱加SSD。</p>
<p>M1 Max如果不是资深从业人员没必要上。</p>
</blockquote>
<p>本来我想买的是10核cpu，32G内存，1T硬盘。</p>
<p>最终选择了下面的配置：14寸 8CPU + 16G +1T SSD。我个人觉得是比较合适的配置。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后我还是要说一下，M1系列其实你认真看很多关注度高的评测，基本都是使用视频剪辑、设计等工作台的人员，因为苹果M1就是以自家公司设计工作台的员工作为需求收集的来源之一，所以对视频、设计类软件有这么牛逼的性能当然这也是mac一直来的最大优势之一。</p>
<p>但是咱静下来想一想，你自己的需求到底是什么，会需要在高性能的基础上再加牛逼的性能吗？反正我是不需要，当然还有个原因是我穷。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>电脑</tag>
      </tags>
  </entry>
  <entry>
    <title>Module bundling</title>
    <url>/2020/03/01/Module%20bundling/</url>
    <content><![CDATA[<p>是的这又是一篇搬运文章，谁让我放荡不羁爱打野呢。作者博客地址<a href="https://www.preethikasireddy.com/">Preethi Kasireddy</a></p>
<p>之前有聊过一篇关于<a href="/2020/02/22/Modules/" title="Modules">Modules</a>的文章，主要讲什么是模块以及为什么需要模块。这篇主要讲怎么捆绑（打包）模块也就是模块使用的深一步探讨。</p>
<h3 id="什么是模块捆绑？"><a href="#什么是模块捆绑？" class="headerlink" title="什么是模块捆绑？"></a>什么是模块捆绑？</h3><p> 从高层次上讲，模块捆绑只是将一组模块（及其依赖项）按正确顺序拼接到单个文件（或一组文件）中的过程。</p>
<h3 id="为什么需要模块捆绑？"><a href="#为什么需要模块捆绑？" class="headerlink" title="为什么需要模块捆绑？"></a>为什么需要模块捆绑？</h3><p>如果项目中使用的模块过多，那么你就需要一个一个的使用script 标签引入到html中去,然后html运行的时候会一个一个的去加载你引入的模块。</p>


<p>像上图那样 one by one 如果用的模块一多，页面的延迟就会过久，用户体验不好。</p>
<p>为了解决这个问题，我们把所有文件捆绑，或“拼接”到一个文件（有时也是一组文件）中，<strong>正是为了减少请求数</strong>。</p>
<p>另一个加速构建操作的常用方法是，“缩减”捆绑后的代码。缩减，是把源代码中不需要的字符（如空格、评论、换行符等等）移除，从而减小了代码的总体积，却不改变其功能。</p>
<p>数据更少，<strong>浏览器处理的时间就更短</strong>，比如经常见到的”xxxmin.js”，相比完整版，缩减版小了好多。</p>
<h3 id="捆绑模块有哪些不同的方式？"><a href="#捆绑模块有哪些不同的方式？" class="headerlink" title="捆绑模块有哪些不同的方式？"></a>捆绑模块有哪些不同的方式？</h3><p>如果你用的是一种标准模块模式（在 <a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.y8hs0nsne">第一部分</a> 讨论过）来定义模块，比如<em>IIFE、全局导入</em>等，其实就是直接拼接和缩减几堆纯 JavaScript 代码，通常则不用借助工具。</p>
<p>但如果你用的是非原生模块系统，浏览器不能像 CommonJS、AMD、甚至原生 ES6 模块格式那样解析，你就需要用专门工具先转化成排列正确、浏览器可识别的代码。这正是 Browserify、RequireJS、Webpack 和其他模块捆绑工具，或模块加载工具粉墨登场的时候。</p>
<p>下面就来过一遍常用的模块捆绑方法：</p>
<h4 id="Bundling-CommonJS"><a href="#Bundling-CommonJS" class="headerlink" title="Bundling CommonJS"></a>Bundling CommonJS</h4><p> <a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.y8hs0nsne">第一部分</a>所知，CommonJS同步加载模块，它对于浏览器是不适用的。 解决此问题其中一个方法是用Browserify。 Browserify是一个为浏览器编译CommonJS模块的工具。</p>
<p>例如，假设您有一个main.js文件，该文件导入一个模块来计算数字数组的平均值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myDependency = require（&#x27;myDependency&#x27;）;</span><br><span class="line">var myGrades = [93，95，88，0，91];</span><br><span class="line">var myAverageGrade = myDependency.average（myGrades）;</span><br></pre></td></tr></table></figure>

<p>因此，在这种情况下，我们只有一个依赖项（myDependency）。 使用以下命令，Browserify将递归所有必需的模块（从main.js开始）并把它们捆绑到一个名为bundle.js的文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">browserify main.js -o bundle.js</span><br></pre></td></tr></table></figure>

<p>Browserify通过跳入每个<em><strong>require</strong></em> 调用的AST解析来遍历项目的整个依赖关系图来实现此目的。 一旦确定了依存关系的结构，便会将它们按正确的顺序捆绑到一个文件中。当需要使用时，则将<em><strong>“bundle.js”</strong></em> 文件的<code>&lt;script&gt;</code>标记插入到html中，以确保所有源代码都在一个HTTP请求中下载。</p>
<p>同样，如果您有多个具有多个依赖项的文件，则只需告诉Browserify您的条目文件是什么，然后静静等待Browserify进行文件捆绑。</p>
<p>最后，可以使用Minify-JS之类的工具来缩小捆绑代码。</p>
<h4 id="Bundling-AMD"><a href="#Bundling-AMD" class="headerlink" title="Bundling AMD"></a>Bundling AMD</h4><p>如果是AMD，则需要使用诸如RequireJS或Curl之类的AMD加载器。 模块加载器（相对于捆绑器）动态加载程序需要的模块。</p>
<p>AMD与CommonJS的主要区别之一是它加载模块的方式为异步。 所以对于AMD，从技术上讲，实际上不需要构建步骤，因为是异步加载模块的，因此无需将模块捆绑到一个文件中。这意味着运行程序时仅会逐步下载执行该命令所必需的那些文件，而不是在用户首次访问该页面时立即下载所有文件。</p>
<p>但是，实际上，随着时间的推移，随着产品复杂性的增加，随着程序依赖的模块越来越多， 大多数情况下仍然使用构建工具来捆绑和缩小其AMD模块，以实现最佳性能，例如使用诸如RequireJS优化器，r.js之类的工具。</p>
<p>总的来说，AMD与CommonJS之间的区别在于：AMD是异步加载，CommonJS时同步加载。</p>
<p>有关CommonJS与AMD的有趣讨论，请查看Tom Dale博客中的<a href="https://tomdale.net/2012/01/amd-is-not-the-answer/#too-much-ceremony">这篇</a>文章。</p>
<h3 id="ES6-modules"><a href="#ES6-modules" class="headerlink" title="ES6 modules"></a>ES6 modules</h3><p> 接下来谈谈ES6模块，它在某些方面可以减少将来对捆绑器的需求。</p>
<p>当前的JS模块格式（CommonJS，AMD）和ES6模块之间最重要的区别是ES6模块在设计时考虑了<strong>静态分析</strong>。 这意味着在导入模块时，将在编译时（即在脚本开始执行之前）解决导入问题。 这使我们可以在运行程序之前删除其他模块未使用的导出。 删除未使用的导出可以节省大量空间，从而减轻浏览器的压力。</p>
<p>一个常见的问题是：与使用UglifyJS之类的代码来缩小代码时所产生的死代码消除有什么不同？这得分情况 。</p>
<p>有时，清除死代码可能在UglifyJS和ES6模块之间完全相同，而有时则不行。 </p>
<p>使ES6模块与众不同的是消除死代码的不同方法，称为<code>tree shaken</code>。 tree shaken本质上是消除死代码的反向操作。 它仅包含捆绑软件需要运行的代码，而不排除捆绑软件不需要的代码。 让我们看一个例子：</p>
<p>假设我们有一个utils.js文件，其中包含以下函数，我们使用ES6语法导出每个函数：:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">each</span>(<span class="params">collection, iterator</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(collection)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; collection.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">iterator</span>(collection[i], i, collection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> collection) &#123;</span><br><span class="line">      <span class="title function_">iterator</span>(collection[key], key, collection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">collection, test</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered = [];</span><br><span class="line">  <span class="title function_">each</span>(collection, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">test</span>(item)) &#123;</span><br><span class="line">      filtered.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> filtered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">collection, iterator</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> mapped = [];</span><br><span class="line">  <span class="title function_">each</span>(collection, <span class="keyword">function</span>(<span class="params">value, key, collection</span>) &#123;</span><br><span class="line">    mapped.<span class="title function_">push</span>(<span class="title function_">iterator</span>(value));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">collection, iterator, accumulator</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> startingValueMissing = accumulator === <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">each</span>(collection, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(startingValueMissing) &#123;</span><br><span class="line">        accumulator = item;</span><br><span class="line">        startingValueMissing = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accumulator = <span class="title function_">iterator</span>(accumulator, item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，假设我们不知道要在程序中使用哪些utils函数，因此我们继续将所有模块导入main.js中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Utils</span> <span class="keyword">from</span> ‘./utils.<span class="property">js</span>’;</span><br></pre></td></tr></table></figure>

<p>然后我们最终只使用each函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Utils</span> <span class="keyword">from</span> ‘./utils.<span class="property">js</span>’;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) &#125;);</span><br></pre></td></tr></table></figure>

<p>模块加载后，main.js文件的“tree shaken”版本将如下所示：:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">each</span>(<span class="params">collection, iterator</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(collection)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; collection.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">iterator</span>(collection[i], i, collection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> collection) &#123;</span><br><span class="line">      <span class="title function_">iterator</span>(collection[key], key, collection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) &#125;);</span><br></pre></td></tr></table></figure>

<p>所以你会发现除了 <strong>each</strong>函数其他函数都没有了.</p>
<p>Meanwhile, if we decide to use the filter function instead of the each function, we wind up looking at something like this:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Utils</span> <span class="keyword">from</span> ‘./utils.<span class="property">js</span>’;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">filter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x === <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>The tree shaken version looks like:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">each</span>(<span class="params">collection, iterator</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(collection)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; collection.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">iterator</span>(collection[i], i, collection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> collection) &#123;</span><br><span class="line">      <span class="title function_">iterator</span>(collection[key], key, collection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">collection, test</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered = [];</span><br><span class="line">  <span class="title function_">each</span>(collection, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">test</span>(item)) &#123;</span><br><span class="line">      filtered.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> filtered;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">filter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x === <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>注意这次是如何同时包含<strong>filter</strong>和<strong>each</strong>的。 这是filter使用each，因此我们需要导出这两个函数模块才能正常工作.</p>
<p>有兴趣可以试试Rollup.js <a href="http://rollupjs.org/">live demo and editor</a>。看看它对Tree-Shaking的应用。</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>就打包器而言，Webpack是新手。 它的设计与您使用的模块系统无关，允许开发人员酌情使用CommonJS，AMD或ES6。</p>
<p>您可能想知道为什么当我们已经有其他捆绑器（如Browserify和RequireJS）完成工作并做得很好时，为什么我们需要Webpack。 其中一个原因是，Webpack提供了一些有用的功能，例如“代码拆分”-一种将您的代码库拆分为“块”（按需加载）的方法。</p>
<p>例如，如果您的Web应用程序仅在某些情况下需要使用代码块，则将整个代码库放入单个大型捆绑文件中可能没有效率。 在这种情况下，您可以使用代码拆分将代码提取为可按需加载的捆绑块，从而避免了在大多数用户只需要应用程序核心的情况下使用较大的前期有效负载的麻烦。</p>
<p>代码拆分只是Webpack提供的众多引人注目的功能之一，并且Internet上对于Webpack还是Browserify更好是有很多意见。 以下是一些我认为有助于解决问题的更高级的讨论：:</p>
<ul>
<li><a href="https://gist.github.com/substack/68f8d502be42d5cd4942">https://gist.github.com/substack/68f8d502be42d5cd4942</a></li>
<li><a href="http://mattdesl.svbtle.com/browserify-vs-webpack">http://mattdesl.svbtle.com/browserify-vs-webpack</a></li>
<li><a href="http://blog.namangoel.com/browserify-vs-webpack-js-drama">http://blog.namangoel.com/browserify-vs-webpack-js-drama</a></li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这篇文章比较老了，但是它对我来说是在于扫盲，毕竟概念性的东西是不过时的。</p>
<ul>
<li><p>CommonJs主要针对服务端，AMD主要针对浏览器端。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）</p>
</li>
<li><p>AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成），即不能懒加载。不过因为AMD并行解析，加载快速，所以同一时间可以解析多个文件。当然也因为并行加载，异步处理，加载顺序不一定，所以不注意的情况下可能会造成程序会出现一些问题。</p>
</li>
<li><p>ES6 module的静态分析，配合tree sharking特性，做到用那些导哪些，也不用像AMD那样需要用define包装函数，当然这篇文章比较老了啊，现在其实ES6 module已经是普及了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title>Modules</title>
    <url>/2020/02/22/Modules/</url>
    <content><![CDATA[<img src="/2020/02/22/Modules/a.png" class="" title="Photo by Sharon McCutcheon from Pexels">

<p>模块话，模块化说了那么多次，以为了解个大概就行了，然而在一次面试经历中被问到AMD和ES Module，所以特此来一篇，汇总一下吸收的模块方面的内容。</p>
<p>又是一篇搬运文章，谁让我放荡不羁爱打野呢。作者博客地址<a href="https://www.preethikasireddy.com/">Preethi Kasireddy</a></p>
<h3 id="为什么模块很重要？"><a href="#为什么模块很重要？" class="headerlink" title="为什么模块很重要？"></a>为什么模块很重要？</h3><p>如果没有模块，你能想象在复杂场景下你得js代码是个什么鬼模样吗？模块解决了名称空间和可维护性等变得越来越难以处理的问题。</p>
<p>好的模块是高度独立的，具有独特的功能，可以根据需要对它们进行改组，删除或添加，而不会破坏整个系统。</p>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p><strong>1）可维护性：</strong>根据定义，模块是独立的。精心设计的模块旨在尽可能减少对代码库各部分的依赖，从而使其能够独立增长和改进。当模块与其他代码解耦时，更新单个模块要容易得多。</p>
<p><strong>2）命名空间：</strong>在JavaScript中，顶级函数范围之外的变量是全局变量（意味着每个人都可以访问它们）。因此，普遍存在“命名空间污染”，其中完全不相关的代码共享全局变量。</p>
<p>在不相关的代码之间共享全局变量<a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">在开发中</a>是一个很大的<a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">禁忌</a>。模块允许我们通过为变量创建私有空间来避免名称空间污染。</p>
<p><strong>3）可重用性：</strong>抽取通用部分，哪里需要就拿去，不用重复写，当然也对应的第一点，当有修改时只需要该一份。</p>
<p>早期的时候为了达到“模块模式”，也有很多方式，不过我看了下基本上都是基于匿名闭包的基础上而来的。</p>
<p>这些方式有一个共同点：<strong>使用单个全局变量将其代码包装在函数中，从而使用闭包作用域为其自身创建私有名称空间，同时自定义公开哪些方法、变量</strong>。</p>
<p>大家可以看下jQuery的源码，就是这样的实现方式，如下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myGradesCalculate = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Keep this variable private inside this closure scope</span></span><br><span class="line">  <span class="keyword">var</span> myGrades = [<span class="number">93</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">0</span>, <span class="number">55</span>, <span class="number">91</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> average = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> total = myGrades.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> accumulator + item;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span><span class="string">&#x27;Your average grade is &#x27;</span> + total / myGrades.<span class="property">length</span> + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> failing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> failingGrades = myGrades.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item &lt; <span class="number">70</span>;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;You failed &#x27;</span> + failingGrades.<span class="property">length</span> + <span class="string">&#x27; times.&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Explicitly reveal public pointers to the private functions </span></span><br><span class="line">  <span class="comment">// that we want to reveal publicly</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">average</span>: average,</span><br><span class="line">    <span class="attr">failing</span>: failing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myGradesCalculate.<span class="title function_">failing</span>(); <span class="comment">// &#x27;You failed 2 times.&#x27; </span></span><br><span class="line">myGradesCalculate.<span class="title function_">average</span>(); <span class="comment">// &#x27;Your average grade is 70.33333333333333.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如您所见，这种方法使我们可以决定将哪些变量&#x2F;方法设为私有（例如*<strong>myGrades*<strong>），以及通过将它们放在return语句中（例如</strong>*average**<em>和</em></strong>failing***）来公开哪些变量&#x2F;方法。</p>
<ul>
<li>Addy Osmani的“ <a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">学习JavaScript设计模式”</a>：精妙读物中的细节宝库</li>
<li><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">Ben Cherry的“足够好”</a>：一个有用的概述，其中包含模块模式的高级用法示例</li>
<li><a href="https://carldanley.com/js-module-pattern/">Carl Danley的博客</a>：模块模式概述和其他JavaScript模式的资源。</li>
</ul>
<p>所以大家可以看出，早期关于模块的写法，尽管每种方法都以其自己的方式有效，但它们也有缺点：</p>
<ol>
<li>大家各自发挥的，这样有个最大的问题就是到最后就是乱的，就像为什么需要TC39一样，让大家有一套标准，才能从而写出更友好通用的模块。 </li>
<li>依赖管理是个问题，需要我们开发人员自己管理依赖，记得刚开始用jQuery这种第三方库的时候，如果没注意到顺序就会报错，所以想象一下如果引用较多时，管理依赖关系并正确解决这些问题会让人头疼。</li>
<li>全局作用域被污染，上述的方式创建的变量（比如<strong>myGradesCalculate</strong>）都在全局范围内，所以该全局范围内的代码的每个部分都可以更改该变量。恶意代码可以有意更改该变量，以使您的代码执行您不希望这样做的事情，或者非恶意代码可能会无意间破坏了您的变量。</li>
</ol>
<p>所以基于上述原因，这个时候我们就需要一套规范了来解决这些个问题：<strong>我们能否设计一种无需遍历全局范围即可请求模块接口的方法</strong></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>现在比较通行得规范有两种：<a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>。</p>
<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><strong><a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a></strong></h4><p>CommonJS是一个旨在定义一系列规范以帮助开发服务器端JavaScript应用程序的项目。CommonJS团队尝试解决的领域之一就是模块，负责设计和实现用于声明模块的JavaScript API。我听说CommonJS，最早是在15年写Node应用的时候接触的，Node.js最开始就是遵循这套规范弄得模块化，但是据说后来不用该规范了。</p>
<p>一个CommonJS的模块本质上是一种可重复使用的一段JavaScript代码其中出口特定对象，使它们可用于其他模块需要在他们的计划。</p>
<p>使用CommonJS，每个JavaScript文件都将模块存储在其自己的唯一模块上下文中（就像将其包装在闭包中一样）。在此范围内，我们使用<em>module.exports</em>对象公开模块，并要求将其导入。</p>
<p>当您定义CommonJS模块时，它可能看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">goodbye</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;goodbye!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = myModule;</span><br></pre></td></tr></table></figure>

<p>我们使用特殊对象模块，并将我们函数的引用放入<em>module.exports中</em>。这使CommonJS模块系统知道我们要公开的内容，以便其他文件可以使用它。</p>
<p>然后，当某人想要使用<em>myModule时</em>，他们可以在其文件中要求它，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;myModule&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myModuleInstance = <span class="keyword">new</span> <span class="title function_">myModule</span>();</span><br><span class="line">myModuleInstance.<span class="title function_">hello</span>(); <span class="comment">// &#x27;hello!&#x27;</span></span><br><span class="line">myModuleInstance.<span class="title function_">goodbye</span>(); <span class="comment">// &#x27;goodbye!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>与我们之前讨论的模块模式相比，这种方法有两个明显的好处：</p>
<ol>
<li>避免全局命名空间污染</li>
<li>明确我们的依赖关系</li>
</ol>
<p>要注意的另一件事是，CommonJS采用服务器优先的方法并<strong>同步加载</strong>模块。这很重要，因为如果我们有我们需要的其他三个模块<em>需要</em>，它就会加载它们一个接一个。</p>
<p>现在，它可以在服务器上很好地工作，但是不幸的是，这使得为浏览器编写JavaScript时更难使用，因为服务器端通常是从磁盘读取，而浏览器需要网络请求，所以只要加载模块的脚本一直在运行（JavaScript线程将停止直到代码被加载），它就会阻止浏览器运行其他任何东西，直到加载完成。</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a></h4><p>从上面我们知道CommonJS是同步的，所以很显然不适用浏览器端，那我们就需要<strong>异步模块定义</strong>的规范，即<strong>AMD</strong>。</p>
<p>使用AMD加载模块如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;myModule&#x27;</span>, <span class="string">&#x27;myOtherModule&#x27;</span>], <span class="keyword">function</span>(<span class="params">myModule, myOtherModule</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="title function_">hello</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里发生的是，<em><strong>define</strong></em>函数将每个模块依赖项的数组作为第一个参数。这些依赖项在后台加载（以非阻塞方式），并且一旦加载了<em><strong>define</strong></em>，便调用回调函数。</p>
<p>接下来，回调函数将加载的依赖项作为参数（在本例中为<strong><em>myModule*<strong>和</strong></em>myOtherModule</strong><em>），以允许函数使用这些依赖项。最后，还必须使用</em>**define***关键字定义依赖项本身。</p>
<p>例如，***myModule***可能看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>([], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">goodbye</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;goodbye&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>与CommonJS不同，AMD采用了浏览器优先的方法以及<strong>异步</strong>行为来完成工作。</p>
<p>除了异步之外，AMD的另一个好处是您的模块可以是<strong>对象，函数，构造函数，字符串，JSON和许多其他类型</strong>，而CommonJS仅支持将<strong>对象</strong>作为模块。</p>
<p>AMD与CommonJS相比，其提供的io，文件系统和其他面向服务器的功能不兼容。</p>
<h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a><a href="https://github.com/umdjs/umd">UMD</a></h4><p>对于需要同时支持AMD和CommonJS功能的项目，还有另一种格式：通用模块定义（UMD）。</p>
<p>UMD本质上创建了一种使用这两种方法之一的方式，同时还支持全局变量定义。结果，UMD模块能够在客户端和服务器上工作。</p>
<p>以下是UMD如何开展业务的快速体验：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">      <span class="comment">// AMD</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&#x27;myModule&#x27;</span>, <span class="string">&#x27;myOtherModule&#x27;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// CommonJS</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;myModule&#x27;</span>), <span class="built_in">require</span>(<span class="string">&#x27;myOtherModule&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Browser globals (Note: root is window)</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">myModule</span>, root.<span class="property">myOtherModule</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">myModule, myOtherModule</span>) &#123;</span><br><span class="line">  <span class="comment">// Methods</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">notHelloOrGoodbye</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// A private method</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// A public method because it&#x27;s returned (see below)</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">goodbye</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// A public method because it&#x27;s returned (see below)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exposed public methods</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">hello</span>: hello,</span><br><span class="line">      <span class="attr">goodbye</span>: goodbye</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>



<p><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES Module</a></p>
<p>是我做前端开始听的最多的了，当然也因为无时无刻都在用它。</p>
<p>上面咱们所说的，都不是JavaScript固有的。不过幸运的是，<a href="https://github.com/tc39">TC39</a>（定义ECMAScript语法和语义的标准机构）引入了ECMAScript 6（ES6）内置模块。</p>
<p>ES6提供了多种导入和导出模块的可能性，其他人则做了很好的解释-以下是其中的一些资源：</p>
<ul>
<li><a href="http://jsmodules.io/cjs.html">jsmodules.io</a></li>
<li><a href="http://exploringjs.com/es6/ch_modules.html">Explorationjs.com</a></li>
</ul>
<p>与CommonJS或AMD相比，ES6模块最大的优点是它能够提供两全其美的优势：紧凑和声明性语法以及异步加载，以及诸如更好地支持依赖项等附加优点。</p>
<p>ES6模块最让人兴奋的应该是导入是导出的<em>实时</em>只读视图，即是只读引用，不过却可以改写属性。所以你猜到了当你模块里的值属性发生变化时，导入的地方获取的值是一样的。ES Module具体的后面还有一篇文档单讲，不然这文章就太长了。</p>
<h3 id="最后我们对比一下两种方式吧"><a href="#最后我们对比一下两种方式吧" class="headerlink" title="最后我们对比一下两种方式吧"></a>最后我们对比一下两种方式吧</h3><h4 id="ES-Module与CommonJS"><a href="#ES-Module与CommonJS" class="headerlink" title="ES Module与CommonJS:"></a>ES Module与CommonJS:</h4><ul>
<li>CommonJS规范通常适用于Node这类服务器端的</li>
<li>CommonJS模块是对象，是运行时加载，运行时才把模块挂载在exports之上（加载整个模块的所有），加载模块其实就是查找对象属性。</li>
<li>ES Module不是对象，是使用export显示指定输出（函数、对象、变量等），再通过import导入。为编译时加载，编译时遇到import就会生成一个只读引用。等到运行时就会根据此引用去被加载的模块取值。所以不会加载模块所有方法，仅取所需。</li>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
</ul>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p><a href="https://scotch.io/tutorials/understanding-scope-in-javascript">全局范围（作用域）</a> 	 	</p>
<blockquote>
<ol>
<li>写在script标签中的JS代码，都在全局作用域 。</li>
<li>全局作用域在页面打开时创建，在页面关闭时销毁。 </li>
<li>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用 。</li>
<li>全局作用域中，创建变量都会作为window对象的属性保存</li>
<li>创建的函数都会作为window对象的方法保存</li>
<li>全局作用域中的变量都是全局变量，在页面的任何部分都可以访问的到并可以修改它</li>
</ol>
</blockquote>
<h4 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h4><blockquote><footer><strong>darlyn</strong><cite><a href="https://juejin.im/post/5b7d2f45e51d4538826f4c28">AMD , CMD, CommonJS，ES Module，UMD</a></cite></footer></blockquote>

<blockquote><footer><strong>Sebastian Peyrott</strong><cite><a href="https://auth0.com/blog/javascript-module-systems-showdown/">JavaScript Module Systems Showdown: CommonJS vs AMD vs ES2015</a></cite></footer></blockquote>





]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js Worker Threads</title>
    <url>/2021/07/23/Node-js-Worker-Threads/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/167920353">https://zhuanlan.zhihu.com/p/167920353</a></p>
<p><a href="https://blog.insiderattack.net/deep-dive-into-worker-threads-in-node-js-e75e10546b11">https://blog.insiderattack.net/deep-dive-into-worker-threads-in-node-js-e75e10546b11</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>OKR</title>
    <url>/2018/06/27/OKR/</url>
    <content><![CDATA[<p>事业部老大从17年开始就在推OKR，以前都是说KPI，所以我想知道OKR又是个啥，以此文章做个记录。</p>
<h1 id="什么是OKR体系？"><a href="#什么是OKR体系？" class="headerlink" title="什么是OKR体系？"></a>什么是OKR体系？</h1><p>OKR体系的全称是Objectives &amp; Key Results，即目标与关键成果。所谓OKR，O &#x3D; Objective 可以理解为企业目标，KR ＝Key Results 可以理解为关键成果。浓缩在一起就是“为确保达成企业目标的关键成果分解与实施”。</p>
<img src="/2018/06/27/OKR/kpi1.png" class="">


<h2 id="二、OKR与KPI的区别"><a href="#二、OKR与KPI的区别" class="headerlink" title="二、OKR与KPI的区别"></a>二、OKR与KPI的区别</h2><p>如果要说 OKR 和 KPI 的区别，区别就在于 KPI 只能让驴使劲走，而 OKR 用于保证驴头朝正确的方向，有些驴拼命想往前走，不希望落后于别人，这时候 OKR 用于帮助驴少走曲线。</p>
<p>OKR考核：“我要做的事”，KPI考核：“要我做的事”，理解不同，但二者都强调有目标,同时也需要有执行力。OKR的思路是先制定目标，然后明确目标的结果，再对结果进行量化，最后考核完成情况。KPI 的思路也是先确定组织目标，然后对组织目标进行分解直到个人目标，然后对个人目标进行量化</p>
<img src="/2018/06/27/OKR/ORK-KPI2.jpg" class="">

<img src="/2018/06/27/OKR/kpi3.jpg" class="">

<p>解释来源于：<blockquote><footer><strong>真人才</strong><cite><a href="http://www.zhenrencai.cn/OKRCase3">OKR管理体系的基本框架</a></cite></footer></blockquote></p>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title>OOM排查工具</title>
    <url>/2022/06/14/OOM%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近刚深度参与了客户现场一个堆的OOM问题的排查，在这儿简单记录一下使用到的工具。</p>
<p>产品为刚发的第一版，功能还在迭代中。</p>
<p>这个现场，是实验局现场，产品运行了1个多月，突然有一天告诉我们程序在能用和不能用之间反复横跳。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我个人先下个结论。</p>
<ol>
<li>对于发布市场的产品版本发生OOM，肯定是由于存在某个外因进而触发了内因引起的。</li>
<li>对于堆的OOM，很可能不是单点问题，而是多点问题，只是在某个时刻由某个单点触发了而已。</li>
</ol>
<p> <strong>问题：</strong></p>
<ol>
<li>为什么突然就OOM？而且一天内发生了多次？</li>
<li>为什么程序直接被系统级的干掉了，连最后的dump都来不及输出？</li>
</ol>
 <span id="more"></span>
<h4 id="为什么突然就OOM？而且一天内发生了多次？"><a href="#为什么突然就OOM？而且一天内发生了多次？" class="headerlink" title="为什么突然就OOM？而且一天内发生了多次？"></a>为什么突然就OOM？而且一天内发生了多次？</h4><p><strong>先看日志：</strong><br>经初步分析发生OOM时，有告警和可视化两个模块在持续输出日志。<br>暂时把关注点放在这两个模块。</p>
<p><strong>再找外因：</strong></p>
<ol>
<li>先检查现场的非功参数看是否是超出了我们的设计，从而引发一系列问题。现场确实比我们第一版所定义的理论数值高，不过这个数值已经涨起来一段时间了，就算有OOM的风险，也不会一天多次。</li>
<li>经过于客户确认，现场当天在进行护网行动，所以会存在多次大面积网络不可访问的情况。意味着会产生大量的告警。这就解释了为啥告警在持续输出。</li>
</ol>
<p><strong>再看内因：</strong></p>
<p> 我们先假设了消耗大量内存的场景：</p>
<ol>
<li>死循环</li>
<li>缓存大量数据的对象</li>
<li>定时任务拉数据</li>
<li>多线程处理数据</li>
<li>队列消费</li>
</ol>
<ul>
<li>jpa query cache plan太大</li>
<li>定时任务太频繁且每次都伴随着拉全量数据</li>
</ul>
<p><a href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#caching-query">https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#caching-query</a></p>
<p><a href="https://tech.asimio.net/2021/01/27/Troubleshooting-Spring-Data-JPA-Specification-and-Criteria-queries-impact-on-Hibernate-QueryPlanCache.html">https://tech.asimio.net/2021/01/27/Troubleshooting-Spring-Data-JPA-Specification-and-Criteria-queries-impact-on-Hibernate-QueryPlanCache.html</a></p>
<p><a href="https://marchen-y.github.io/2020/06/23/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-spring-jpa%E7%BC%93%E5%AD%98%E6%BA%A2%E5%87%BA/">https://marchen-y.github.io/2020/06/23/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-spring-jpa%E7%BC%93%E5%AD%98%E6%BA%A2%E5%87%BA/</a></p>
<p>LIRS算法：<a href="https://ranger.uta.edu/~sjiang/pubs/papers/jiang02_LIRS.pdf">https://ranger.uta.edu/~sjiang/pubs/papers/jiang02_LIRS.pdf</a></p>
<p><a href="https://nullget.sourceforge.io/?q=node/609">https://nullget.sourceforge.io/?q=node/609</a></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li>命令行<blockquote>
<p>比如kubectl xxx、free 、dmesg等</p>
</blockquote>
</li>
<li>netdata<blockquote>
<p>看系统运行指标数据</p>
</blockquote>
</li>
<li>Arthas<blockquote>
<p>实时查看程序内部运行状态</p>
</blockquote>
</li>
<li>JDK(因为做过瘦身只保留了jre)工具<blockquote>
<p>jstat、jcmd、jstack等</p>
</blockquote>
</li>
<li>MAT<blockquote>
<p>查看dump文件</p>
</blockquote>
</li>
<li>gceasy、fastThread<blockquote>
<p>看gc、线程日志</p>
</blockquote>
</li>
</ol>
<h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><pre><code>其实工具没啥特别的，都是这些玩意，主要还是看是否能再适当的时机使用对应的工具找到问题。
工具其实是最好解决的，最难的是人，你得通过各种策略、沟通方式等拿到你想要的信息，特别是此种很可能吃力不讨好的情况。
</code></pre>
<h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><pre><code>故障复盘是有必要的，无所谓追责，关键在于挖掘根因，分析出一些改进、预防措施，助于后续减少相应问题发生的概率以及减轻问题造成的损失。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>OSIV</title>
    <url>/2023/04/11/OSIV/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>问题也是源于一个客户现场问题。</p>
<ul>
<li>主要是页面查询变卡慢。</li>
<li>时不时报数据库连接问题。</li>
</ul>
<p>经查原因如下：</p>
<ul>
<li>在JPA中，设置open-in-view&#x3D;true（默认）的话，会在每个HTTP请求过程中打开一个EntityManager，这个EntityManager会一直保持打开状态，直到HTTP请求结束时才关闭。在这个过程中，EntityManager会维护一个持久化上下文，用于缓存实体对象，以及在需要时延迟加载相关对象。<br>因此，设置open-in-view&#x3D;true会占用一个数据库连接，直到HTTP请求结束时才释放。如果应用程序的并发请求量较大，那么这些连接可能会被耗尽，从而导致应用程序出现性能问题或无法响应请求。</li>
</ul>
<h3 id="跟chatgpt了解了更多"><a href="#跟chatgpt了解了更多" class="headerlink" title="跟chatgpt了解了更多"></a>跟chatgpt了解了更多</h3><p><strong>You:</strong></p>
<p>什么是OSIV</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>我不确定你指的是什么是 “OSIV”。 请问您能否提供更多上下文或信息，以便我更好地回答您的问题？</p>
<hr>
<p><strong>You:</strong></p>
<p>spring里的</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>在Spring中，”OSIV” 是 “Open Session In View” 的缩写，它是一种用于在Web应用程序中处理Hibernate（或其他ORM框架）延迟加载异常的技术。</p>
<p>具体而言，当在Web应用程序中使用Hibernate时，通常会在每个HTTP请求上打开一个Hibernate会话，以便加载数据并填充视图。 在没有OSIV的情况下，当在视图中使用延迟加载属性时，可能会发生”LazyInitializationException”异常。</p>
<p>通过启用OSIV，Spring会在Web请求处理期间保持Hibernate会话打开状态，从而避免延迟加载异常。但是，这种技术也可能导致一些不良影响，例如过度加载和缓存问题，因此使用时应谨慎。</p>
<hr>
<p><strong>You:</strong></p>
<p>优点缺点分别是什么</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>以下是 “Open Session In View”（OSIV）的优点和缺点：</p>
<p>优点：</p>
<ol>
<li><p>避免延迟加载异常：OSIV 可以确保在Web请求处理期间Hibernate会话一直处于打开状态，从而避免了在视图中使用延迟加载属性时可能出现的 “LazyInitializationException” 异常。</p>
</li>
<li><p>简化开发：启用OSIV可以简化开发过程，因为开发人员不需要显式管理Hibernate会话的打开和关闭。这使得代码更加简洁易懂。</p>
</li>
<li><p>提高性能：由于会话不需要在每次需要数据时重新打开和关闭，因此启用OSIV可能会提高应用程序的性能。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>过度加载：启用OSIV可能会导致过度加载，即在应用程序的生命周期中始终保持数据库连接处于打开状态，这可能会导致性能下降和资源消耗过高。</p>
</li>
<li><p>缓存问题：在使用缓存时，启用OSIV可能会导致缓存中的数据变得过时，从而导致数据不一致性。</p>
</li>
<li><p>难以调试：由于会话在整个请求周期中处于打开状态，因此在调试时可能很难确定哪个代码块打开和关闭了会话，从而导致问题的难以定位。</p>
</li>
</ol>
<hr>
<p><strong>You:</strong></p>
<p>缓存问题具体是什么意思</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>启用 “Open Session In View”（OSIV）可能会导致缓存问题，这是因为Hibernate具有一个二级缓存机制，它可以缓存从数据库中检索的实体对象，以避免在每次需要访问它们时都要进行数据库查询。而当启用OSIV时，Hibernate会话保持打开状态，从而可能会导致缓存中的数据变得过时。</p>
<p>具体而言，如果在请求期间Hibernate会话中的某些实体对象被更新或删除，但是由于启用了OSIV，Hibernate会话没有关闭，那么缓存中仍然包含过时的实体对象。如果在同一请求中需要访问这些实体对象，那么就会使用缓存中的过时数据，这可能会导致数据不一致性的问题。</p>
<p>为了避免这种情况，通常建议在处理请求后立即关闭Hibernate会话，以确保缓存中的数据始终与数据库中的数据保持同步。</p>
<hr>
<p><strong>You:</strong></p>
<p>那就是不建议打开OSIV呗</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>是否启用 “Open Session In View”（OSIV）通常取决于应用程序的具体需求和开发人员的偏好。虽然启用OSIV可以简化开发过程并避免延迟加载异常，但也可能会导致过度加载和缓存问题等不良影响。</p>
<p>因此，建议在决定是否使用OSIV时需要考虑应用程序的实际需求。对于一些简单的应用程序，可能不需要使用OSIV，而对于一些复杂的应用程序，启用OSIV可能会带来实际的好处。</p>
<p>同时，如果您决定使用OSIV，请注意使用它的潜在风险，并遵循最佳实践，例如在请求结束后立即关闭Hibernate会话以避免缓存问题。</p>
<hr>
<p><strong>You:</strong></p>
<p>如果开启了OSIV，怎么避免这类问题呢</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>如果您决定启用 “Open Session In View”（OSIV），可以采取以下措施来避免缓存问题：</p>
<ol>
<li><p>只缓存只读数据：在使用缓存时，只缓存只读的实体对象，而不是缓存可以进行修改的实体对象。这可以避免缓存中的数据被过时数据污染。</p>
</li>
<li><p>显式刷新缓存：在每个请求的结束处，显式地刷新Hibernate的二级缓存。这可以确保缓存中的数据与数据库中的数据保持一致。</p>
</li>
<li><p>使用版本控制：在实体类中使用版本控制可以帮助确保在多个事务中不会出现数据不一致的问题。Hibernate会在更新实体时使用版本控制，并在并发修改发生时抛出异常。</p>
</li>
<li><p>禁用缓存：如果缓存问题太棘手，或者您无法控制缓存中的数据，那么可以考虑完全禁用Hibernate的二级缓存。这虽然会降低性能，但可以避免缓存问题。</p>
</li>
</ol>
<p>总之，如果您决定启用OSIV，则应该注意缓存问题，并采取适当的措施来避免数据不一致性。同时，建议在开发过程中进行充分测试，以确保应用程序在使用OSIV时不会出现问题。</p>
<hr>
<p><strong>You:</strong></p>
<p>怎么刷新缓存</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>要刷新Hibernate的二级缓存，可以使用以下方法之一：</p>
<ol>
<li>手动刷新缓存：可以使用 <code>SessionFactory</code> 的 <code>getCache()</code> 方法获取二级缓存，然后调用 <code>evictAllRegions()</code> 方法刷新缓存，示例如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> ... <span class="comment">// 获取SessionFactory实例</span></span><br><span class="line">sessionFactory.getCache().evictAllRegions(); <span class="comment">// 刷新缓存</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在事务提交时自动刷新缓存：可以在Hibernate配置文件中设置 <code>hibernate.cache.use_second_level_cache</code> 和 <code>hibernate.cache.use_query_cache</code> 属性为 <code>true</code>，并在事务提交时自动刷新缓存。示例如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_second_level_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_query_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，还可以通过在实体类上使用 <code>@Cache</code> 注解来控制实体类的缓存策略，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cacheable</span></span><br><span class="line"><span class="meta">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，实体类 <code>User</code> 将被缓存，并使用 <code>READ_WRITE</code> 缓存策略。如果在更新 <code>User</code> 对象时使用了 Hibernate 的缓存，则会自动刷新该对象的缓存。</p>
<p>总之，要刷新Hibernate的二级缓存，可以手动刷新缓存或在事务提交时自动刷新缓存，还可以通过使用 <code>@Cache</code> 注解来控制实体类的缓存策略。</p>
<hr>
<p><strong>You:</strong></p>
<p>怎么使用使用版本控制</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>在Hibernate中使用版本控制可以帮助确保在多个事务中不会出现数据不一致的问题。Hibernate通过使用版本号来实现版本控制，每个实体类都必须定义一个版本号属性。当更新实体时，Hibernate会自动更新版本号，并在并发修改发生时抛出异常。以下是如何使用版本控制的步骤：</p>
<ol>
<li>在实体类中定义版本号属性，通常使用 <code>@Version</code> 注解，示例如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新实体时，Hibernate会自动更新版本号。在并发修改发生时，Hibernate会抛出 <code>StaleObjectStateException</code> 异常，示例如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>);</span><br><span class="line">user.setName(<span class="string">&quot;New Name&quot;</span>);</span><br><span class="line">session.update(user); <span class="comment">// 更新实体</span></span><br></pre></td></tr></table></figure>

<p>如果在此之前，有另一个事务更新了同一行记录，那么在第二个事务中更新实体时，Hibernate会抛出 <code>StaleObjectStateException</code> 异常，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Another New Name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个事务中更新实体时，Hibernate会抛出异常</span></span><br><span class="line">session.update(user); <span class="comment">// 抛出StaleObjectStateException异常</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理并发修改异常。当出现并发修改异常时，通常需要处理该异常并决定如何解决冲突。例如，可以使用乐观锁来处理并发修改异常，即在更新实体时检查版本号是否匹配。如果版本号匹配，则更新实体，否则抛出异常。示例如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>);</span><br><span class="line">user.setName(<span class="string">&quot;New Name&quot;</span>);</span><br><span class="line">session.update(user); <span class="comment">// 更新实体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在更新实体后，检查版本号是否匹配</span></span><br><span class="line">    session.flush(); <span class="comment">// 将更新保存到数据库</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (OptimisticLockException e) &#123;</span><br><span class="line">    <span class="comment">// 处理并发修改异常</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，在Hibernate中使用版本控制可以帮助确保在多个事务中不会出现数据不一致的问题。可以在实体类中定义版本号属性，并在更新实体时处理并发修改异常。</p>
<hr>
<p><strong>You:</strong></p>
<p>请给一个完整的版本冲突的代码实现</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>以下是一个简单的版本冲突的代码实现，其中使用乐观锁处理并发修改异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中更新实体</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    session.update(user); <span class="comment">// 更新实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        session.flush(); <span class="comment">// 将更新保存到数据库</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OptimisticLockException e) &#123;</span><br><span class="line">        <span class="comment">// 处理并发修改异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Update failed due to concurrent modification!&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先获取要更新的实体，并将其名称设置为新名称。然后调用 <code>session.update()</code> 方法将实体标记为“脏”并更新到缓存中。最后，使用 <code>session.flush()</code> 方法将更改保存到数据库。如果在此之前有另一个事务更新了同一行记录，则在当前事务中调用 <code>session.flush()</code> 方法时，Hibernate会抛出 <code>OptimisticLockException</code> 异常。可以在异常处理程序中处理并发修改异常，并根据需要回滚事务。</p>
<hr>
<p><strong>You:</strong></p>
<p>怎么回滚事务</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>在Java中，可以使用try-catch语句块和异常处理程序来回滚事务。如果在事务中出现异常，则可以在异常处理程序中调用 <code>rollback()</code> 方法来回滚事务。以下是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在事务中执行数据库操作</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行可能会抛出异常的代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，则回滚事务</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，使用了 Spring Framework 的事务注解 <code>@Transactional</code> 来标记方法作为事务。在方法中，执行数据库操作，然后使用try-catch语句块捕获异常。如果出现异常，则调用 <code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code> 方法将事务标记为回滚状态，并将异常抛出给调用者。这将导致 Spring 回滚事务并将异常传播给调用者。</p>
<hr>
<p><strong>You:</strong></p>
<p>怎么禁用二级缓存</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>禁用二级缓存需要在Hibernate的配置文件中进行设置。以下是禁用Hibernate二级缓存的配置示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 其他配置项 --&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 禁用二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_second_level_cache&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的配置中，设置了 <code>hibernate.cache.use_second_level_cache</code> 属性为 <code>false</code>，表示禁用了Hibernate的二级缓存。</p>
<p>需要注意的是，如果应用程序使用了Hibernate的查询缓存，仍然需要将 <code>hibernate.cache.use_query_cache</code> 属性设置为 <code>true</code>，否则查询缓存也会被禁用。</p>
<p>另外，如果使用Spring框架进行数据访问，可以在 <code>application.properties</code> 文件中配置 <code>spring.jpa.properties.hibernate.cache.use_second_level_cache</code> 属性来禁用Hibernate二级缓存：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_second_level_cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>You:</strong></p>
<p>OSIV什么情况下才会关闭session</p>
<hr>
<p><strong>ChatGPT:</strong></p>
<p>在开启 Open Session In View (OSIV) 模式的情况下，session 会在请求结束时自动关闭。具体来说，一般情况下，在控制器方法执行完毕后，Spring 框架会调用 <code>DispatcherServlet</code> 的 <code>processDispatchResult</code> 方法，该方法会在返回响应之前关闭 <code>Hibernate Session</code>。这样可以确保在整个请求处理过程中都可以访问数据库并且避免了一些潜在的问题，比如：延迟加载异常等。</p>
<p>但是，需要注意的是，在使用某些数据访问方式时（如 <code>JdbcTemplate</code>），并不会自动开启 Hibernate Session，因此也就不会自动关闭。在这种情况下，需要手动开启 Session，并在使用完毕后手动关闭 Session，以避免潜在的连接泄漏问题。</p>
<p>总之，在使用 Open Session In View 模式时，要注意确保 session 在请求结束时被正确地关闭，以免出现连接泄漏等问题。<br><a href="https://stackoverflow.com/questions/30549489/what-is-this-spring-jpa-open-in-view-true-property-in-spring-boot">https://stackoverflow.com/questions/30549489/what-is-this-spring-jpa-open-in-view-true-property-in-spring-boot</a></p>
<p><a href="https://medium.com/@rafaelralf90/open-session-in-view-is-evil-fd9a21645f8e">https://medium.com/@rafaelralf90/open-session-in-view-is-evil-fd9a21645f8e</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>PO和研发免干架沟通指南(1)</title>
    <url>/2020/12/29/PO%E5%92%8C%E7%A0%94%E5%8F%91%E5%85%8D%E5%B9%B2%E6%9E%B6%E6%B2%9F%E9%80%9A%E6%8C%87%E5%8D%97-1/</url>
    <content><![CDATA[<img src="/2020/12/29/PO%E5%92%8C%E7%A0%94%E5%8F%91%E5%85%8D%E5%B9%B2%E6%9E%B6%E6%B2%9F%E9%80%9A%E6%8C%87%E5%8D%97-1/a.jpg" class="" title="Photo by Stillness InMotion on Unsplash">



<p>新产品线跑了一段时间了，这两天团队复盘了一哈，其中谈到了产品和研发沟通问题。</p>
<p>简单记录一下</p>
<h5 id="梳理了这么一个公式"><a href="#梳理了这么一个公式" class="headerlink" title="梳理了这么一个公式"></a><strong>梳理了这么一个公式</strong></h5><ul>
<li><p>我做了xx设计(实现)</p>
<p>1.xx<br>2.xx<br>3.xx</p>
</li>
<li><p>能达到xx效果</p>
<p>1.xx<br>2.xx<br>3.xx</p>
<hr>
<p><strong>point来了，我分割一下</strong></p>
</li>
<li><p>它的限制是什么</p>
<p>1.xx<br>2.xx<br>3.xx</p>
<p>导致达不到xx效果<br>1.xx<br>2.xx</p>
</li>
</ul>
<h5 id="切记"><a href="#切记" class="headerlink" title="切记"></a>切记</h5><p>所以说做东西别上来先傲娇吧啦吧啦说一通，报喜不报忧，后面只会任由PO摩擦。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA vs Flutter</title>
    <url>/2021/07/23/PWA-vs-Flutter/</url>
    <content><![CDATA[<p><a href="https://www.simicart.com/blog/pwa-vs-flutter/">https://www.simicart.com/blog/pwa-vs-flutter/</a></p>
]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>pwa</tag>
      </tags>
  </entry>
  <entry>
    <title>Personal Growth</title>
    <url>/2019/08/05/Personal-Growth/</url>
    <content><![CDATA[<p>来自Quora上的一个关于个人成长的问答，先摘录在这儿，成长计划可参考之。</p>
<p>Travel<br>Wake up early<br>Wake up and go to bed at the same time as much as possible<br>Get rid of toxic people<br>Focus on networking and building your network<br>Exercise daily, even if it is 5–10 minutes of intense exercise<br>Eat a high protein&#x2F;high fat breakfast within 30 minutes of waking<br>Drink plenty of water throughout the day<br>Focus on the 80&#x2F;20 rule<br>Focus on compounding activities. Like giving up alcohol or dramatically reducing it leads to more money and energy, which could result in more money if you reinvest the surplus. Same thing with negotiation and spending habits - Why the wealthy spend less on luxury: the 70&#x2F;30 rule in finance<br>Read, read and read. Read about personal health, sales, management, marketing and personal finance - Best investment books for beginners</p>
<blockquote>
<ol>
<li>旅行</li>
<li>起得很早</li>
<li>尽可能多地醒来上床睡觉</li>
<li>摆脱有毒的人</li>
<li>专注于网络和建立网络</li>
<li>即使每天剧烈运动5-10分钟，也要每天运动</li>
<li>醒来30分钟内吃高蛋白&#x2F;高脂早餐</li>
<li>全天多喝水</li>
<li>专注于80&#x2F;20规则</li>
<li>专注于复合活动。 就像放弃酒精或大幅度减少酒精含量一样，它可以带来更多的金钱和精力，如果您将剩余资金再投资，可能会产生更多的钱。 具有谈判和消费习惯的东西-富人为何减少在奢侈品上的消费：70&#x2F;30的金融规则</li>
<li>阅读，阅读和阅读。 了解有关个人健康，销售，管理，市场营销和个人理财的信息-适用于初学者的最佳投资书</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>REST API 设计</title>
    <url>/2021/10/12/REST-API-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><a href="https://www.redhat.com/zh/topics/api/what-is-a-rest-api">https://www.redhat.com/zh/topics/api/what-is-a-rest-api</a></p>
<p><a href="https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/">https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/</a></p>
<p><a href="https://stackoverflow.blog/2021/10/06/best-practices-for-authentication-and-authorization-for-rest-apis/">https://stackoverflow.blog/2021/10/06/best-practices-for-authentication-and-authorization-for-rest-apis/</a></p>
<p><a href="https://phauer.com/2016/testing-restful-services-java-best-practices/">https://phauer.com/2016/testing-restful-services-java-best-practices/</a></p>
<p><a href="https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf">https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf</a></p>
<p><a href="https://www.ibm.com/docs/zh/mam/7.6.0?topic=ppdm-put-method">https://www.ibm.com/docs/zh/mam/7.6.0?topic=ppdm-put-method</a></p>
<p><a href="https://www.freecodecamp.org/news/rest-api-best-practices-rest-endpoint-design-examples/">https://www.freecodecamp.org/news/rest-api-best-practices-rest-endpoint-design-examples/</a><br><a href="http://algermissen.io/classification_of_http_apis.html">http://algermissen.io/classification_of_http_apis.html</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks(一)</title>
    <url>/2020/02/25/React%20Hooks(%E4%B8%80)/</url>
    <content><![CDATA[<img src="/2020/02/25/React%20Hooks(%E4%B8%80)/title.png" class="">

<p>整理自团队内部的分享，因为从17年底启动的产品线，所以用的当时的最新版本16.3.1，由于种种原因一直没有升级，特别是自从出了Hooks之后，我是一直觉得应该进行版本升级了，因为升级这个事是避免不了的，除非你不再接收新的变化。</p>
<p>去年其实呼吁过一次不过被按下来了，犹不死心，所以就借着分享的机会，再团队内部普及一遍。</p>
<p>当然我说了只是普及不是教程，所以要点就两个：</p>
<ol>
<li><strong>Hooks的特性</strong></li>
<li><strong>在项目中的实践</strong></li>
</ol>
<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><p>在介绍Hooks之前先说说我在开发中的一些痛点</p>
<ol>
<li>类组件没办法写的比较轻巧，毕竟好几个生命周期在那儿摆着，有时候不得不冷静一下想想用哪个生命周期合适。</li>
<li><strong>本来是个函数组件，就因为需要添加一个变量（state），所以必须改成class组件。</strong></li>
<li><strong>有关状态管理的逻辑代码很难在组件之间复用、且该业务逻辑的实现代码很多时候被分分散到了不同的生命周期内，当能提组件的时候还好，如果不能提组件那这套代码如果其他地方有用只能重复造轮子</strong></li>
<li>class组件this的指向问题。</li>
</ol>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h4 id="什么是-Hooks"><a href="#什么是-Hooks" class="headerlink" title="什么是 Hooks?"></a>什么是 Hooks?</h4><p>我的理解啊，是这样，就是当你要完成一个动作（事情…），必然就需要一个过程的，有过程就可以分阶段，而在某个阶段，你可以在其前后插入事项从而实现对整个过程的扩展以及把控，这就是hook做的事情，挤进去搞事情。类似的比如Spring里的AOP。</p>
<p>而没有React Hooks之前想要实现上述效果，只能用class+生命周期函数，比如下图。</p>
<img src="/2020/02/25/React%20Hooks(%E4%B8%80)/a.png" class="" title="from https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5a062fb551882535cd4a4ce3">

<p>而React Hooks就是允许你在不编写 class 的情况下使用状态(state)和其他 React 特性。 你还可以<strong>构建自己的 Hooks</strong>, 跨组件共享可重用的有状态逻辑。<strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和在整个渲染过程中进行功能扩展，就用钩子把外部代码”钩”进来。</strong> </p>
<p>从图1到图2的进化，忘掉class抱紧hooks。</p>
<img src="/2020/02/25/React%20Hooks(%E4%B8%80)/5LbsY.jpg" class="" title="图1">

<img src="/2020/02/25/React%20Hooks(%E4%B8%80)/nTmNe.jpg" class="" title="图2">

<h4 id="主要应用的Hook"><a href="#主要应用的Hook" class="headerlink" title="主要应用的Hook"></a>主要应用的Hook</h4><p>列举使用频度较高的几个hook。</p>
<p><strong>useRef</strong> 代替之前的 ref并且更加强大，不仅用于DOM引用。 “ ref”对象是一个通用容器，其当前属性是可变的，并且可以保存任何值，类似于类的实例属性。</p>
<p><strong>useState</strong> 代替之前的 <strong>state</strong></p>
<p><strong>useReducer</strong>可实现redux类似的功能，其实state就算基于useReducer实现的</p>
<p><strong>useEffect</strong> 则可以代替某些生命周期钩子函数，如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。</p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>结合项目中的代码实操一下，感受一下hooks的魅力。</p>
<h5 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a><strong>示例一</strong></h5><p>一个最简单的例子，只是为了加一个变量。</p>
<p>场景：实现弹出窗体的效果，需要一个变量<span style=color:red>visible</span>控制窗口的显示和隐藏，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AlarmCards extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; visible: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateVisible = (visible) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      visible</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &#123;...&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><span style=color:red>切换到Hooks代码如下：</p>
<ol>
<li>class变为函数组件</li>
<li>用useState</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">const AlarmCards = (&#123; ...props &#125;) =&gt; &#123;</span><br><span class="line">  // useState 直接声明变量visible，同时声明方法setVisible来更新visible</span><br><span class="line">  // false 初始值</span><br><span class="line">  const [visible, setVisible] = useState(false);</span><br><span class="line">  </span><br><span class="line">  return &#123;...页面内容...&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a><strong>示例二</strong></h5><p>看一个稍微复杂一点点的例子，只涉及到两个生命周期函数。</p>
<p>场景：从后端获取数据使其更新组件内容，并在该组件卸载时，更新重置状态（变量）到初始值，代码如下：</p>
<p><strong>变量声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export const initState = &#123;</span><br><span class="line">  loading: false,</span><br><span class="line">  data: [],</span><br><span class="line">  header: [],</span><br><span class="line">  // 探测结果弹出层是否打开</span><br><span class="line">  visible: false,</span><br><span class="line">  // 探测结果弹出层参数对象</span><br><span class="line">  drawerParams: &#123;</span><br><span class="line">    appId: null,</span><br><span class="line">    appName: &#x27;&#x27;,</span><br><span class="line">    record: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>请求方法封装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 排查对比表</span><br><span class="line"> * @param params 参数对象</span><br><span class="line"> * @returns &#123;Function&#125;</span><br><span class="line"> */</span><br><span class="line">export const getComparisonTable = (&#123; ...params &#125;) =&gt; &#123;</span><br><span class="line">  /**</span><br><span class="line">   * alarmRule 告警规则（类型）</span><br><span class="line">   * updateTime 告警更新时间</span><br><span class="line">   * onDotClick 小圆点的点击事件</span><br><span class="line">   * appId 当前告警的应用id</span><br><span class="line">   * span 告警计算时间跨度</span><br><span class="line">   */</span><br><span class="line">  const &#123; alarmId, alarmRule, updateTime, onDotClick, appId, span &#125; = params;</span><br><span class="line">  // 开始请求</span><br><span class="line">  setState(&#123; loading: true &#125;);</span><br><span class="line">  const errorCallback = () =&gt; &#123;</span><br><span class="line">    setState(&#123; loading: false &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  req(BASE_WEB_API.GET_ALARM_DETAIL_COMPARISON, &#123; alarmId, alarmRule, updateTime &#125;, null, &#123;</span><br><span class="line">    errorCallback</span><br><span class="line">  &#125;).then(result =&gt; &#123;</span><br><span class="line">    if (!isAvailableArray(result)) &#123;</span><br><span class="line">      setState(&#123; loading: false &#125;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 生成表格需要的表头和数据</span><br><span class="line">    const data = generateTableObjs(result, onDotClick, appId);</span><br><span class="line">    setState(&#123; ...data, loading: false &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>展示组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AlarmTable extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; alarmId, alarmRule, updateTime, appId, getComparisonTable, span,</span><br><span class="line">    onDotClick &#125; = this.props;</span><br><span class="line">    // 获取对比表数据</span><br><span class="line">    getComparisonTable(&#123; alarmId, alarmRule, updateTime, onDotClick, appId, span &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    const &#123; setState &#125; = this.props;</span><br><span class="line">    // 重置state避免脏数据影响折叠面板展开和关闭</span><br><span class="line">    setState(model.initState);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">render() &#123;</span><br><span class="line">   ....</span><br><span class="line">  return &#123;...页面内容...&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><span style=color:red><strong>Hooks切换，代码如下：</strong></span></p>
<ol>
<li>class变为函数组件</li>
<li>用useState+useEffect</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useEffect, useState &#125; from &#x27;react&#x27;;</span><br><span class="line">const AlarmTable = (&#123; ...props &#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; alarmId, alarmRule, updateTime, appId, closeLoading, span, onDotClick &#125; = props;</span><br><span class="line">    // 变量声明</span><br><span class="line">  const [tableData, setTableData] = useState(&#123; data: [], header: [] &#125;);</span><br><span class="line"></span><br><span class="line">  // 开始请求， useEffect可当作componentDidMount，componentDidUpdate 和 </span><br><span class="line">  // componentWillUnmount三个生命周期的组合</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const &#123; alarmId, alarmRule, updateTime, appId, onDotClick, closeLoading &#125; = props;</span><br><span class="line">  const errorCallback = () =&gt; &#123;</span><br><span class="line">    closeLoading(false);</span><br><span class="line">  &#125;;</span><br><span class="line">  req(BASE_WEB_API.GET_ALARM_DETAIL_COMPARISON, &#123; alarmId, alarmRule, updateTime &#125;, null, &#123;</span><br><span class="line">    errorCallback</span><br><span class="line">  &#125;).then(result =&gt; &#123;</span><br><span class="line">    if (!isAvailableArray(result)) &#123;</span><br><span class="line">      errorCallback();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 生成表格需要的表头和数据</span><br><span class="line">    const data = generateTableObjs(result, onDotClick, appId);</span><br><span class="line">    setTableData(&#123; ...data &#125;);</span><br><span class="line">    closeLoading(false);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 卸载函数</span><br><span class="line">  return function cleanup() &#123;</span><br><span class="line">    // 重置state避免脏数据影响页面呈现</span><br><span class="line">    setTableData((&#123; data: [], header: [] &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">  return &#123;...页面内容...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><span style=color:red>继续优化：</span></strong></p>
<p><strong>自定义钩子封装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function useCpmparisonTable(closeLoading, alarmId, alarmRule, updateTime, onDotClick, appId) &#123;</span><br><span class="line">  const [drawer, setDrawer] = useState(&#123;</span><br><span class="line">    visible: false,</span><br><span class="line">    drawerParams: &#123; appId: null, appName: null, record: null &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  const [tableData, setTableData] = useState(&#123; data: [], header: [] &#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 开始请求</span><br><span class="line">    const errorCallback = () =&gt; &#123;</span><br><span class="line">      closeLoading(false);</span><br><span class="line">    &#125;;</span><br><span class="line">    req(BASE_WEB_API.GET_ALARM_DETAIL_COMPARISON, &#123; alarmId, alarmRule, updateTime &#125;, null, &#123;</span><br><span class="line">      errorCallback</span><br><span class="line">    &#125;).then(result =&gt; &#123;</span><br><span class="line">      if (!isAvailableArray(result)) &#123;</span><br><span class="line">        errorCallback();</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      // 生成表格需要的表头和数据</span><br><span class="line">      const data = generateTableObjs(result, onDotClick, appId);</span><br><span class="line">      setTableData(&#123; ...data &#125;);</span><br><span class="line">      closeLoading(false);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 功能等同componentWillUnmount</span><br><span class="line">    return  ()=&gt; &#123;</span><br><span class="line">       // 重置state避免脏数据影响页面呈现</span><br><span class="line">       setTableData((&#123; data: [], header: [] &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  return [drawer, setDrawer, tableData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>页面组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const AlarmTable = (&#123; ...props &#125;) =&gt; &#123;</span><br><span class="line">const &#123; alarmId, alarmRule, updateTime, appId, closeLoading, onDotClick &#125; = props;</span><br><span class="line">// 自定义钩子，通常用use开头于官方的钩子呼应，使其能一眼看出这是一个hook</span><br><span class="line">const [ tableData ] = useComparisonTable(closeLoading, alarmId, alarmRule, updateTime, onDotClick, appId);</span><br><span class="line">....</span><br><span class="line">  return &#123;...页面内容...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从示例中可以看出Hooks的带来的一些变化，当然篇幅有限只写了两个Hook，useState和useEffect。</p>
<p>简单总结一下Hooks带来的<strong>优势</strong>。</p>
<ol>
<li><p>干掉了生命周期（夸张了一点点），不用在多个生命周期函数中徘徊</p>
</li>
<li><p>为后面的第三方组件等升级做铺垫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特别是基于React的三方库，比如我们用的Ant Design，</span><br><span class="line">官方前几天发布了4.0有重大升级，假设我们有一天要升级到AntD 4.0，</span><br><span class="line">它会告诉你先要把React升到16.8以后也就是支持Hooks之后的版本。</span><br></pre></td></tr></table></figure>
</li>
<li><p>减少代码量，且从面向函数编程细化到面向<strong>业务逻辑块</strong>编程</p>
<ol>
<li><p>比如不用再bind方法或者不用再写方法体来改变state可用自定的hook封装业务逻辑 使<strong>业务逻辑内聚</strong>，便于整套业务逻辑能够在不同的组件间复用，组件在使用的时候也不需要关注其内部的实现。 </p>
</li>
<li><p>Hook能够在传统的类组件基础上上，实现细化到<strong>逻辑层面的代码复用</strong>，而不仅仅是停留在组件级别， 而且Hook的复用并不是停留在将某些常用的逻辑方法代码抽成一个公共方法，而是可以将之前散落在类组件中各个生命周期中的用于实现某个业务的逻辑代码合并在一起封装成一个自定义的Hook，其他地方随用随调。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如我们的各种CRUD的表单...</span><br><span class="line">比如我们的表格一些通用交互，过滤、刷新、排序、查询...</span><br><span class="line">比如我们的图表的一些通用交互，框选、点选...</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>更简洁易测的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如后续期望分享的前端单元测试的工具，如果我们要把单元测试用起来，</span><br><span class="line">你会发现class和函数写单元测试的差别真的很大</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Hooks不足："><a href="#Hooks不足：" class="headerlink" title="Hooks不足："></a><strong>Hooks不足：</strong></h4><p>当然不能吹爆React的Hooks，虽然业界公认包括官方规划都指出，Hooks是React的未来，未来需要一个过程。</p>
<ol>
<li><p>现在的Hooks还不能完全替代class</p>
</li>
<li><p>使用的Hooks必须保证顺序，即内部是通过两个数组来管理的，所以<strong>不要在循环，条件判断，嵌套函数里面调用 Hooks</strong>。使其下标对不上从而导致state发生混乱，这在前期可能很容易发生bug。</p>
<p>下图可简单理解一下内部的原理：</p>
<img src="/2020/02/25/React%20Hooks(%E4%B8%80)/lQQX7.png" class="">
</li>
<li><p>使用hook后，代码归类不会像之前class组件时代的一样有语法的强制规划了，什么意思呢？在class组件时代，redux的有关的代码是放到connect里的，state生命是放constructor里的，其他逻辑是放每个有关的生命周期里的。而在hook的时代，没有这些东西了，一切都直接放在函数组件内部，如果写得混乱，看起来就是<strong>一锅粥</strong>，所以，制定组件的书写规范和通过注释来归类不同功能的逻辑显得尤为重要。这有助于后期的维护，也有助于保持一个团队在代码书写风格上的一致性。</p>
</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>   <strong>Peace &amp; Love</strong>，没有银弹。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>React Lifecycle</title>
    <url>/2019/04/09/React%20Lifecycle/</url>
    <content><![CDATA[<p>当看到这个error时，才知道自己对React的生命周期理解得还是太薄。</p>
<img src="/2019/04/09/React%20Lifecycle/001.png" class="">


<p><a href="https://tylermcginnis.com/react-interview-questions/">https://tylermcginnis.com/react-interview-questions/</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>React 条件渲染</title>
    <url>/2019/03/22/React%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>产品1.1时，有较大需求的调整，映射到代码则意味着很多功能需要改造或者新增，此时才发现前期由于只求快，代码的可维护性太差，导致要改造模块功能太麻烦，所以就想着边改造边对代码进行重构，一步步提升性能和可维护性。</p>
<p>这个过程我顺便用Lighthouse跑了一下我们的页面，结果挺崩溃的。</p>
<p>我相当不能接受这个结果，遂列出了优化行动项</p>
<ol>
<li>深入学习React<ol>
<li>官网再详细看一遍</li>
<li>极客时间上React学完</li>
<li>medium.com上找对应的React、Redux文章</li>
</ol>
</li>
<li>尽可能少的渲染<ol>
<li>掌握react的条件渲染规则</li>
<li>辨识什么情况下用Redux</li>
<li>父子组件、公共组件的定义和搭配</li>
</ol>
</li>
<li>code review<ol>
<li>代码逻辑</li>
<li>代码可维护性</li>
<li>渲染次数</li>
<li>第三方组件风险</li>
</ol>
</li>
</ol>
<h2 id="React的条件渲染"><a href="#React的条件渲染" class="headerlink" title="React的条件渲染"></a>React的条件渲染</h2><p><em>官方的文章说的很详细，我很舒服。</em></p>
<p><a href="https://reactjs.org/docs/reconciliation.html" title="Reconciliation">https://reactjs.org/docs/reconciliation.html</a></p>
<p><em>这篇文章虽然老了点但是讲的通俗易懂，编于更深入的理解React的Reconciliation</em></p>
<p><a href="https://tylermcginnis.com/react-elements-vs-react-components/" title="React Elements vs React Components">https://tylermcginnis.com/react-elements-vs-react-components/</a></p>
<p><strong>然后我们再谈怎么阻止多余的渲染</strong></p>
<p>官方是这么说的：</p>
<blockquote>
<p>Preventing Component from Rendering<br>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output.</p>
</blockquote>
<p>所以最简单的方式就是当不需要某个模块输出是那就return null，从而避免渲染;</p>
<p>因为我们是React+Redux，梳理代码后得出如下有效技巧：</p>
<ol>
<li>子组件添加state判断</li>
<li>合理记录state用于条件判断是否需要渲染</li>
<li>为元素设置key，选择不会动态变化得作为key，比如id之类的，杜绝使用index</li>
<li>必要的时候设置shouldComponentUpdate</li>
<li>卸载组件后记住重置状态</li>
<li>利用devtool调试并提升代码性能</li>
</ol>
<p>参考：</p>
<blockquote><footer><strong>robinwieruch</strong><cite><a href="https://www.robinwieruch.de/conditional-rendering-react/">All React Conditional Rendering Techniques</a></cite></footer></blockquote>

<blockquote><footer><strong>React</strong><cite><a href="https://reactjs.org/docs/faq-internals.html">Virtual DOM and Internals</a></cite></footer></blockquote>

<blockquote><footer><strong>React</strong><cite><a href="https://reactjs.org/docs/conditional-rendering.html">Conditional Rendering</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks(二)</title>
    <url>/2021/05/21/React-Hooks-%E4%BA%8C/</url>
    <content><![CDATA[<p><a href="https://medium.com/geekculture/useimperativehandle-by-examples-99cbdc8e3c3a">https://medium.com/geekculture/useimperativehandle-by-examples-99cbdc8e3c3a</a></p>
<p><a href="https://stackoverflow.com/questions/57005663/when-to-use-useimperativehandle-uselayouteffect-and-usedebugvalue">https://stackoverflow.com/questions/57005663/when-to-use-useimperativehandle-uselayouteffect-and-usedebugvalue</a></p>
<p>Allow me to preface this answer by stating that all of these hooks are very rarely used. 99% of the time, you won’t need these. They are only meant to cover some rare corner-case scenarios.</p>
<p>useImperativeHandle<br>Usually when you use useRef you are given the instance value of the component the ref is attached to. This allows you to interact with the DOM element directly.</p>
<p>useImperativeHandle is very similar, but it lets you do two things:</p>
<p>It gives you control over the value that is returned. Instead of returning the instance element, you explicitly state what the return value will be (see snippet below).<br>It allows you to replace native functions (such as blur, focus, etc) with functions of your own, thus allowing side-effects to the normal behavior, or a different behavior altogether. Though, you can call the function whatever you like.<br>There could be many reasons you want might to do either of the above; you might not want to expose native properties to the parent or maybe you want to change the behavior of a native function. There could be many reasons. However, useImperativeHandle is rarely used.</p>
<p>useImperativeHandle customizes the instance value that is exposed to parent components when using ref</p>
<p>Example</p>
<p>In this example, the value we’ll get from the ref will only contain the function blur which we declared in our useImperativeHandle. It will not contain any other properties (I am logging the value to demonstrate this). The function itself is also “customized” to behave differently than what you’d normally expect. Here, it sets document.title and blurs the input when blur is invoked.</p>
<p>Show code snippet</p>
<p>useLayoutEffect<br>While similar to some extent to useEffect(), it differs in that it will run after React has committed updates to the DOM. Used in rare cases when you need to calculate the distance between elements after an update or do other post-update calculations &#x2F; side-effects.</p>
<p>The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.</p>
<p>Example</p>
<p>Suppose you have a absolutely positioned element whose height might vary and you want to position another div beneath it. You could use getBoundingCLientRect() to calculate the parent’s height and top properties and then just apply those to the top property of the child.</p>
<p>Here you would want to use useLayoutEffect rather than useEffect. See why in the examples below:</p>
<p>With useEffect: (notice the jumpy behavior)</p>
<p>Show code snippet</p>
<p>With useLayoutEffect:</p>
<p>Show code snippet</p>
<p>useDebugValue<br>Sometimes you might want to debug certain values or properties, but doing so might require expensive operations which might impact performance.</p>
<p>useDebugValue is only called when the React DevTools are open and the related hook is inspected, preventing any impact on performance.</p>
<p>useDebugValue can be used to display a label for custom hooks in React DevTools.</p>
<p>I have personally never used this hook though. Maybe someone in the comments can give some insight with a good example.</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React一点点</title>
    <url>/2018/08/18/React%E4%B8%80%E7%82%B9%E7%82%B9/</url>
    <content><![CDATA[<img src="/2018/08/18/React%E4%B8%80%E7%82%B9%E7%82%B9/one_year_of_react_native.png" class="">



<p>网上关于React的内容一抹多，我就不献丑了，我简单记录一下，主要是一些编程中不太注意的的点。</p>
<p><em><strong>React</strong></em></p>
<p>A JavaScript library for building user interfaces。React是MVC中作用于V的一种库，需要注意它不是一个框架只是一个库。</p>
<p><a href="https://www.quora.com/Why-is-React-called-React">reacts to state changes</a>，react是对页面状态变化做出反应的意思。</p>
<p><em><strong>Component</strong></em></p>
<p>Component  is A piece of the UI，React App is  Tree of component。组件的概念其实之前就有不过我是从React才开始了解的，即把一个前端应用拆分为一个个的组件。</p>
<p><strong><em>React</em>.<em>createElement</em>()</strong></p>
<p>没看到有用React但是为什么还需要import React？</p>
<img src="/2018/08/18/React%E4%B8%80%E7%82%B9%E7%82%B9/1.png" class="" title="https:&#x2F;&#x2F;youtu.be&#x2F;Ke90Tje7VS0">

<p>因为是JSX到JS这样编译后是需要React.createElement来创建元素的，所以需要引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// This JSX:</span><br><span class="line">React.render(&lt;div id=&quot;msg&quot;&gt;Hello World!&lt;/div&gt;, mountNode);</span><br><span class="line"></span><br><span class="line">// Is transformed to this JS:</span><br><span class="line">React.render(React.createElement(&quot;div&quot;, &#123;id:&quot;msg&quot;&#125;, &quot;Hello World!&quot;), mountNode);</span><br></pre></td></tr></table></figure>



<p><em><strong>JSX</strong></em></p>
<p>JavaScript XML</p>
<p><em><strong>Why can’t JSX write If-Else</strong></em></p>
<p>因为 JSX 只是函数调用和对象创建的语法糖，像一下的代码编译后是不合法的JS，没法识别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // This JSX:</span><br><span class="line">&lt;div id=&#123;if (condition) &#123; &#x27;msg&#x27; &#125;&#125;&gt;Hello World!&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> // Is transformed to this JS:</span><br><span class="line">React.createElement(&quot;div&quot;, &#123;id: if (condition) &#123; &#x27;msg&#x27; &#125;&#125;, &quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>



<p><em><strong>Arrow Function</strong></em></p>
<p>为什么箭头函数可以提代bind(this)，首先是因为JS中的一个实验特性<a href="http://github.com/tc39/proposal-static-class-features/">Static class fields and private static methods</a>，一个箭头函数没有它自己的 <code>this</code>，不过他使用的是封闭的执行上下文的 <code>this</code> 值。箭头函数在词法上绑定它们的上下文，所以 <code>this</code> 实际上指向最原始的上下文。</p>
<p>所以有个点我们需要明白，bind不是react要求的，而是因为JS的this对象的指向问题导致的。</p>
<p>bind(this)延伸阅读：<a href="https://www.freecodecamp.org/news/react-binding-patterns-5-approaches-for-handling-this-92c651b5af56/">react-binding-patterns-5-approaches-for-handling-this</a></p>
<p><em><strong>setState</strong></em></p>
<p><em>它接受一个对象或者函数作为参数</em>，如果你想在 <code>setState</code> 之后使用新的 <code>state</code> 来做后续运算就需要使用到函数。</p>
<p><a href="http://huziketang.mangojuice.top/books/react/lesson10">state 和 setstate</a>：为什么不用直接用this.state.xxx&#x3D;xxx;而必须用setState才能修改state，因为如果用this.state.xxx&#x3D;xxx,React无法知道你修改了状态，所以需要调用setState通知到React你修改了状态，然后React会走它那一套更新状态的步奏。</p>
<p><em><strong>props vs state</strong></em></p>
<p>共同点：都可以决定组件的行为和显示形态。</p>
<p><a href="https://codeburst.io/react-state-vs-props-explained-51beebd73b21">react-state-vs-props-explained</a>：</p>
<p>state可以理解为函数的局部变量，所以外部是不能访问和修改的，只有内部能维护。</p>
<p>props它是组件间对话的方式，让外部（父组件）数据和行为传入组件（子组件）内部达到更新内部组件的目的。</p>
<p><em><strong>controlled vs uncontrolled</strong></em></p>
<p>简单的理解了一下，<a href="https://www.robinwieruch.de/react-controlled-components">受控组件</a>这儿受控其实指的是通过props来控制data，非受控通常说的是自己内部维护data，大多数情况下我们都用的是受控组件</p>
<p><a href="https://stackoverflow.com/questions/42522515/what-are-controlled-components-and-uncontrolled-components">What are controlled components and uncontrolled components?</a></p>
<p><em><strong>lifecycle hooks</strong></em></p>
<img src="/2018/08/18/React%E4%B8%80%E7%82%B9%E7%82%B9/1.png" class="" title="https:&#x2F;&#x2F;youtu.be&#x2F;Ke90Tje7VS0">

<h2 id="延伸阅读："><a href="#延伸阅读：" class="headerlink" title="延伸阅读："></a>延伸阅读：</h2><blockquote><footer><strong>proposal-class-public-fields</strong><cite><a href="https://tc39.es/proposal-class-public-fields/">tc39.es/proposal-class-public-fields</a></cite></footer></blockquote>

<blockquote><footer><strong>github tc39</strong><cite><a href="https://github.com/tc39/proposal-class-public-fields">github.com/tc39/proposal-class-public-fields</a></cite></footer></blockquote>

<blockquote><footer><strong>github Demystifying Memory Usage using ES6 React Classes</strong><cite><a href="https://medium.com/dailyjs/demystifying-memory-usage-using-es6-react-classes-d9d904bc4557">medium.com/dailyjs/demystifying-memory-usage-using-es6-react-classes-d9d904bc4557</a></cite></footer></blockquote>



<blockquote><footer><strong>understanding-reactjs-setstate</strong><cite><a href="https://medium.com/@baphemot/understanding-reactjs-setstate-a4640451865b">medium.com/@baphemot/understanding-reactjs-setstate-a4640451865b</a></cite></footer></blockquote>



]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Root User in Ubuntu</title>
    <url>/2020/02/13/Root-User-in-Ubuntu/</url>
    <content><![CDATA[<p>话说从接触Linux那一天起，就有一种独领风骚的傲气，命令走天下的这种霸气，那时候感觉精通Linux的连女朋友都带光环。</p>
<p>我最开始接触Linux是从Ubuntu开始，当时笔记本装了双系统，我就鼓捣了一个Ubuntu，现在用的较多的CentOS，首先入门都是先从了解root开始，我其实一直对root很好奇，刚好今天看到twitter上ruanyf大佬推了一篇文章<a href="https://itsfoss.com/root-user-ubuntu/">Root User in Ubuntu: Important Things You Should Know</a>讲基于Ubuntu的root的文章，基础好用，我们现在做的产品的安装包刚好也是基于Ubuntu做的，所以更有必要在此做个中文版记录。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>文章主要讲了以下四块：</p>
<ol>
<li>为什么在Ubuntu中禁用root用户</li>
<li>以root身份使用命令</li>
<li>切换到root用户</li>
<li>解锁root用户</li>
</ol>
<h3 id="什么是root用户？为什么将其锁定在Ubuntu中？"><a href="#什么是root用户？为什么将其锁定在Ubuntu中？" class="headerlink" title="什么是root用户？为什么将其锁定在Ubuntu中？"></a>什么是root用户？为什么将其锁定在Ubuntu中？</h3><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/01/root_user_ubuntu.png?ssl=1" alt="根用户Ubuntu"></p>
<p>稍微了解Linux的都知道，在Linux中，有一个称为<a href="http://www.linfo.org/root.html">root</a>的超级用户。这是超级管理员帐户，可以使用系统执行任何操作。它可以访问任何文件并在Linux系统上运行任何命令。</p>
<p>拥有权利的同时也被赋予了重大的责任。超级用户可以为您提供对系统的完全控制权，因此也格外谨慎。超级用户可以访问系统文件并运行命令来更改系统配置。因此，错误的命令可能会造成无法挽回的损失，比如网上老说的一个梗：当rm -rf 之后我跑路了。所以一般情况下都不会给root权限，管理员会分配部分权限建对应的用户供对应的人使用。</p>
<p>这也说明了为什么<a href="https://ubuntu.com/">Ubuntu</a>默认情况下锁定了root用户，就是为了避免意外灾难。</p>
<p>您无需具有root特权即可执行日常任务，例如将文件移动到主目录中，从Internet下载文件，创建文档等。</p>
<p>*<strong>以此类比更好地理解它。如果必须切水果，可以使用菜刀。如果必须砍伐树木，则必须使用锯。现在，您可以使用锯切水果，但这不明智，是吗？*</strong></p>
<p>这是否意味着您不能成为Ubuntu的root用户或无法使用具有root用户特权的系统？不，您仍然可以在“ sudo”的帮助下获得root用户访问权限（在下一节中说明）。</p>
<blockquote>
<p>重点：</p>
<p>用户功能强大，无法用于常规任务。这就是为什么不建议始终使用root的原因。您仍然可以使用root运行特定命令。</p>
</blockquote>
<h3 id="如何在Ubuntu中以root用户身份运行命令？"><a href="#如何在Ubuntu中以root用户身份运行命令？" class="headerlink" title="如何在Ubuntu中以root用户身份运行命令？"></a>如何在Ubuntu中以root用户身份运行命令？</h3><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/01/sudo_sandwich.png?ssl=1" alt="须藤三明治xkcd">图片来源：<a href="https://xkcd.com/149/">xkcd</a></p>
<p>当你需要某些系统特定任务的root特权。例如，如果要<a href="https://itsfoss.com/update-ubuntu/">通过命令行更新Ubuntu</a>，则不能以常规用户身份运行该命令。会有以下类似的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">Reading package lists... Done</span><br><span class="line">E: Could not open lock file /var/lib/apt/lists/lock - open (13: Permission denied)</span><br><span class="line">E: Unable to lock directory /var/lib/apt/lists/</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/pkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/srcpkgcache.bin - RemoveCaches (13: Permission denied)</span><br></pre></td></tr></table></figure>

<p>那么，这个时候怎么做呢？简单的答案是在需要以root身份运行的命令之前添加sudo。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>Ubuntu和许多其他Linux发行版使用一种称为sudo的特殊机制。Sudo是一个程序，用于以root（或其他用户）身份控制对运行命令的访问。</p>
<p>Sudo实际上是一个多功能的工具。可以将其配置为允许用户以root用户身份运行所有命令。您可以配置它仅以root身份运行选定的几个命令。您也可以配置为<a href="https://linuxhandbook.com/sudo-without-password/">不带密码运行sudo</a>。</p>
<p><a href="https://itsfoss.com/install-ubuntu/">在安装Ubuntu时</a>，必须创建一个用户帐户。该用户帐户在您的系统上以管理员身份运行，并且按照Ubuntu中的默认sudo策略，它可以使用root特权在系统上运行任何命令。</p>
<p>运行<strong>sudo不需要root密码，但需要用户自己的password</strong>。</p>
<p>这就是为什么当使用sudo运行命令时，总会一开始就询问密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gamehu@nuc:~$ sudo apt update</span><br><span class="line">[sudo] password for gamehu: </span><br></pre></td></tr></table></figure>

<p>如您在上面的示例中看到的，用户gamehu试图使用<em>sudo</em>运行’apt update’命令，系统要求输入gamehu的密码。</p>
<p><strong>要注意当您开始在终端中输入密码时，屏幕上什么都没有发生不会有任何显示，也没有所谓的删除键、退格键…这里会记录你按下的所有键。因为作为默认安全功能，屏幕上不显示任何内容。甚至没有星号（*）。您输入密码，然后按Enter。*</strong></p>
<blockquote>
<p>划重点：</p>
<p>要在Ubuntu中以root身份运行命令，请在命令前添加sudo。<br>当要求输入密码时，输入您的帐户密码。<br>在屏幕上键入密码时，看不到任何内容。只需继续正确的输入密码，然后按Enter。</p>
</blockquote>
<h3 id="如何在Ubuntu中成为root用户？"><a href="#如何在Ubuntu中成为root用户？" class="headerlink" title="如何在Ubuntu中成为root用户？"></a>如何在Ubuntu中成为root用户？</h3><p>你可以使用sudo以root身份运行命令。但是，在某些情况下，您必须以root用户身份运行多个命令，则可以临时切换为root用户。</p>
<p>sudo命令允许您使用以下命令模拟root登录shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">gamehu@nuc:~$ sudo -i</span><br><span class="line">[sudo] password for gamehu: </span><br><span class="line">root@nuc:~# whoami</span><br><span class="line">root</span><br><span class="line">root@nuc:~# </span><br></pre></td></tr></table></figure>

<p>您会注意到，切换到root用户时，shell命令提示符将从$（美元键符号）更改为＃（磅键符号）。</p>
<p>*<strong>尽管已向您展示了如何成为root用户，但我必须警告你，应避免将系统用作root用户。毕竟出于某种原因，我们不建议这样做。*</strong></p>
<p>临时切换到root用户的另一种方法是使用su命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>

<p>如果您尝试在不使用sudo的情况下使用su命令，则会遇到“ su身份验证失败”错误。</p>
<p>您可以使用exit命令恢复为普通用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>





<h3 id="如何在Ubuntu中启用root用户？"><a href="#如何在Ubuntu中启用root用户？" class="headerlink" title="如何在Ubuntu中启用root用户？"></a>如何在Ubuntu中启用root用户？</h3><p>到目前为止，您已经知道默认情况下，root用户在基于Ubuntu的发行版中被锁定。</p>
<p>Linux使您可以自由地对系统进行任何操作。解锁root用户是这些自由之一。</p>
<p>如果出于某种原因决定启用root用户，则可以通过为它设置密码来启用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>

<p>同样，不建议这样做，我也不鼓励您在桌面上执行此操作。如果忘记了密码，将无法再次<a href="https://itsfoss.com/how-to-hack-ubuntu-password/">在Ubuntu中更改root密码</a>。</p>
<p>您可以通过删除密码来再次锁定root用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd -dl root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SSO实践</title>
    <url>/2019/12/27/SSO%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<img src="/2019/12/27/SSO%E5%AE%9E%E8%B7%B5/florian-olivo-4hbJ-eymZ1o-unsplash.jpg" class="" title="Photo by Florian Olivo on Unsplash">



<h1 id="OK，正式说明了"><a href="#OK，正式说明了" class="headerlink" title="OK，正式说明了"></a>OK，正式说明了</h1><p>SSO的说明网上有很多我就不在这儿丢人了。找了张小图SSO的作用一目了然。</p>
<img src="/2019/12/27/SSO%E5%AE%9E%E8%B7%B5/whatis-single_sign_on-h.png" class="" title="https:&#x2F;&#x2F;searchsecurity.techtarget.com&#x2F;definition&#x2F;single-sign-on">

<p>以下主要记录一下我在产品中SSO的实践案例。</p>
<h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><p><strong>案例1</strong> 是比较标准的基于OpenID方式的SSO，用Node.js写的。</p>
<p>案例1没什么说的，网上样例很多，如果有兴趣可以看下我之前写的，不过比较老了，也是第一次写nodejs。</p>
<blockquote><footer><strong>OpenID+MongoDB实现的数据交换中心</strong><cite><a href="https://github.com/WebHu/async_data_exchange_center.git">github.com/WebHu/async_data_exchange_center.git</a></cite></footer></blockquote>



<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a><strong>案例2</strong></h3><p>则是非标的SSO，用Java+javascript写的。</p>
<p>案例2虽然不是非标的，不过整体流程是具备的，比较适用特定编码场景（Spring Security+OpenID），可能有需要的同学，反正我是没在网上找到这类案例。</p>
<img src="/2019/12/27/SSO%E5%AE%9E%E8%B7%B5/sso.png" class="" title="场景说明">

<p>客户现场的系统A需要登入到我们提供的系统B，没有单独用户中心即也不存在用户同步，客户要求的是能无缝登入，所以解决办法有用户则直接登入无用户则创建后再登入，登录效果与从登录页面发起的登录一样，所以token解析后用Security的方式执行登录。</p>
<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * sso出现在路径末尾 react router方式 目前采用这种方式 http://.../frame/#/module/xxx?sso=xxx 避免sso一直保留</span><br><span class="line"> * @param key 需要获取url参数key</span><br><span class="line"> * @returns &#123;string|null&#125;</span><br><span class="line"> */</span><br><span class="line">export function getSsoString(key) &#123;</span><br><span class="line">  const str = location.hash;</span><br><span class="line">  if (str == null || str.length &lt; 2) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  const arr = str.split(&#x27;?&#x27;);</span><br><span class="line">  if (arr != null &amp;&amp; arr.length === 2) &#123;</span><br><span class="line">    const query = arr[1];</span><br><span class="line">    if (query != null &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">      const words = query.split(&#x27;&amp;&#x27;);</span><br><span class="line">      // 将每一个数组元素以=分隔并赋给obj对象</span><br><span class="line">      for (let i = 0; i &lt; words.length; i++) &#123;</span><br><span class="line">        const tmp_arr = words[i].split(&#x27;=&#x27;);</span><br><span class="line">        const k = decodeURIComponent(tmp_arr[0]);</span><br><span class="line">        const v = decodeURIComponent(tmp_arr[1]);</span><br><span class="line">        if (k === key) &#123;</span><br><span class="line">          return v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 单点登录逻辑 在页面token发送到后端进行验证</span><br><span class="line"> * @param callback</span><br><span class="line"> */</span><br><span class="line">export function sso(callback) &#123;</span><br><span class="line">  const token = getSsoString(&#x27;sso&#x27;);</span><br><span class="line">  if (token != null) &#123;</span><br><span class="line">    req(BASE_WEB_API.SSO, &#123; token &#125;, null, &#123; validateError: true &#125;)</span><br><span class="line">      .then(response =&gt; &#123;</span><br><span class="line">        // do something....</span><br><span class="line">        if (callback != null) &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(e =&gt; &#123;</span><br><span class="line">        console.error(&#x27;failed sso --&gt; &#x27;, e);</span><br><span class="line">        if (callback != null) &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; else if (callback != null) &#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 跳转到猎豹系统</span><br><span class="line"> *</span><br><span class="line"> * @param response</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">@PostMapping(value = &quot;/cheetah&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">public String cheetah(@RequestBody SSOVO ssovo,</span><br><span class="line">                      HttpServletRequest request,</span><br><span class="line">                      HttpServletResponse response) throws Exception &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 验证license</span><br><span class="line">        if (!licenseService.isValid()) &#123;</span><br><span class="line">            LOGGER.error(&quot;license is invalid&quot;);</span><br><span class="line">            return validateTokenError(request, LICENSE_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析token</span><br><span class="line">        Context.Token userToken = Context.getUserInfoFromToken(ssovo.getToken());</span><br><span class="line">        if (isNullOrEmpty(userToken.getUserName()) || isNullOrEmpty(userToken.getPassword())) &#123;</span><br><span class="line">            LOGGER.warn(&quot;token is invalid:&#123;&#125;&quot;, ssovo.getToken());</span><br><span class="line">            return validateTokenError(request);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(&quot;当前单点登录的用户信息为:&#123;&#125;&quot;, JSON.toJSONString(userToken));</span><br><span class="line">        //验证内置用户是否存在，不存在则创建</span><br><span class="line">        SSOUserVO user = ssoService.checkUser(userToken.getUserName(), Context.getCmsContext());</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            // 执行登录</span><br><span class="line">            user.setPassword(userToken.getPassword());</span><br><span class="line">            return ssoLogin(request, response, user);</span><br><span class="line">        &#125;</span><br><span class="line">        //异常时跳转到登录页</span><br><span class="line">        return validateTokenError(request);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOGGER.error(&quot;sso登录失败:&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        return validateTokenError(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String validateTokenError(HttpServletRequest request) &#123;</span><br><span class="line">    return validateError(request, SSO_VERIFICATION_ERROR_MSG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String validateTokenError(HttpServletRequest request, String msg) &#123;</span><br><span class="line">    return validateError(request, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String validateError(HttpServletRequest request, String msg) &#123;</span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    if (session != null) &#123;</span><br><span class="line">        //使session失效</span><br><span class="line">        session.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    SSOErrorVO errorVo = new SSOErrorVO(SSO_VERIFICATION_ERROR, msg);</span><br><span class="line">    return JSON.toJSONString(errorVo);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 执行登录</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @param response</span><br><span class="line"> * @param userToken</span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> * @throws ServletException</span><br><span class="line"> */</span><br><span class="line">private String ssoLogin(HttpServletRequest request, HttpServletResponse response, SSOUserVO userToken) throws IOException, ServletException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //登录</span><br><span class="line">        UsernamePasswordAuthenticationToken authReq</span><br><span class="line">                = new UsernamePasswordAuthenticationToken(userToken.getUserName(), userToken.getPassword());</span><br><span class="line">        authReq.setDetails(new WebAuthenticationDetails(request));</span><br><span class="line">        Authentication auth = authenticationManagerBean.authenticate(authReq);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(auth);</span><br><span class="line">        HttpSession session = request.getSession(true);</span><br><span class="line">        // 永不超时</span><br><span class="line">        session.setMaxInactiveInterval(-1);</span><br><span class="line">        //TODO 静态导入</span><br><span class="line">        session.setAttribute(SPRING_SECURITY_CONTEXT_KEY, SecurityContextHolder.getContext());</span><br><span class="line">        baymaxLoginSuccessHandler.onAuthenticationSuccess(request, response, auth);</span><br><span class="line">    &#125; catch (AuthenticationException failed) &#123;</span><br><span class="line">        LOGGER.warn(</span><br><span class="line">                &quot;sso: InternalAuthenticationServiceException occurred while trying to authenticate the user.&quot;,</span><br><span class="line">                failed);</span><br><span class="line">        SecurityContextHolder.clearContext();</span><br><span class="line">        baymaxAuthenticationFailureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">        validateTokenError(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据用户名，获取用户的token</span><br><span class="line"> *</span><br><span class="line"> * @param userName</span><br><span class="line"> * @param response</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/getToken/&#123;userName&#125;&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">public String getToken(@PathVariable(value = &quot;userName&quot;, required = false) String userName, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        return Context.createToken(userName, PasswordUtil.getPlaintextPwd());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOGGER.error(&quot;获取token失败:&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        formatErrorResponse(response, HttpServletResponse.SC_BAD_REQUEST, e.getMessage());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void formatErrorResponse(HttpServletResponse response, int httpCode, String errorMsg) &#123;</span><br><span class="line">    response.setStatus(httpCode);</span><br><span class="line">    response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">    try (PrintWriter out = response.getWriter();) &#123;</span><br><span class="line">        String errorMsgVo = JSON.toJSONString(ImmutableMap.of(&quot;code&quot;, SSO_GET_TOKEN_ERROR, &quot;message&quot;, errorMsg));</span><br><span class="line">        out.write(errorMsgVo);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        LOGGER.warn(&quot;get token :&#123;&#125;&quot;, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理400异常避免出现白页</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Gamehu</span><br><span class="line"> * @description 接管400异常，个性化错误提示</span><br><span class="line"> * @date 2019/12/19</span><br><span class="line"> */</span><br><span class="line">@RestControllerAdvice(assignableTypes = SSOController.class)</span><br><span class="line">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class SSO400ExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(value = Exception.class)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public Object defaultErrorHandler(Exception e) &#123;</span><br><span class="line">        log.warn(&quot;---SSO验证异常---  ERROR: &#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        return ImmutableMap.of(&quot;code&quot;, SSO_VERIFICATION_ERROR, &quot;message&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引伸阅读："><a href="#引伸阅读：" class="headerlink" title="引伸阅读："></a>引伸阅读：</h3><blockquote><footer><strong>OpenID versus OAuth from the user’s perspective</strong><cite><a href="http://cakebaker.42dh.com/2008/04/01/openid-versus-oauth-from-the-users-perspective/">cakebaker.42dh.com/2008/04/01/openid-versus-oauth-from-the-users-perspective</a></cite></footer></blockquote>

<blockquote><footer><strong>OAUTH-OPENID: YOU’RE BARKING UP THE WRONG TREE IF YOU THINK THEY’RE THE SAME THING</strong><cite><a href="http://softwareas.com/oauth-openid-youre-barking-up-the-wrong-tree-if-you-think-theyre-the-same-thing/">softwareas.com/oauth-openid-youre-barking-up-the-wrong-tree-if-you-think-theyre-the-same-thing</a></cite></footer></blockquote>

<blockquote><footer><strong>What's the difference between OpenID and OAuth?</strong><cite><a href="https://stackoverflow.com/questions/1087031/whats-the-difference-between-openid-and-oauth">stackoverflow.com/questions/1087031/whats-the-difference-between-openid-and-oauth</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title>Serverless</title>
    <url>/2018/06/30/Serverless/</url>
    <content><![CDATA[<p>最近关注ServerMesh时，又听到一个Serverless，所以又了解了解，做个笔记吧。</p>
<p>最近google开源了Knative，感觉Serverless可能又要起飞了。</p>
<p>Serverless也是一种架构模式，中文意思是“无服务器”架构。目前，业界并没有给出明确的定义，把其分成两种类型，分别为“Backend as a Service” 和 “Functions as a Service”。</p>
<blockquote>
<p>个人理解就是开发是不需要维护基础设施以及基础组件，直接填业务代码。</p>
</blockquote>
<h2 id="Serverless与传统架构比较"><a href="#Serverless与传统架构比较" class="headerlink" title="Serverless与传统架构比较"></a>Serverless与传统架构比较</h2><p>传统的互联网APP主要采用C&#x2F;S架构，服务器端需长期维持业务进程来处理客户端请求，并调用代码逻辑完成请求响应流程。而在Serverless架构中，应用业务逻辑将基于FAAS架构形成独立为多个相互独立功能组件，并以API服务的形式向外提供服务；同时，不同功能组件间的逻辑组织代码将存储在Amazon Lambda，Azure Function，Google Cloud Functions等产品上，业务代码仅在调用时才激活运行，当响应结束占用资源便会释放。</p>
<blockquote>
<p>个人理解类似事件驱动的感觉，来了请求就触发业务代码。我理解这种形式是不是很有可能比传统的长期维持的方式要慢一些，因为传统是等着你时刻准备着，serverless是你来了我再启用。</p>
</blockquote>
<p>Serverless 如果是在高并发而且要求数据安全性、独立性的场景应该是不适用。和云厂商真的是强耦合了。后续有时间继续学习吧。</p>
<p>如果想试一试，可以去Cloudflare](<a href="https://workers.cloudflare.com/docs)%E8%AF%95%E8%AF%95%E8%B7%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84js%E8%84%9A%E6%9C%AC%E6%84%9F%E5%8F%97%E4%B8%80%E4%B8%8B%E3%80%82">https://workers.cloudflare.com/docs)试试跑一个简单的js脚本感受一下。</a></p>
<p>参考：</p>
<blockquote><footer><strong>Leo_wlCnBlogs</strong><cite><a href="https://www.cnblogs.com/Leo_wl/p/6055252.html">Serverless 架构：用服务代替服务器</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Mesh</title>
    <url>/2018/07/03/Service%20Mesh/</url>
    <content><![CDATA[<p>之前从国外的一篇博客上了解到了ServiceMesh，觉得很感兴趣，感觉它是完全就是为分布式量身定做的以后肯定会大火，不管以后能不能进入运用ServiceMesh思想的公司，先了解是不错的，果不其然，阿里系首先就来了个dubbo mesh和sofa mesh，我参加阿里的dubbo meeting up时，宣布发布了dubbo mesh。以下内容做个这段时间的学习记录。</p>


<p>Service mesh  我理解其实不是新技术是一个新技术理念。</p>
<p>看了很多相关的文章也看了某些案例，准备动手实践一下。很多service mesh的文章和案例通常都会提到两个单词，data-plane和control-plane，即<strong>数据面板</strong>和<strong>控制面板</strong>。</p>
<p>顾名思义，我理解数据面主要是负责服务间通信传递信息的相关操作，比如负载均衡、服务发现、心跳检测、路由、监控等等，但是你会发现，如果只有数据面板其实是没用的，因为数据面板功能再多但是它是死的，他就像一台计算机，软硬件都配好了就算你跟他通上电，插好网线他也不能工作，因为它不知道他要做什么和怎么做。</p>
<p>而控制面板恰好就是做这个事的，它告诉控制面板应该做什么怎么做，比如服务间通信的规范、路由的地址以及路由的规则、监控的指标、限流、熔断的机制是什么配置是什么？控制面板才能真正让数据面板变成一套可运行的系统。</p>
<p>其实通过很多案例知道，很多大中型的公司特别是互联网公司，他们很早以前就有了自己的数据面板可能叫代理更合适，因为那时候还没流行service mesh的概念，他们也有控制面板（可能那时候更明确的叫法是库或者配置中心）。所以service mesh只是概念新，但应用应该很早就有了，只是现在的提出的service mesh应该更激进一些，直接把数据面板和控制面板剥离出来作为基础设施，脱离业务。</p>
<p>由于近年云原生、容器、微服务等概念的火热，微服务的落地案例越来越多，带来技术革新的同时也带来了烦恼。即微服务的运维（服务治理、路由策略、性能监控等）复杂度，不管是云原生还是容器都旨在让微服务能更快速更高效的部署，但是服务部署后是需要运行的，这么多服务之间的运行的有效性谁来保证，当然在云原生等概念火热之前，很多公司都有自己的微服务架构，服务之间运维也都有自己的一套。但是很多方案基本上都是把对服务运维的管理的代码或者说库耦合在业务代码里的，比如zk的使用，就是耦合在业务代码中的，而且很多时候是每种编程语言都需要开发一套代码来支持。这就让运维变得越来越繁琐，Dev和Ops耦合程度会越来越高。</p>
<p>现在的Istio、linkerd、sofa mesh等其实就为了解决上面说到的痛点。那怎么解决呢，就是把属于基础设施的组件，属于ops的工作从业务中剥离出来。在业务服务的身边跟他派一个书童，这个书童就是service mesh的应用。书童存在的价值是什么？就是让他的少爷能专心的读书，除了读书其它事情一概不用管。我理解这就是service mesh真正的价值。</p>
<h2 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h2><p>云原生（cloud native）<br>我理解的是什么都在云上做，存储、交付、部署、测试等等，最大的特点就是快。</p>
<blockquote><footer><strong>佚名</strong><cite><a href="http://cloud.51cto.com/art/201712/562038.htm">云原生架构概述 不了解你就OUT了</a></cite></footer></blockquote>

<blockquote><footer><strong>Matt Stine</strong><cite><a href="https://pivotal.io/cloud-native">What are Cloud-Native Applications?</a></cite></footer></blockquote>


<hr>
<p>源引：</p>
<blockquote><footer><strong>敖小剑</strong><cite><a href="https://skyao.io/publication/istio-introduction/">服务网格新生代-Istio</a></cite></footer></blockquote>

<blockquote><footer><strong>小数</strong><cite><a href="http://www.servicemesh.cn/?/article/24">深度解析Service Mesh中数据面板与控制面板</a></cite></footer></blockquote>

<blockquote><footer><strong>勇往直前的专栏</strong><cite><a href="https://blog.csdn.net/zl1zl2zl3/article/details/78678460?locationNum=2&fps=1">聊聊Service Mesh：linkerd</a></cite></footer></blockquote>

<blockquote><footer><strong>并发编程网</strong><cite><a href="http://ifeve.com/linkerd-introduction/">《Linkerd官方文档》Linkerd介绍?</a></cite></footer></blockquote>

<blockquote><footer><strong>William Morgan</strong><cite><a href="https://blog.buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/">What’s a service mesh? And why do I need one?</a></cite></footer></blockquote>

<blockquote><footer><strong>goodrain</strong><cite><a href="http://www.servicemesh.cn/?/article/75">Service mesh的历史-The History of the Service Mesh</a></cite></footer></blockquote>

<blockquote><footer><strong>William Morgan</strong><cite><a href="https://thenewstack.io/history-service-mesh/">The History of the Service Mesh</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>service mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>TRIZ</title>
    <url>/2020/07/18/TRIZ/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司从去年引入TRIZ，以激发产品创新，上半年宗磊带着RELAX几位架构师参加了一个课题。从目前公司的成果来看，还是一个非常不错的创新方法，公司也有非常大的决心去推进这个方法论的落地。</p>
<p>之前认为TRIZ不适用软件，上期陆续有多个软件课题获奖，包括一些持续集成，测试，算法等方面的课题，为了让我们未来的产品更有竞争力，我们将会加大这方面的投入。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><strong>当我们遇到实际问题的时候，会产生截然不同的解决问题的思路。</strong>如果是使用传统的试错法，通常是根据问题的现状，利用自己的专业知识和行业知识，尝试不同的办法来寻找问题的解决方案。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/oaLdCUnAnSTHGlk7r08Ru4aTCuTKQMmTOPA4d64fr1hXlbSicfQgtCWpXcvUAB81xEbGzyBZFSH9z1Iqfy3ibzVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>图1 问题导向做法（图片选自网络并修改）</p>
<p>如图1所示，由于并非人人都是专家，都能遇到自己熟悉的问题，所以以往的经验未必对解决问题有太大的帮助。这种<strong>从问题出发，典型的问题导向做法往往不知道问题的解决办法在何处，有点类似“脚踩西瓜皮，划到哪里算哪里”的感觉。</strong>有时虽然能解决问题，但效率较低，且其解决办法是否是最优的也未必知晓。</p>
<p>如果是采用TRIZ创新方法，比如用到TRIZ的工具——<strong>最终理想结果（IFR，Ideal Final Result，也称最终理想解）</strong>，这种从解决问题所追求的结果出发，目标明确，则是典型的结果导向做法，<strong>通过对系统的最终理想结果（IFR）的确定，来判断具体问题的解决方案的空间和解决问题的入手点。</strong></p>
<p>如图2所示，就像在黑夜里航行的船舶看到航灯，其好处是既知晓问题解决的理想方向，在解决问题的时候始终不会迷失方向，又能找到合理的解决问题的入手机会，导向性非常明确，这是以往多数的创新方法所不具备的优点。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/oaLdCUnAnSTHGlk7r08Ru4aTCuTKQMmTQ6FKgQ8R26dp8VNe2CaOSDff96nEEXibAibqhw1dibPrr8wicAX2W0eGKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>图2结果导向做法（图片选自网络并修改）</p>
<p>在实际的培训、咨询和辅导解题中，经常会遇到研发人员不太会正确定义最终理想结果（IFR）和合理使用此工具，不能准确锁定问题，严重影响了问题的解决。那么，<strong>如何指导研发人员快速、准确的确定最终理想结果（IFR）呢？</strong></p>
<p>首先，我们来看看最终理想结果（IFR）的概念，<strong>最终理想结果（IFR）是对发明问题的最好解决方案模型</strong>。<strong>它使系统完全消除了问题，并且没有让系统的参数发生恶化，且对系统的改变最小。</strong>它是解决方案的模型，可以指引着我们去解决发明问题。</p>
<p><strong>通过上述概念，可以了解三个信息：</strong></p>
<p>1）IFR是最好的解决方案模型，注意不是之一，可以用来引导和把握问题的解题方向；</p>
<p>2）通过IFR模型，既要解决系统存在的问题，又不能使系统的参数发生恶化，也就是要消除矛盾；</p>
<p>3）是对系统的最小改变，也就是最小问题，不要考虑对系统进行较大的改变，这不符合IFR的理念。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/oaLdCUnAnSStMic1MZ9JU2Fwmkgf2fwLA4SGS6JqrJhicB1aoOnI0JzvxFCwJftFDmN6icYmVHrDrUrOEK60rzjnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>其次，最终理想结果（IFR）的定义过程中，要注意系统的最终目标和最终理想结果的区别。</p>
<p>系统的最终目标是指所设计的系统应该达成的结果，即<strong>客户之声****（VOC，Voice of Customer）</strong>。例如，客户需要清洁衣物，又不能过于劳累，所以设计了洗衣机，则洗衣机的最终目标就是清洁衣物，至于生产商用什么工作原理、什么系统组成来满足客户的需求，则会有不同的系统（产品）产生。</p>
<p>所以，最终目标往往是客户很模糊的需求，需要认真加以甄别，有相应的工具和流程，这里不加赘述。</p>
<p>再次，<strong>为了打破研发人员的惯性思维，通常建议定义IFR时把握两个原则：</strong></p>
<p>**<br>**</p>
<p>1）以系统的作用对象（又称制品、目标）为入手来定义；</p>
<p>2）定义的IFR应用“自身”或“自我实现”的字眼。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_gif/oaLdCUnAnSStMic1MZ9JU2Fwmkgf2fwLACDlq8JXJRH5D2U760rXkkvAdxeVQuricx7NXiaLIWTEA3l7vS1o9J4Tw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p><strong>例如，清洁衣物，可以用灰尘等污物自身脱离衣物来作为IFR。</strong>当然，如果能做到这一点，系统就是非常理想的系统，但是，这往往是不可能的，否则系统就没有存在的必要了。</p>
<p>既然IFR是不太容易实现，为什么还要这样定义呢？这里主要是基于以下考虑：</p>
<p>1）在解决问题之初，<strong>先抛开各种客观限制条件，把最终理想结果作为终极追求目标</strong>；</p>
<p>2）针对问题情境，结合最终理想结果设立各种理想模型，即最优的模型结构来分析问题；</p>
<p>3）这样定义的IFR在后续的分析很容易达成共识，不会变来变去，干扰解题过程。</p>
<p>这时，我们就可以在最终理想结果（IFR）与系统问题现状之间不断选择不同的次理想结果，方便找到解决问题的入手点。</p>
<p>还是拿清洁衣物来举例说明，让灰尘等污物自己脱离衣物纤维这一IFR无法实现，那么就尝试改变工具（或执行机构），这样次理想结果就是衣物纤维自己能与灰尘等污物分离。</p>
<p><strong>通常应注意：</strong></p>
<p>1）技术物体比天然物体易于改变；</p>
<p>2）工具比制品易于改变；</p>
<p>3）如果系统中无易于改变的要素，即应指出”外部介质”，可以借助中介物原理。</p>
<p>此时需要考虑的就是衣物纤维能不能像荷叶那样，具有自洁能力，灰尘等污物无法附着在衣物纤维上，故而就可以实现清洁衣物的目的。</p>
<p>还有，当衣物纤维不具备自洁功能时，可以将下一个次生理想结果定义为衣物纤维借助外力实现与灰尘等污物分离，这时问题就转变为利用什么力（或场）能实现两者的分离，能达到清洁衣物的目的。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/oaLdCUnAnSTHGlk7r08Ru4aTCuTKQMmT80KkbMQ560P80Vicnjf9F0NSElTCUPeN6SziaqDgX33XApdejbTNaGWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>图3 后退收敛定义IFR的过程（图片选自法思诺FASINNO课件）</p>
<p>如此这般，<strong>通过逐步后退一小步收敛问题的不同理想结果（次生、次次生……），更易发现解决问题的机会</strong>。</p>
<p>可以参照如图3所示的收敛过程进行定义，把不明确的问题通过IFR的多次定义、分析，将问题转化为明确的问题，寻找到解决问题的入手点。</p>
<ul>
<li>什么是TRIZ创新理论</li>
</ul>
<p>TRIZ意译为发明问题的解决理论。TRIZ理论成功地揭示了创造发明的内在规律和原理，着力于澄清和强调系统中存在的矛盾，其目标是完全解决矛盾，获得最终的理想解。它不是采取折中或者妥协的做法，而且它是基于技术的发展演化规律研究整个设计与开发过程， 而不再是随机的行为。实践证明，运用TRIZ理论，可大大加快人们创造发明的进程而且能得到高质量的创新产品。</p>
<h4 id="专利"><a href="#专利" class="headerlink" title="专利"></a>专利</h4><p>TRIZ这个强而有力的工具消除在不同性能测量之间的冲突所引起对妥协和交换的需要，为创新带来了可执行的方法论。</p>
<p><strong>特点</strong></p>
<ul>
<li>降低尝试次数和错误迭代</li>
<li>降低对共同的资源的需要</li>
<li>使用演化的趋势打开历史，为新产品想法证明方向</li>
<li>利用专利规避，突破竞争对手的防御</li>
</ul>
<p><strong>优越性</strong></p>
<p>TRIZ 是一套以人为导向的知识系统之系统化创新问题解决方法。它有别于传统的脑力激荡，TRIZ强调发明或创新可依一定的程序与步骤进行，而非仅是随机或天马行空的脑力刺激。TRIZ 发展至今，从 300 万个专利分析中提取了 1000 个样式等，这个广泛的知识库可使用户在开发实际产品时，面对困难的局面和问题得以迅速获得可能的答案或思路。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/wvDoyVDyfBSib3JHEGZ6p8LcNLxruicicFzJvm9A4hG3he6O3uUdCA027I9b6CpOa9PeUbpmQ6icR0ibvyl9OQGxc6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>TRIZ具体项目的落地成果，取决于几个关键要素：</p>
<p><strong>1. 能识别出关键问题</strong></p>
<p><strong>2. 能想到创新的方案</strong></p>
<p><strong>3. 能把这些方案做出来</strong></p>
<p>因此，在这个过程中需要几个关键要素：</p>
<p>第一：大家能够整合不同的观点，找到关键问题和关键解决方案；</p>
<p>第二：能死磕，把方案落地过程中的关键问题能够解决掉；</p>
<p>第三：落地过程中的具体工作和资源支持。</p>
<p>在这个过程中，我们需要参与者付出三方面的努力：</p>
<p>\1. 积极参与小组讨论活动，因为协作的力量搭配上TRIZ流程才能发挥比较大的作用；</p>
<p>\2. 积极提出方案；</p>
<p>\3. 积极完成分工布置的主要任务。</p>
<p>那么，如何通过考核与激励来实现这一点呢？</p>
<p>我觉得可以从两个角度来实施：</p>
<p><strong>从业务部门的角度</strong>，可以从项目管理的角度来推进落地，考核整个TRIZ小组的项目进度和流程的应用。可以通过定期的项目评审来完成，考核与激励指标都基于项目成果来设置。</p>
<p><strong>从人力资源的角度</strong>，可以考核项目组里每个成员的参与度和贡献度，考核与激励指标基于出席率、创意的数量与质量等。</p>
<p>最终，业务考核可以与项目奖金挂钩，人事考核可以与年终评奖、职称等挂钩。</p>
<p>用图片来总结就是：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/lGJx6AymfugRs43oIGic5IlF9ZgzEdzGm0RMTVxh855VQiblSkkmBoVNrFanmy9dricz9xBIKibjpWWryzzE4icfZJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>如果你对TRIZ感兴趣，并且是产品、研发部门的小伙伴，欢迎扫码添加小助手，发送暗号“TRIZ”，经过验证后，会邀请你进入【研发专属群】，精品直播课+大咖分享+专业咨询… 等着你！</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>TRIZ</tag>
      </tags>
  </entry>
  <entry>
    <title>Tools for Auditing CSS（CSS检查工具）</title>
    <url>/2021/04/26/Tools-for-Auditing-CSS/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前关注比较多的还是js以及js扩展语言方面的检测工具，对css方面的检查工具了解较少，个人感觉css的检查确实比较难。刚好这两天看到了一篇css检查工具的<a href="https://css-tricks.com/tools-for-auditing-css/">文章</a>，刚好蹩脚的翻译一下，做个记录。</p>
<p>就如文中作者所说，当然自身也有体会，css检查一个很大的难点就是：可以<a href="https://css-tricks.com/hearts-in-html-and-css/">通过许多不同的方式</a>来<a href="https://css-tricks.com/hearts-in-html-and-css/">实现相同的样式</a>。这已经就让CSS审核起来有些棘手。</p>
<p>通过之前我在团队内分享的stylelint等工具可以避免一些问题，但是其实是不够的。仍然还有一些问题时无法解决的比如：<a href="https://css-tricks.com/a-quick-css-audit-and-general-notes-about-design-systems/">太多的</a>颜色，排版或z-indexs。</p>
<p> 所以作者给我们列举了一些工具，用于检查css。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="浏览器内的开发工具"><a href="#浏览器内的开发工具" class="headerlink" title="浏览器内的开发工具"></a>浏览器内的开发工具</h4><p>用Chrome DevTools 的 CSS 检查工具举例。 详细的可参考 Umar Hansa 的这篇文章 —<a href="https://css-tricks.com/whats-new-in-devtools-2020/">Chrome一大堆发布于 2020 年的「伟大的」 DevTool 功能</a>。<br>如果你喜欢手动检查 CSS 代码，我们可以使用 Inspect 工具以找出应用于特定元素的 CSS 代码。使用 “Inspect arrow”，我们甚至可以看到关于颜色、字体、大小和可访问性的那些额外的细节。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615281211425_devtools-inspect.png?resize=1342,918&ssl=1" alt="img"></p>
<h5 id="Grid-和-Flex-的检查器"><a href="#Grid-和-Flex-的检查器" class="headerlink" title="Grid 和 Flex 的检查器"></a>Grid 和 Flex 的检查器</h5><p>DevTools 界面中有很多实用的工具，我最喜欢的是 Grid 和 Flex 检查器。要启用它们，请进入设置（DevTools 右上方的一个小齿轮图标），点击 Experiments，然后启用 CSS Grid 和 Flexbox 调试功能。虽然这个工具主要用于调试布局问题，但我有时也会用它来快速判断页面上是否使用了 CSS Grid 或 Flexbox。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615281358961_grid-inspector.png?resize=1342,921&ssl=1" alt="img"></p>
<h5 id="CSS-Overview"><a href="#CSS-Overview" class="headerlink" title="CSS Overview"></a>CSS Overview</h5><p>让我们看看一些更高级的 DevTools 功能。CSS Overview 就是其中之一。</p>
<p>要启用 CSS Overview 工具，进入设置，点击 Experiments，启用 CSS Overview 选项。<br>要打开 CSS Overview 面板，我们可以使用 ⌘ ⇧ P 或 Ctrl ⇧ P 快捷键，输入 css overview，然后选择 Show CSS Overview。这个工具可以展现 CSS 属性的概览，比如颜色、字体、对比度问题、未使用的声明和media查询。我通常用这个工具来判断当前 CSS 代码的好坏。例如，如果有 50 种灰度色彩或过多的排版定义，就意味着样式规范没有被应用到实际，或者甚至可能不存在样式规范。<br><img src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615281703939_css-overview.png?resize=1342,918&ssl=1" alt="img"><br>不过请注意，该工具会对应用于这个页面的样式做出概览，而不是对单个文件做出概览。</p>
<h5 id="Coverage-panel"><a href="#Coverage-panel" class="headerlink" title="Coverage panel"></a>Coverage panel</h5><p>Coverage Panel 工具会显示页面上使用的代码数量和百分比。要查看它，我们可以使用 ⌘ ⇧ P 或 Ctrl ⇧ P 快捷键，键入 Coverage，选择 Show Coverage，然后点击刷新图标。<br>你可以在 URL 过滤器中输入 .css 以用于过滤专门显示 CSS 文件。我通常使用这个工具来了解网站的交付技术。例如，如果我看到 CSS 的覆盖率相当的高，我就可以认为 CSS 文件是为每个页面单独生成的。这可能不是关键数据，但有时它有助于了解缓存策略。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615281772886_coverage.png?resize=1342,919&ssl=1" alt="img"></p>
<h5 id="Rendering-Panel"><a href="#Rendering-Panel" class="headerlink" title="Rendering Panel"></a>Rendering Panel</h5><p>Rendering Panel 是另一个有用的工具。要打开渲染面板，我们可以使用 ⌘ ⇧ P 或 Ctrl ⇧ P 快捷键。这次输入 “Rendering”，然后选择 “Show Rendering” 选项。这个工具有很多选项，个人觉得最好用的是：</p>
<ul>
<li><strong>Paint flashing</strong> — 当重绘事件发生时会显示绿色矩形。我用它来识别需要花费太多渲染时间的区域。</li>
<li><strong>Layout Shift Regions</strong> — 当布局移动发生时显示蓝色矩形。为了充分利用这些选项，我通常在 “网络” 选项卡下设置 “Slow 3G” 预设。我有时会录制我的屏幕，然后放慢视频速度来寻找布局转移。</li>
<li><strong>Frame Rendering Stats</strong> — 显示 GPU 和帧的实时使用情况。这个工具在识别动画卡顿和滚动问题时很方便。</li>
</ul>
<p>这些工具会给出常规检查中没有的数据，它对于了解 CSS 代码是否具有性能以及消耗设备的能量的多少提供依据。<br>其他选项可能对调试问题更有利，比如模拟和禁用各种功能，强制使用 prefers-color-scheme 功能或打印媒体类型，以及禁用本地字体。<br><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615282108070_renderiing.png?resize=1342,918&ssl=1" alt="img"></p>
<h5 id="Performance-Monitor"><a href="#Performance-Monitor" class="headerlink" title="Performance Monitor"></a>Performance Monitor</h5><p>另一个检查 CSS 代码性能的工具是 Performance Monitor。要启用它，我们可以使用 ⌘ ⇧ P 或 Ctrl ⇧ P 快捷键，输入 Performance Monitor，然后选择 Show Performance Monitor 选项。我通常使用这个工具来查看与页面交互或动画发生时会触发多少次重新计算和布局。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615282038861_performance-monitor.png?resize=1342,918&ssl=1" alt="img"></p>
<h5 id="Performance-Panel"><a href="#Performance-Panel" class="headerlink" title="Performance Panel"></a>Performance Panel</h5><p>在 Performance Panel 上，我们可以详细查看页面加载过程中的所有浏览器事件。要启用性能工具，我们可以使用 ⌘ ⇧ P 或 Ctrl ⇧ P 快捷键，输入 Performance，选择 Show Performance，然后点击 “重新加载” 图标。我通常会启用 Screenshots 和 Web Vitals 选项。对我来说，最感兴趣的是First Paint、 First Contentful Paint、Layout Shifts、  Largest Contentful Paint这几个指标。</p>
<p>还有一个饼图显示了绘制和渲染时间。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615282240348_performance.png?resize=1342,918&ssl=1" alt="img"><br>DevTools 可能不算是一个经典的检查工具，但它可以帮助我们了解哪些 CSS 功能被使用，代码的效率，以及代码的执行情况，而这些都是 CSS 代码检查的关键所在。</p>
<h4 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h4><p>DevTools 只是用于检查css的其中一个工具，下面介绍一下其它可用来检查 CSS 代码的工具：</p>
<h5 id="Specificity-Visualizer"><a href="#Specificity-Visualizer" class="headerlink" title="Specificity Visualizer"></a>Specificity Visualizer</h5><p><a href="https://github.com/isellsoap/specificity-visualizer">Specificity Visualizer</a>显示代码库中 CSS 选择器的特殊性。只需访问网站并粘贴 CSS。<br>主图 Main Chart 会显示特定样式与样式表中的位置的关系。另外两个图表显示了特定样式的使用情况。我经常使用这个网站来寻找 “bad” 选择器。例如，如果我看到许多特定样式被标记为红色，我很容易得出结论 —— 这里的 CSS 代码可以改进得更好。在你努力改进时，保存截图以供参考是很有帮助的。<br><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615280650448_specificity-visualizer-frame.png?resize=1342,918&ssl=1" alt="img"></p>
<h5 id="CSS-Specificity-Graph-Generator"><a href="#CSS-Specificity-Graph-Generator" class="headerlink" title="CSS Specificity Graph Generator"></a>CSS Specificity Graph Generator</h5><p><a href="https://jonassebastianohlsson.com/specificity-graph/">CSS Specificity Graph Generator</a>是一个类似的可视化特定样式工具。它显示了一个略有不同的图表，可能会帮助你看到你的 CSS 选择器是如何按特定样式组织的。正如它在工具页面上所说的那样，”波峰是不好的，总的趋势应该是在样式表的后期有更高的特定样式”。进一步讨论这个问题会很有意思，但这不在本文的讨论范围内。然而，Harry Roberts 在他的文章 <a href="https://csswizardry.com/2014/10/the-specificity-graph/">“The Specificity Graph”</a> 中确实广泛地写到了这一点，值得一试。<br><img src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615280474471_css-specificity-graph-generator-frame.png?resize=1342,918&ssl=1" alt="img"></p>
<h5 id="CSS-Stats"><a href="#CSS-Stats" class="headerlink" title="CSS Stats"></a>CSS Stats</h5><p><a href="https://github.com/cssstats/cssstats">CSS Stats</a> 是另一个为你的样式表提供分析和可视化的工具。事实上，Robin 在不久前写过关于它的<a href="https://css-tricks.com/a-quick-css-audit-and-general-notes-about-design-systems/">文章</a>，并展示了他如何使用它来审核他工作中的样式表。<br>你需要做的就是输入网站的 URL，然后点击 Enter。这些信息被分割成有意义的部分，包括了样式的声明数、颜色、排版、z-index 和特定样式等等。同样，你可能要把截图存储起来，以备日后参考。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615280657659_cssstats-frame.png?resize=1342,918&ssl=1" alt="img"></p>
<h5 id="Project-Wallace"><a href="#Project-Wallace" class="headerlink" title="Project Wallace"></a>Project Wallace</h5><p><a href="https://www.projectwallace.com/analyze-css">Project Wallace</a> 是由 Bart Veneman 开发的，而他已经在 CSS Tricks 上介绍了这个<a href="https://css-tricks.com/in-search-of-a-stack-that-monitors-the-quality-and-complexity-of-css/">项目</a>。Project Wallace 的强大之处在于，它可以比较和可视化基于导入的变化。这意味着你可以看到你的 CSS 代码库以前的状态，并看到你的代码在不同状态之间的变化。我觉得这个功能相当有用，特别是当你想说服别人代码是改进过的。该工具对单个项目是免费的，并为更多项目提供付费计划。<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615280724437_projectwallace-frame.png?resize=1342,918&ssl=1" alt="img"></p>
<h4 id="CLI-工具"><a href="#CLI-工具" class="headerlink" title="CLI 工具"></a>CLI 工具</h4><p>除了 DevTools 和在线工具，还有命令行界面（CLI）工具可以帮助我们检查 CSS：</p>
<h5 id="Wallace"><a href="#Wallace" class="headerlink" title="Wallace"></a>Wallace</h5><p>我最喜欢的 CLI 工具之一是<a href="https://github.com/bartveneman/wallace-cli">Wallace</a>。安装后，输入wallace，然后输入网站名称，它就会自动输出显示了你需要知道的关于网站的 CSS 代码的一切。我最喜欢看的是 !important 的使用次数，以及代码中有多少个 ID。另一个信息是顶级特定样式的数量以及有多少选择器使用它。这些可能是 “坏” 代码的危险信号。<br>我最喜欢这个工具的地方是，它可以从网站中提取所有的 CSS 代码 —— 不仅是外部文件，还能够包括内联代码。这就是为什么 CSS Stats 和 Wallace 的报告不匹配的原因。<br><img src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615280252636_wallace-frame.png?resize=671,709&ssl=1" alt="img"></p>
<h5 id="csscss"><a href="#csscss" class="headerlink" title="csscss"></a>csscss</h5><p>csscss CLI 工具可以显示哪些规则共享相同的声明，而这对于识别重复的代码和减少编写的代码量是很有用的。在这样做之前，我会三思而后行，因为这可能是不值得的，尤其是在今天的缓存机制下。值得一提的是，csscss 需要 Ruby 运行环境。<br><img src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2021/03/s_4B1C4D78EB4B7F4A9199BBB917690297400901EB2ABA2FEBF7F40167C51F9C2A_1615280250407_csscss-frame.png?resize=671,709&ssl=1" alt="img"></p>
<h4 id="其他有用的工具"><a href="#其他有用的工具" class="headerlink" title="其他有用的工具"></a>其他有用的工具</h4><ul>
<li><a href="https://github.com/bartveneman/color-sorter">Color Sorter</a> —  先按色调，再按饱和度对 CSS 颜色进行排序。</li>
<li><a href="https://github.com/projectwallace/css-analyzer">CSS Analyzer</a> —  对一串 CSS 进行分析。</li>
<li><a href="https://github.com/bartveneman/constyble">constyble</a> — 这是一个基于 CSS Analyzer 的 CSS 复杂性分析器。</li>
<li><a href="https://extract-css.now.sh/">Extract CSS Now</a> — 从一个网页中获取所有 CSS。</li>
<li><a href="https://content-project-wallace.vercel.app/get-css">Get CSS</a> — 从一个网页中获取所有的 CSS。</li>
<li><a href="https://github.com/oyvindeh/ucss">uCSS</a> — 抓取网站以识别未使用的 CSS。</li>
</ul>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>CSS在我们周围无处不在，我们需要将其视为每个项目的头等公民。 如果您的CSS井井有条且编写精良，那么您将花费更少的时间调试它，而将更多的时间用于开发新功能。 在理想的世界中，我们会训练每个人都编写出色的CSS，但这需要时间。</p>
<p>今天是开始关心CSS代码的日子。</p>
<p>我知道审核CSS对每个人都不会很有趣。 但是，如果您针对这些工具中的任何一个运行代码，并尝试甚至改善CSS代码库的一部分，那么这篇文章就完成了它的工作。</p>
<p>最近，我越来越多地考虑CSS代码，并且试图使更多的开发人员更加尊重CSS代码。 我甚至开始了一个新项目<a href="http://css-auditors.com/">css-auditors.com</a>，该项目专门用于审核CSS。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>检查工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Websocket</title>
    <url>/2023/10/09/Websocket/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近遇到一个现场问题，客户反馈产品页面提示连接错误，一查是ws不能链接，借此复习下ws的内容。毕竟之前写ws功能是好几年前了。温故知新。</p>
<p><a href="https://ably.com/topic/websockets">https://ably.com/topic/websockets</a></p>
<p><a href="https://www.rfc-editor.org/rfc/rfc6455">https://www.rfc-editor.org/rfc/rfc6455</a></p>
<p><a href="https://websockets.spec.whatwg.org/#websocket-opening-handshake">https://websockets.spec.whatwg.org/#websocket-opening-handshake</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>XFS(Structure needs cleaning)</title>
    <url>/2022/12/23/XFS-Structure-needs-cleaning/</url>
    <content><![CDATA[<p>事件缘起于遇到的一个现场问题</p>
<img src="/2022/12/23/XFS-Structure-needs-cleaning/1.png" class="">


<h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h3><p>先问原因：<br>如果是主机不正常关机，很可能是 操作系统的文件系统损害<br>如果是docker的某种操作，那就修改docker<br>如果以上都没问题，再考虑修复clickhouse<br>如果是主机问题，还需要用户解决呢；如果是二、三记录场景，看看如何避免。<br>不论哪个，先询问情况吧。可以用uptime、docker ps等看看启动时间，然后对照日志时间，看看是否对的上<br>16:16<br>估计是主机非正常关机，linux系统很稳定，很少出现文件系统损害。<br>如果是这样，需要开远程，慎重验证、修复。并向用户澄清，有丢失数据的风险（毕竟文件系统坏了），在首肯之后再操作</p>
<p>如果挂载了特殊的 硬件，如：RAID、NAS，由用户的主机管理员解决。（坚决禁止NAS）</p>
<p>非正常关机了？或者升级k8s重启？<br>merge过程分多阶段：<br>生成新文件夹<br>将待合并的多个文件夹，读取合并到新文件夹<br>删除旧文件夹<br>修改相关的系统表（分区表等）<br>这个问题，可以到github看clickhouse源代码，然后猜测问题点</p>
<p>df -T -x tmpfs</p>
<img src="/2022/12/23/XFS-Structure-needs-cleaning/2.jpg" class="">
<p>看来文件夹都在，只是文件系统记录的 状态 和 落盘 不一致了</p>
<p>文件系统需要卸载，所以先要看 有哪些应用在使用 &#x2F;opt&#x2F;local-path-provisioner，将k8s相关的服务都关闭吧</p>
<p>!!确定相关业务已经关闭，然后一个个执行</p>
<p>umount &#x2F;dev&#x2F;sdb1<br>xfs_repair &#x2F;dev&#x2F;sdb1<br>mount &#x2F;dev&#x2F;sdb1</p>
<p>lsblk -f<br>17:39<br>parted -l  可以查看未挂载的文件系统类型，以及那些分区尚未格式化</p>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p>会不会还有程序占用着相关文件？<br>lsof +d &#x2F;opt&#x2F;local-path-xxxxxprovoider<br>后边的路径就是挂载路径</p>
<p>刚还试了<br>没有lsof命令</p>
<p>ps -elf 看看是否有可疑进程，如果关闭k8s，应该没有几个进程在了</p>
<p>pstree命令执行一下，我看看继承顺序</p>
<p>另一个经常出的日志占用内存问题：删除文件后，进程依然持有文件描述符，内容将输出到内存</p>
<p>以后现场会发生的问题：经常出现断网——造成终端停止、里边的长时间命令就会失败<br>建议方法：启动一个tmux，启动命令后，脱离终端，等过一段时间再attach上去</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_file_systems/checking-an-xfs-file-system-with-xfs-repair_checking-and-repairing-a-file-system">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_file_systems/checking-an-xfs-file-system-with-xfs-repair_checking-and-repairing-a-file-system</a></p>
<p><a href="https://bbs.qunyingkeji.com/2052/">https://bbs.qunyingkeji.com/2052/</a></p>
<p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_file_systems/proc_repairing-an-xfs-file-system-with-xfs_repair_checking-and-repairing-a-file-system">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_file_systems/proc_repairing-an-xfs-file-system-with-xfs_repair_checking-and-repairing-a-file-system</a></p>
<p><a href="https://man7.org/linux/man-pages/man8/lsblk.8.html">https://man7.org/linux/man-pages/man8/lsblk.8.html</a></p>
<p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_file_systems/unmounting-a-file-system-with-umount_assembly_mounting-file-systems">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_file_systems/unmounting-a-file-system-with-umount_assembly_mounting-file-systems</a></p>
]]></content>
  </entry>
  <entry>
    <title>X、Y理论</title>
    <url>/2022/08/17/X%E3%80%81Y%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p><a href="https://coolshell.cn/articles/4951.html">https://coolshell.cn/articles/4951.html</a></p>
<p><a href="https://softwareengineering.stackexchange.com/questions/45776/why-do-business-analysts-and-project-managers-get-higher-salaries-than-programmer">https://softwareengineering.stackexchange.com/questions/45776/why-do-business-analysts-and-project-managers-get-higher-salaries-than-programmer</a></p>
<p><a href="https://zh.wikipedia.org/wiki/X%E7%90%86%E8%AE%BA%E5%92%8CY%E7%90%86%E8%AE%BA">https://zh.wikipedia.org/wiki/X%E7%90%86%E8%AE%BA%E5%92%8CY%E7%90%86%E8%AE%BA</a></p>
]]></content>
  </entry>
  <entry>
    <title>You&#39;re worrying about the wrong thing if you&#39;re trying to learn it all</title>
    <url>/2021/07/06/You-are-worrying-about-the-wrong-thing-if-you-re-trying-to-learn-it-all/</url>
    <content><![CDATA[<p>别想着记住所有东西<br><a href="https://www.kevinpowell.co/article/youre-worrying-about-the-wrong-things/">https://www.kevinpowell.co/article/youre-worrying-about-the-wrong-things/</a><br><a href="https://www.youtube.com/watch?v=vP2MNhC_Igw">https://www.youtube.com/watch?v=vP2MNhC_Igw</a></p>
<p>为了成为一名前端开发人员，我们需要学习一百万零一件事，似乎每 30 秒就有另一件新东西需要我们添加到我们的武器库中。</p>
<p>学习新事物可能很有趣，但是当我们需要学习的新事物清单似乎不断增加时，它可能会让人不知所措。</p>
<p>还有一个大问题。当我们离开学习所有这些新东西时，我们他妈的怎么能记住我们已经学过的所有东西？</p>
<p>我经常被问到，通过 DM 或来自追随者的电子邮件，或者有时作为 YouTube 评论，询问记住所有内容的最佳策略。</p>
<p>事实是，我什么都不记得。我记得一些东西是因为我一直在使用它们，并且因为我主要关注 CSS。我使用它们的次数越多，与它们相处得越好，与它们相处的乐趣也就越多。但我不记得一切。</p>
<p>事实上，它甚至不接近。</p>
<h2 id="这都是一个大谎言"><a href="#这都是一个大谎言" class="headerlink" title="这都是一个大谎言"></a>这都是一个大谎言</h2><p>当您观看我的 YouTube 视频或其他人编写代码时，似乎我无所不知。然后下周我发布了一个关于新主题的新视频，我也知道！</p>
<p>我当然是了！我已经把它写好了，而且我之前已经建立了那个东西。</p>
<p>大多数情况下，有关编码的视频和课程中的人们只是从其他屏幕上的已完成版本中复制代码。</p>
<p>事情需要计划好！否则，课程的质量将很糟糕。</p>
<p>但它确实给人一种错误的感觉，即那里的“专业人士”知道并记住一切。</p>
<h2 id="没有人记得这一切"><a href="#没有人记得这一切" class="headerlink" title="没有人记得这一切"></a>没有人记得这一切</h2><p>我喜欢听关于开发的播客的原因之一是当你仰望的人谈论他们是如何忘记事情的时候，或者不得不查找事情的时候（有时是我非常了解的事情！）。</p>
<p>不断在<a href="https://shoptalkshow.com/">ShopTalk Show 上</a>，他们的名字出现了，我非常尊重，他们谈论他们如何必须为他们写的一本书研究某些东西，然后发现自己不得不阅读他们自己书中的部分内容记住它是如何工作的。</p>
<p>我可以理解这一点，<strong>我确实看过我自己视频的一部分来记住如何做某些事情</strong>。</p>
<p>我知道这是我以前知道的东西（毕竟我确实制作了一个视频！），但是因为我有一段时间没有使用那个东西了，也许即使我制作了那个视频，我也不记得到底是怎么回事它不再起作用了！</p>
<p>这是正常的。</p>
<p>而且我认为重要的是要知道我们不应该记住所有内容。</p>
<h2 id="这不是要记住所有内容，而是要知道解决方案存在"><a href="#这不是要记住所有内容，而是要知道解决方案存在" class="headerlink" title="这不是要记住所有内容，而是要知道解决方案存在"></a>这不是要记住所有内容，而是要知道解决方案存在</h2><p>CSS 中有很多小技巧和窍门，很多很酷的小功能，我无法记住它们是如何工作的，或者说，它们甚至都叫什么！</p>
<p>但是出现了一些事情，而不是想“嗯，我不知道我可以在这里做什么”，而是“哦，我知道有这个东西可以帮助解决这个问题”，然后我立即研究它是什么。也许这是我看到一篇文章或视频的东西，或者也许是我过去使用过的东西，只是忘记了它是如何工作的。</p>
<p>这不是要记住一切是如何运作的。你永远不会那样做。相反，它是关于知道解决方案存在。</p>
<p>你做的事情越多，你越需要使用这些晦涩的功能，你就越会记住它们是如何工作的。然后你将不会使用它 6 个月，你会完全忘记。</p>
<p>这很好。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>chatgpt过气小结</title>
    <url>/2023/03/31/chatgpt%E8%BF%87%E6%B0%94%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ol>
<li><p>先得翻墙，有境外的vps。</p>
</li>
<li><p>能接收国外的短信，我用的sms-activate</p>
</li>
<li><p>如果境外的也被封禁，在服务器上安装Cloudflare Warp，让Warp接管ChatGPT域名的访问流量即可。亲测有效。</p>
</li>
</ol>
<h4 id="vscode-插件"><a href="#vscode-插件" class="headerlink" title="vscode 插件"></a>vscode 插件</h4><blockquote>
<p>需要chatgpt的<a href="https://platform.openai.com/account/api-keys">api token</a><br>输出比较慢，估计是一次性把完整结果给出来的原因。可写代码、注释、找bug、重构分析代码等</p>
</blockquote>
<p><a href="https://www.codegpt.co/">https://www.codegpt.co/</a></p>
<div style="width:70%;margin:auto"><img src="/2023/03/31/chatgpt%E8%BF%87%E6%B0%94%E5%B0%8F%E7%BB%93/2.jpg" class="" title="比较慢"></div>


<h4 id="编码工具"><a href="#编码工具" class="headerlink" title="编码工具"></a>编码工具</h4><blockquote>
<p>可写代码、注释、找bug、重构分析代码等<br><a href="https://www.cursor.so/">https://www.cursor.so/</a></p>
</blockquote>
<div style="width:70%;margin:auto"><img src="/2023/03/31/chatgpt%E8%BF%87%E6%B0%94%E5%B0%8F%E7%BB%93/2.gif" class=""></div>

<h4 id="文档解析"><a href="#文档解析" class="headerlink" title="文档解析"></a>文档解析</h4><blockquote>
<p>没啥好说的，就是把文档解析后，可以通过提问的方式从文档里找答案<br><a href="https://chatdoc.com/">https://chatdoc.com/</a></p>
</blockquote>
<h4 id="google搜索集成"><a href="#google搜索集成" class="headerlink" title="google搜索集成"></a>google搜索集成</h4><blockquote>
<p>需要chatgpt的<a href="https://platform.openai.com/account/api-keys">api token</a><br>可以与google搜索无缝集成，且可以直接下载结构为md文档</p>
</blockquote>
<p><a href="https://github.com/josStorer/chatGPTBox">https://github.com/josStorer/chatGPTBox</a></p>
<center><img src="/2023/03/31/chatgpt%E8%BF%87%E6%B0%94%E5%B0%8F%E7%BB%93/1.gif" class=""></center>


<h4 id="传统体验"><a href="#传统体验" class="headerlink" title="传统体验"></a>传统体验</h4><blockquote>
<p>各种基于chatgpt的工具，但是这个最原始的反而是我最喜欢用的，简洁明了<br><a href="https://chat.openai.com/chat">https://chat.openai.com/chat</a></p>
</blockquote>
<div style="width:70%;margin:auto"><img src="/2023/03/31/chatgpt%E8%BF%87%E6%B0%94%E5%B0%8F%E7%BB%93/1.jpg" class="" title="done"></div>]]></content>
  </entry>
  <entry>
    <title>ClickHouse System Tables</title>
    <url>/2023/09/11/clickhouse-system-tables/</url>
    <content><![CDATA[<p>最近处理一个现场故障，现象是系统用一段时间就会变得很慢，clickhouse会重启，etcd发生长时间起不来，业务日志有代码报错。</p>
<p>总结下来大体发现如下几个问题：</p>
<ul>
<li>clickhouse变慢、重启</li>
<li>业务代码报空指针</li>
<li>etcd长时间起不来</li>
</ul>
<p>业务代码问题先给到业务方进行排查，我们先看clickhouse和etcd问题</p>
<h3>clickhouse变慢、重启</h3>

<p>因为对于基础组件都没开系统日志，所以只能从观察系统的指标开始，通过netdata，发现clickhouse会不断的打到峰值</p>
<p>所以先从clickhouse查起，因为没有开日志，所以就从clickhoue提供的系统表开始查起</p>
<p>我们找了下官方资料，先锁定了如下几张表</p>
<ul>
<li>system.query_log</li>
<li>system.query_thread_log</li>
<li>system.metrics</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看可疑的sql</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    address,</span><br><span class="line">    event_time,</span><br><span class="line">    client_hostname,</span><br><span class="line">    read_rows,</span><br><span class="line">    result_rows,</span><br><span class="line">    query_duration_ms</span><br><span class="line"><span class="keyword">FROM</span> system.query_log</span><br><span class="line"><span class="keyword">WHERE</span> event_date <span class="operator">=</span> <span class="string">&#x27;2023-09-09&#x27;</span> </span><br><span class="line"><span class="comment">-- 查看执行sql最多的来源</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    address,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> query_count</span><br><span class="line"><span class="keyword">FROM</span> system.query_thread</span><br><span class="line"><span class="keyword">WHERE</span> event_date <span class="operator">=</span> <span class="string">&#x27;2023-09-09&#x27;</span> <span class="keyword">AND</span> peak_memory_usage <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> address;</span><br><span class="line"><span class="comment">-- 查看消耗内存最大的来源</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    address,</span><br><span class="line">    <span class="built_in">SUM</span>(peak_memory_usage) <span class="keyword">AS</span> total_peak_memory</span><br><span class="line"><span class="keyword">FROM</span> system.query_thread</span><br><span class="line"><span class="keyword">WHERE</span> event_date <span class="operator">=</span> <span class="string">&#x27;2023-09-09&#x27;</span> <span class="keyword">AND</span> peak_memory_usage <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> address;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo讲究(一)</title>
    <url>/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/</url>
    <content><![CDATA[<p>第一次接触dubbo好像是在14年吧，13年参加工作时，在一家半国企，当时他们用的是axis2，当时那一堆代码+XML，让我怀疑是否应该继续干IT，觉得太难用了。后来接触了dubbo，觉得这玩意好，省了很多事，感概开源的力量和大公司的体量。用起来真实很通畅。</p>
<p>当然我们公司也没有作妖，非要选个与众不同所以还是选了dubbo作为服务之间的通信框架。</p>
<p>我这儿也不做什么源码解析了，比我专业的细致的网上很多，我主要解析一下我在用dubbo过程中遇到的问题相关的源码。比如今天讲的就是dubbo的异常机制、序列化协议hession相关的源码。</p>
<p>问题起因在于我们系统中定义了自己的一套异常处理机制，有个自定义异常</p>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error.png" class="" title="异常堆栈信息">

<p>图中的ApiException是我们定义的针对接口异常的异常类，长成下图这样。</p>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error01.png" class="" title="ApiException">

<p>红框的部分是这次发生问题之后加的一个构造参数，加完之后就搞定了。那为什么呢？我们跟着异常信息我们知道是dubbo用的hession那块反序列化报了异常，跟下源码看下。</p>
<ul>
<li>我们找到JavaDeserializer的instantiate方法，找到_constructor，发现是个Constructor，找到赋值地方，在JavaDeserializer实例化时赋值，进入JavaDeserializer构造方法，根据赋值代码，并且因为我们的ApiException是不知一个构造函数的所以_constructor肯定不会为null,所以</li>
</ul>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error02.png" class="" title="xxx could not be instantiated">

<pre><code>    public JavaDeserializer(Class cl) &#123;
    	this._type = cl;
        this._fieldMap = this.getFieldMap(cl);
        this._readResolve = this.getReadResolve(cl);
        if (this._readResolve != null) &#123;
            this._readResolve.setAccessible(true);
        &#125;

        Constructor[] constructors = cl.getDeclaredConstructors();
        long bestCost = 9223372036854775807L;

        for(int i = 0; i &lt; constructors.length; ++i) &#123;
            Class[] param = constructors[i].getParameterTypes();
            long cost = 0L;

            for(int j = 0; j &lt; param.length; ++j) &#123;
                cost = 4L * cost;
                if (Object.class.equals(param[j])) &#123;
                    ++cost;
                &#125; else if (String.class.equals(param[j])) &#123;
                    cost += 2L;
                &#125; else if (Integer.TYPE.equals(param[j])) &#123;
                    cost += 3L;
                &#125; else if (Long.TYPE.equals(param[j])) &#123;
                    cost += 4L;
                &#125; else if (param[j].isPrimitive()) &#123;
                    cost += 5L;
                &#125; else &#123;
                    cost += 6L;
                &#125;
            &#125;

            if (cost &lt; 0L || cost &gt; 65536L) &#123;
                cost = 65536L;
            &#125;

            cost += (long)param.length &lt;&lt; 48;
            if (cost &lt; bestCost) &#123;
                this._constructor = constructors[i];
                bestCost = cost;
            &#125;
        &#125;

        if (this._constructor != null) &#123;
            this._constructor.setAccessible(true);
            Class[] params = this._constructor.getParameterTypes();
            this._constructorArgs = new Object[params.length];

            for(int i = 0; i &lt; params.length; ++i) &#123;
                this._constructorArgs[i] = getParamArg(params[i]);
            &#125;
        &#125;

    &#125;
</code></pre>
<p>根据下面这段代码，从JavaDeserializer的构造方法中可以看出，这里_constructor会被赋予参数最少的那个构造器，即找到ApiException一个参数的构造方法 public ApiException(Throwable cause)，</p>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error04.png" class="" title="xxx">

<p>有根据下面这段代码，我们知道Throwable不是primitive（原始数据类型），所以_constructorArgs值为null。</p>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error03.png" class="" title="_constructorArgs">

<p>**this._constructor.newInstance(this._constructorArgs)**使用反射调用构造方法时，要求给的参数必须是原始类型或者其包装器</p>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error05.png" class="" title="反射调用构造函数">

<p>但是我们给的参数值都为null，，传入的参数不合法，造成了上面的异常。</p>
<p><strong>解决办法</strong></p>
<p>所以绕了这么大一圈知道了原因，那怎么办呢，最简单的方式ApiException提供一个无参的构造方法。就会这样调用：ca.newInstance(new Object[])，即无参构造则不会再抛异常了。</p>
<img src="/2018/06/26/dubbo%E8%AE%B2%E7%A9%B6(%E4%B8%80)/error06.png" class="" title="反射调用构造函数">

<p><strong>小结</strong></p>
<p>其实这块还会牵扯处很多东西，比如为什么ApiException要那么设计？为什么Java本身的反序列化机制能过而Hession不能过？再比如Constructor.newInstance()和我们经常看到的Class.newInstance()有什么区别？…哎 学海无涯苦作舟</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>esbuild</title>
    <url>/2021/03/19/esbuild/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>esbuild</tag>
      </tags>
  </entry>
  <entry>
    <title>Fusion Design</title>
    <url>/2020/07/08/fusion%20design/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>因为团队要用fusion design，所以按我的习惯我得先知道他是什么、为什么、能做什么，我才好下手。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>先不负责任的下一个结论，fusion design是个撒子？</p>
<p><strong>答案：</strong></p>
<blockquote>
<p><strong>一个平台：</strong> fusion.design</p>
<p><strong>两个工具：</strong></p>
<ol>
<li>开发者工具 Iceworks </li>
<li>设计师工具 FusionCool</li>
</ol>
</blockquote>
<p>可以看作是下图这样纠缠：</p>
<img src="/2020/07/08/fusion%20design/6.png" class="">

<h3 id="Fusion-Design"><a href="#Fusion-Design" class="headerlink" title="Fusion Design"></a>Fusion Design</h3><p>fusion design &#x3D; 一套基础组件库 @alifd&#x2F;next + 主题定制平台 <a href="https://fusion.design/">https://fusion.design</a> +  设计师工具 FusionCool+ 物料中心 。</p>
<p>所以更确切的说 Fusion Design算是一套体系，是一种旨在提升设计与开发之间 UI 构建效率的工作方式 ，<code>我认为理解这点很重要</code>，不然可能咱们用半天还以为他就是另一个库就像我们之前用的antd一样，其实完全不是一回事。</p>
<p><strong>Fusion Design能解决哪些痛点：</strong></p>
<ol>
<li><p>【协作成本】内部（UCD和研发）协作问题，不再需要因为对概念、规范、复用性等问题UCD和研发不断沟通。</p>
</li>
<li><p>用户体验一致性问题 ，不同业务功能或者不同迭代功能，同样功能的交互和组件用户体验不一致。</p>
</li>
<li><p>【时间成本】重复工作问题，比如不断的review还原度不断的修正、UCD每次都需要对高保真进行规范说明以及关键内容的标注。</p>
<p><em>旧模式如下图：</em>红框部分是我们经常重复的内容。</p>
<img src="/2020/07/08/fusion%20design/1.png" class="" title="https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;53117538"></li>
</ol>
<p><strong>Fusion Design提供了哪些能力来解决上诉的痛点：</strong></p>
<ul>
<li><p>物料中心：各种组件、区块、模板（包含官方（Next等）+其它第三方+咱们自研的）</p>
</li>
<li><p>UI的可定制能力，设计师根据物料中心的内容定制UI，还可沉淀设计模板。</p>
</li>
<li><p>研发都能配合前端工具（iceworks等），开发模块模板更高效，沉淀业务模板，后续可直接套用模板不用再开发。</p>
</li>
<li><p>快速定制、切换主题。</p>
<p>应用fusion design之后，产出过程应该就会像下图：</p>
<img src="/2020/07/08/fusion%20design/2.png" class="" title="fusion design应用"></li>
</ul>
<p><strong>@alifd&#x2F;next</strong> </p>
<ul>
<li><strong>Next</strong> 是基于 Alibaba Fusion Design 的设计理念实现的一套骨架DPL(Design Pattern Library)类似于咱们之前使用的antd。配合 fusion.design 使用可以实现换肤的能力。</li>
<li>基于React的组件库。 可以理解**<a href="https://github.com/alibaba-fusion/next">Next</a>**是fusion design的技术实现。</li>
</ul>
<h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>所以综上所述，引人fusion design后，理想状态下设计师和研发产出页面（功能）的过程应该会如下面两张图所示：</p>
<img src="/2020/07/08/fusion%20design/5.png" class="" title="前期产出">

<img src="/2020/07/08/fusion%20design/4.png" class="" title="后期沉淀">



<h3 id="物料中心"><a href="#物料中心" class="headerlink" title="物料中心"></a>物料中心</h3><p>可以理解成一个仓库，类似maven仓库或者npm仓库，里面可包含用开发好的<strong>物料</strong>(区块、模板、组件)，该物料中心与sketch、iceworks是互通的，相互间可上传可下载。</p>
<h3 id="FusionCool"><a href="#FusionCool" class="headerlink" title="FusionCool"></a>FusionCool</h3><p>FusionCool：组件分发工具，主要面向所有设计师。当组件构建者完成组件设计发布组件后，每位设计师手上的Fusion Cool都会“自动”接收到构建者的发布的组件样式，确保无缝衔接组件更新。</p>
<p>FusionCool也可以简单理解为是设计端使用的<strong>sketch</strong> 插件，达到<strong>sketch</strong> 既能设计页面，又能沉淀已经设计完成的模板。即设计师使用的同一套规范的组件，产出的设计稿都是同一套规范。</p>
<img src="/2020/07/08/fusion%20design/3.png" class="">

<h3 id="IceWorks"><a href="#IceWorks" class="headerlink" title="IceWorks"></a>IceWorks</h3><p>飞冰(ICE) 是一套基于 React 的中后台应用解决方案，ICE 包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用，开发者无须关注环境的问题，并且有海量物料可用。目前已经和 Fusion 的物料体系打通，可以轻松使用 Fusion 站点的物料。</p>
<p>Iceworks 是淘宝飞冰团队开发的面向前端开发者的 GUI 工具，开发者无须关注环境的问题，并且有海量物料可用。目前已经和 Fusion 的物料体系打通，可以轻松使用 Fusion 站点的物料。</p>
<p>fusion design的御用开发者工具，基于其开发各种组件丰富fusion design站点的<strong>物料中心</strong>，当然iceworks也能轻松使用 Fusion 站点的物料，两者互通。</p>
<h3 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h3><p>我个人认为fusion design的价值在于提升工作效率，因为它改造了前端（设计师和研发）的工作方式，减少了重复工作的内容，减少了沟通以及甩锅的成本，通过fusion design这个平台，让设计师和研发都能深度参与产品中来且这种参与是互补共赢的，它让设计师和研发之间的一些壁垒或者冲突点慢慢的消失了。</p>
<p><strong>另外</strong></p>
<p>对于角色（设计、研发）来说：可能最大变化就是对于通用性的、沉淀下来的物料，<strong>UCD才是老板</strong>，这块的样式布局等需要UCD统一把关收口，研发只需要<strong>更新包</strong>就行。总体上就是UCD的工作内容会增加但是研发时间会减少，协作时间也会减少，同时体验一致性也能达到要求。我估计能达到这种状态应该就可以要自行车了吧？</p>
<p>但是这玩意都是<strong>线上</strong>的，不知道能不能支持本地搭一套（如果不能搭是不是又不能要自行车了）？</p>
<h4 id="题外篇：iceworks-server"><a href="#题外篇：iceworks-server" class="headerlink" title="题外篇：iceworks server"></a>题外篇：iceworks server</h4><p>如需使用iceworks提供的一些快捷能力，比如新建项目（基于fusion design、react、typescript）、项目管理等。</p>
<p>用于练手刚好。</p>
<h5 id="1-安装iceworks"><a href="#1-安装iceworks" class="headerlink" title="1.安装iceworks"></a>1.安装iceworks</h5><p>npm install iceworks -g –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>每个命令大家都可以玩一玩，我下面只介绍<code>start</code>的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\baymax_projects\fusion-design-one&gt;iceworks -h</span><br><span class="line">Usage: iceworks &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version                           output the version number</span><br><span class="line">  -h, --help                              output usage information</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  start                                   start and open the iceworks</span><br><span class="line">  init [type] [npmName]                   init project/material/component by template</span><br><span class="line">  add [options] [materialType] [npmName]  add block to current directory</span><br><span class="line">  generate                                generate material collection data(material.json)</span><br><span class="line">  sync [options]                          sync materials data to Fusion Material Center</span><br><span class="line">  use &lt;version&gt;                           specify the iceworks-core version</span><br><span class="line">  config [type] [key] [value]             operate iceworks global config</span><br><span class="line"></span><br><span class="line">  Run iceworks &lt;command&gt; --help for detailed usage of given command.</span><br></pre></td></tr></table></figure>



<h5 id="2-启动-安装iceworks-server"><a href="#2-启动-安装iceworks-server" class="headerlink" title="2.启动 安装iceworks-server"></a>2.启动 安装iceworks-server</h5><p><strong>windows:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iceworks  start</span><br></pre></td></tr></table></figure>

<p><strong>linux：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># iceworks start</span><br><span class="line">iceworks # open http://localhost:8000/</span><br></pre></td></tr></table></figure>

<p>3.若提示是否安装iceworks-server 直接Enter 默认是 稍等几分钟 自动启动浏览器</p>
<h4 id="iceworks-server使用方法"><a href="#iceworks-server使用方法" class="headerlink" title="iceworks server使用方法"></a>iceworks server使用方法</h4><p>1.打开项目,(首先你要有项目包)</p>
<img src="/2020/07/08/fusion%20design/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15942030658073.png" class="">

<p>2.安装依赖</p>
<p>如果要切换cnpm源，设置包管理工具cnpm（前提是现状了cnpm），如不需要则跳过此步。</p>
<p><img src="http://p.qlogo.cn/qqmail_head/Q3auHgzwzM71G0g4z5ytHZ3RnWFG6CQBymPLrJfcn3414aSmCt9kxE3rFpGUyE4mkZAq7swa9ddRWBBE9reucepYTnCFraPo/0" alt="img"></p>
<p><img src="http://p.qlogo.cn/qqmail_head/Q3auHgzwzM6v4zGcvurETEGvaibCoKpJiaLYIXnT6IQWUwzHpr64y93qJYK3iapia65fAOSFz92XwKagfibU85Ru1xnrFib2YttvcT/0" alt="img"></p>
<p>3.启动服务</p>
<p>当然你也可以本地运行</p>
<img src="/2020/07/08/fusion%20design/image-20200708181243032.png" class="">

<p>4.当页面变成这样说明已经启动成功:(会自动跳转到项目页面)</p>
<img src="/2020/07/08/fusion%20design/image-20200708181842813.png" class="">

<p>5.打开编辑器</p>
<p><img src="http://p.qlogo.cn/qqmail_head/PiajxSqBRaEJVGxo28SB3YVYmnPVIWRrzicm3k0lSgoDfAdpDEwwfic7xdf2CSLwkN5DhaickyISN8y7dXqyHflWnhxz8HiaR8EvG/0" alt="img"></p>
<img src="/2020/07/08/fusion%20design/image-20200708181919865.png" class="">

<h4 id="感谢："><a href="#感谢：" class="headerlink" title="感谢："></a>感谢：</h4><blockquote><footer><strong>阿里中后台UI解决方案 - Fusion</strong><cite><a href="https://zhuanlan.zhihu.com/p/53117538">zhuanlan.zhihu.com/p/53117538</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>fusion design</tag>
      </tags>
  </entry>
  <entry>
    <title>gatsby</title>
    <url>/2021/03/19/gatsby/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
        <tag>gatsby</tag>
      </tags>
  </entry>
  <entry>
    <title>git submodule</title>
    <url>/2021/08/31/git-submodule/</url>
    <content><![CDATA[<p>git clone -b develop ssh:&#x2F;&#x2F;<a href="mailto:&#103;&#105;&#116;&#64;&#120;&#x78;&#120;&#x2e;&#103;&#105;&#116;">&#103;&#105;&#116;&#64;&#120;&#x78;&#120;&#x2e;&#103;&#105;&#116;</a> 项目名<br>cd 项目目录<br>git submodule update –init –recursive</p>
<p>更新代码</p>
<p>submodule变更了版本:</p>
<p>git pull –recursive</p>
<p>git submodule upadte</p>
<p>submodule没有变更版本：</p>
<p>cd submodule目录<br>git checkout origin&#x2F;develop<br>git pull origin develop</p>
<p><a href="https://zhuanlan.zhihu.com/p/87053283">https://zhuanlan.zhihu.com/p/87053283</a></p>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">https://git-scm.com/book/en/v2/Git-Tools-Submodules</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 分支规范</title>
    <url>/2019/03/15/git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>产线当前在代码库管理遇到了如下挑战：</p>
<ol>
<li>职责权限不明确，关键操作未收口，分支管理效率不理想。</li>
<li>多功能同时开发时，有功能之间互相Block、提测受影响、新分支建立困难的问题。</li>
<li>无法应对后续应对多客户定制化开发场景的需要。</li>
<li>测试团队人力紧张。</li>
</ol>
<p>针对以上问题，本模型在旧模型的基础上进行改造，做出以下改变：</p>
<ol>
<li>分支和tag建立收口到专人负责，不用再互相等待。</li>
<li>多feature并行开发测试，减少开发阶段的耦合。</li>
<li>设立定制化feature机制应对后期多客户的场景。</li>
<li>功能测试收束至develop分支进行。</li>
</ol>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a><strong>实操</strong></h2><p>搬运一下我们团队的分支管理办法，大体的思路还是遵循git flow的规范</p>
<h3 id="develop和release"><a href="#develop和release" class="headerlink" title="develop和release"></a>develop和release</h3><p>当数个feature开发并提测后，进入多feature集成测试阶段。在develop分支进行多feature集成测试，完成后转入实验局测试。完成实验局阶段后，产品团队决定发版，这时从develop拉出release分支并根据版本号命名。此时会做最终的功能集成测试和回归测试，验证功能间是否有冲突导致的BUG和遗漏BUG，测试完成后合并至master和develop分支。</p>
<img src="/2019/03/15/git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/1.png" class="">

<ul>
<li><p>步骤1</p>
<p>当新工程建立时，配置管理员从master分支拉出develop分支，设置保护权限，关闭develop分支所有人员提交代码权限，完成后邮件通知全体研发。</p>
</li>
<li><p>步骤2</p>
<p>当功能提测后，研发经理将feature分支合并至develop分支。若某feature分支未成功提测，则略过该分支。当全部feature分支合并完毕后开放develop权限。</p>
<p>每次测试部署时，由配置管理员建立tag，然后根据tag部署。</p>
</li>
<li><p>步骤3</p>
<p>重复BUG修复过程直至符合发布要求。</p>
</li>
<li><p>步骤4</p>
<p>当多feature集成测试阶段结束，配置管理员邮件通知全员即将锁定的分支，然后设置develop保护权限，建立tag进行实验局部署。</p>
</li>
<li><p>步骤5</p>
<p>实验局阶段将对bug进行整理，非block级bug将在后续feature中进行规划和修改。</p>
<p><strong>注意事项：</strong>block级bug将视紧急程度开放权限给指定人员</p>
</li>
<li><p>步骤6</p>
<p>当产品团队确定发版，配置管理员从develop分支拉出release分支，邮件通知全员。</p>
</li>
<li><p>步骤7</p>
<p>集成测试部署时，配置管理员邮件通知全员即将锁定的分支，然后设置release保护权限，锁定release权限。（设置锁定的目的是防止转测阶段有人提交代码出现BUG，导致tag不可用）</p>
</li>
<li><p>步骤8</p>
<p>配置管理员在release上打测试tag，然后解除锁定，邮件通知全员。</p>
<p>研发下载release代码，准备修改bug。</p>
<p>测试经理基于测试tag，启动集成测试流程。</p>
<p>研发修复BUG并提交至release分支。</p>
<p>步骤7重复多次直到符合发布要求</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>职责</th>
<th>通知机制</th>
</tr>
</thead>
<tbody><tr>
<td>研发经理</td>
<td>feature分支向develop分支合并  release分支向master分支合并  release分支向develop分支合并</td>
<td>feature分支的合并需要通知配置管理和Scrum Master  release分支的合并需要通知配置管理</td>
</tr>
<tr>
<td>配置管理</td>
<td>develop分支的建立  release分支的建立、tag建立、锁定、删除  master分支的tag建立  feature分支的建立、tag建立、锁定、删除</td>
<td>develop分支建立需要邮件通知全体人员  release分支的tag建立需要通知测试，release分支的建立、锁定、解锁需要邮件通知全体人员  master分支的tag建立需要通知负责安装包的研发人员  feature分支的tag建立需要通知测试，  feature分支的建立、锁定、删除需要通知相关研发人员</td>
</tr>
<tr>
<td>研发</td>
<td>开发、bugfix、安装包生成</td>
<td></td>
</tr>
<tr>
<td>测试经理</td>
<td>release分支的测试、部署  feature分支的测试、部署  develop分支的测试、部署</td>
<td>feature分支验收测试和多feature集成测试结果需要邮件通知对应研发和研发经理</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="hotfix分支场景"><a href="#hotfix分支场景" class="headerlink" title="hotfix分支场景"></a>hotfix分支场景</h3><p>hotfix分支用于产品稳定版及现场问题的修正。当一线端反馈了BUG并且判定需要作为hotfix修复时，从master拉出hotfix分支。分支修复完成后，重新合并入master和develop分支。若hotfix可能影响定制化feature的场景，由ScrumMaster判断是否需要进行合入。</p>
<img src="/2019/03/15/git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/2.png" class="">

<ul>
<li><p>步骤1</p>
<p>当master发布完成后，当有现场问题需要修正时，配置管理员从master的发布tag拉hotfix分支，邮件通知全员。</p>
<p> 研发从hotfix分支下载代码，修改缺陷。</p>
<p>研发在实验局（建议）或专用环境验证缺陷是否修改完成。</p>
<p>研发将修改提交，然后推送到hotfix。</p>
<p>研发修改故障单状态，提交测试。</p>
</li>
<li><p>步骤2</p>
<p>在hotfix整体送测日，配置管理员锁定hotfix权限。</p>
<p>配置管理员在hotfix上打转测tag ，邮件通知全员。</p>
<p>测试经理基于转测试tag，启动回归测试流程。</p>
<p>如果回归测试不通过，配置管理员开放hotfix权限，重复步骤2直到回归测试通过。</p>
</li>
<li><p>步骤3</p>
<p>回归测试通过，测试经理确认基于hotfix的哪个tag发布，邮件通知全员。</p>
<p>执行步骤4、5、6，配置管理确定步骤完成后删除分支</p>
</li>
<li><p>步骤4</p>
<p>研发经理基于hotfix的发布tag，向master合并，完成后通知配置管理员。</p>
<p>配置管理员确认后，给master打发布tag，转升级包生成流程。</p>
</li>
<li><p>步骤5</p>
<p>研发经理基于hotfix的发布tag向develop合并，完成后通知配置管理员。</p>
</li>
<li><p>步骤6</p>
<p>配置管理员通知研发判断hotfix是否影响定制化分支，若影响，则通知研发经理基于hotfix的发布tag向定制化feature合并，完成后通知配置管理员和Scrum Master。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>角色</th>
<th>职责</th>
<th>通知机制</th>
</tr>
</thead>
<tbody><tr>
<td>研发经理</td>
<td>hotfix发布tag向develop分支合并  hotfix发布tag向master分支合并  hotfix发布tag向定制化feature分支合并</td>
<td>hotfix tag向develop和master的合并需要通知配置管理  hotfix tag向定制化feature的合并需要通知配置管理和Scrum Master</td>
</tr>
<tr>
<td>配置管理</td>
<td>hotfix分支的建立、锁定、删除  hotfix分支的tag建立   判断hotfix是否向定制化feature合并</td>
<td>hotfix分支的建立、锁定、解锁需要邮件通知全体人员  hotfix分支的tag建立需要通知测试经理  hotfix需要向定制化feature合并需要通知研发经理</td>
</tr>
<tr>
<td>研发</td>
<td>hotfix分支的日常实验局部署和bugfix  升级包生成</td>
<td></td>
</tr>
<tr>
<td>测试经理</td>
<td>hotfix分支的测试、部署  hotfix分支发布</td>
<td>hotfix分支发布需要邮件通知全体人员</td>
</tr>
</tbody></table>
<h3 id="feature分支场景"><a href="#feature分支场景" class="headerlink" title="feature分支场景"></a>feature分支场景</h3><p>feature分支用于进行新功能开发和上个阶段实验局的缺陷修复。产线管理团队需要规划好功能的相关性和相互依赖，避免把相互依赖的功能放到不同的feature中去。在feature规划完成后，需要建立分支，并在feature分支上完成工程开发、提测阶段。提测成功后，feature分支将被合并至develop分支。</p>
<p>多个feature分支将在develop进行合并测试，若测试前有feature不满足提测条件，为了不影响其它feature的发布，可以将这个分支延迟合并。</p>
<p><strong>注意事项</strong>：common包等不参与部署过程的公共模块，在产线管理团队规划时可采用其它的分支管理策略，例如多个虚拟团队公用一个feature分支。</p>
<img src="/2019/03/15/git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/3.png" class="">

<ul>
<li><p>步骤1</p>
<p>当需求确定时，研发经理确定feature规划。feature规划一般根据敏捷小组进行，也会受到功能关联性的影响。feature规划确定后需要邮件通知研发小组和配置管理员。</p>
</li>
<li><p>步骤2</p>
<p>Scrum Master邮件发起feature分支建立申请，然后配置管理员从develop分支拉出feature分支，通知小组成员和研发经理。研发人员开始功能开发。</p>
</li>
<li><p>步骤3</p>
<p>准备提测，配置管理员锁定feature分支，通知小组成员、测试经理和研发经理。研发部署锁定的feature进行提测，不论提测通过或未通过，Scrum Master都解除分支锁定，通知小组成员和研发经理。</p>
</li>
<li><p>步骤4</p>
<p>若提测失败，配置管理员重新打开分支权限。</p>
</li>
<li><p>步骤5</p>
<p>研发继续在feature分支进行bugfix。当bugfix完成后，配置管理员重新锁定分支。</p>
</li>
<li><p>步骤6</p>
<p>提测通过，研发经理merge分支至develop。确定merge成功后，删除feature分支，通知小组成员和配置管理员。</p>
</li>
<li><p>步骤7</p>
<p>当第二个feature或者后续feature需要提测时，需要先从develop反向合并然后进行检查，该步骤是为了防止代码冲突或者功能被覆盖。</p>
</li>
</ul>
<p><strong>注意事项</strong>：若合并分支时发现基础代码有冲突，研发需要给测试团队提供冲突列表，帮助测试团队着重验证冲突功能。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>职责</th>
<th>通知机制</th>
</tr>
</thead>
<tbody><tr>
<td>研发经理</td>
<td>确定feature规划  feature分支向develop分支合并  develop分支向feature分支合并</td>
<td>feature规划需要通知小组成员  feature分支的合并需要通知小组成员和配置管理员</td>
</tr>
<tr>
<td>配置管理员</td>
<td>feature分支的建立、tag建立、锁定、删除  develop的tag建立</td>
<td>feature分支的建立、tag建立、锁定、删除需要通知小组成员和研发经理</td>
</tr>
<tr>
<td>研发</td>
<td>feature分支的日常开发、部署和bugfix  develop分支的实验局部署、多feature集成测试阶段bug修复</td>
<td></td>
</tr>
<tr>
<td>Scrum Master</td>
<td>发起feature建立申请</td>
<td>feature分支建立向配置管理员申请</td>
</tr>
</tbody></table>
<h3 id="定制化feature分支场景"><a href="#定制化feature分支场景" class="headerlink" title="定制化feature分支场景"></a>定制化feature分支场景</h3><p>当存在定制化需求时，需要建立定制化feature分支。该分支用于定制化客户的功能开发、测试、打包等。在定制化开发过程中，若有影响该分支的release和hotfix出现，则需要合入定制化feature分支。</p>
<img src="/2019/03/15/git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/4.png" class="">

<ul>
<li><p>步骤1</p>
<p>定制化需求确定，配置管理员决定从哪个tag创建定制化feature分支。</p>
</li>
<li><p>步骤2</p>
<p>配置管理员从develop分支拉出定制化feature分支，通知相关小组成员和研发经理。</p>
</li>
<li><p>步骤3</p>
<p>当有release分支发布时，配置管理员决定是否合并至定制化feature分支，然后通知研发经理。</p>
<p>研发经理从release分支合并代码至定制化feature分支。</p>
</li>
<li><p>步骤4</p>
<p>当有hotfix分支发布时，配置管理员决定是否合并至定制化feature分支，然后通知研发经理。</p>
<p>研发经理从hotfix分支发布tag合并代码至定制化feature分支。</p>
</li>
<li><p>步骤5</p>
<p>准备提测，配置管理员锁定定制化feature分支，通知小组成员和测试经理。</p>
</li>
<li><p>步骤6</p>
<p>研发部署锁定的定制化feature进行提测，提测未通过，配置管理员解除分支锁定，通知小组成员。</p>
</li>
<li><p>步骤7</p>
<p>研发继续在定制化feature分支进行bugfix。当bugfix完成后，配置管理员重新锁定分支并且提测，通知小组成员、测试经理。</p>
</li>
<li><p>步骤6</p>
<p>提测通过，配置管理员对定制化feature分支建立tag，转安装包流程。</p>
</li>
</ul>
<p>​		</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>职责</th>
<th>通知机制</th>
</tr>
</thead>
<tbody><tr>
<td>研发经理</td>
<td>release分支向定制化feature分支合并  hotfix发布tag向定制化feature分支合并</td>
<td>定制化feature分支合并需要通知配置管理员</td>
</tr>
<tr>
<td>配置管理员</td>
<td>定制化feature分支的建立、锁定、解锁  定制化feature分支的tag建立</td>
<td>定制化feature分支的建立、锁定、解锁需要通知小组成员和研发经理</td>
</tr>
<tr>
<td>研发</td>
<td>定制化feature分支的日常开发、部署和bugfix</td>
<td></td>
</tr>
<tr>
<td>测试</td>
<td>定制化feature分支的日常测试活动</td>
<td></td>
</tr>
</tbody></table>
<h4 id="感谢："><a href="#感谢：" class="headerlink" title="感谢："></a>感谢：</h4><blockquote><footer><strong>敏捷的水</strong><cite><a href="https://www.cnblogs.com/cnblogsfans/p/5075073.html">Git 在团队中的最佳实践--如何正确使用Git Flow deep-dive</a></cite></footer></blockquote>

<blockquote><footer><strong>Vincent Driessen</strong><cite><a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git实践</title>
    <url>/2019/08/20/git%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>据说再2016年我就开始接触git，当时还用台式机、笔记本作为两个用户进行git的一些实践和原理的了解，但是正儿八经在项目中用git还是现在，经过一年多的实践呢，入了一些坑所以觉得是时候展现真正的技术了，简单积累一下我比较常用的。</p>
<img src="/2019/08/20/git%E5%AE%9E%E8%B7%B5/boat-164989.jpg" class="" title="Image by Pixabay License from Pixabay">

<p>** git提交规范 **</p>
<p>这块是很重要很重要的，在代码评审、问题追溯、代码回滚、代码培训等的时候都需要用到这个东西，但是团队内暂时还没有对此做硬性要求。不过我个人是一直比较注重提交的内容，因为以前吃过亏，没有友好的commit内容某些场景下很难定位。虽然我比较注重但是还是比较游击队的打法，最近看到了个东西叫commitizen，它可以配置一套标准的提交规范，所以准备用起来。</p>
<p><strong>配置commitizen</strong></p>
<p><a href="https://juejin.im/post/5cbd1fdf5188250a546f565f" title="安装链接">https://juejin.im/post/5cbd1fdf5188250a546f565f</a></p>
<ul>
<li><p>可借助工具使提交更加规范：安装cz-conventional-changelog，即使用第三方的提交模板，这儿表示用的AngularJS的提交模板</p>
</li>
<li><p>用husky配合git hooks 进行预检查</p>
</li>
</ul>
<p>package.json</p>
<pre><code>&#123;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">  &quot;hooks&quot;: &#123;</span><br><span class="line">   &quot;commit-msg&quot;: &quot;(echo HUSKY_GIT_PARAMS: %HUSKY_GIT_PARAMS%) &amp;&amp; commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">  &quot;commitizen&quot;: &#123;</span><br><span class="line">   &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p><strong>git 储藏</strong></p>
<pre><code>常用git stash命令：

（1）git stash save &quot;save message&quot;  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。

（2）git stash list  ：查看stash了哪些存储

（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;$num&#125;，比如第二个 git stash show stash@&#123;1&#125;

（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;$num&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p

（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;$num&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; 

（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;$num&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;

（7）git stash drop stash@&#123;$num&#125; ：丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储

（8）git stash clear ：删除所有缓存的stash
</code></pre>
<p><strong>git 回滚</strong></p>
<pre><code>//回滚上一次提交
git reset HEAD~ 
// 修改最近一次提交的备注
git commit --amend
// 修改某一次提交的备注，最后的数字2指的是显示到倒数第几次
git rebase -i HEAD~2
</code></pre>
<p><strong>git 合并</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</span><br><span class="line">  git fetch</span><br><span class="line">  //是将远程主机的最新内容拉到本地并合并</span><br><span class="line">  git pull</span><br></pre></td></tr></table></figure>

<p><strong>git 切换分支</strong></p>
<pre><code>//对于已经拉取到本地的分支之间的切换
git checkout 分支名
//对于还没有拉取到本地的分支
git checkout -b remote分支名 本地分支名
</code></pre>
<p> <strong>git 撤销merge</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//经常在切换分支时，一不小心就merge错了分支或者合并时遇到冲突想取消操作，这命令就好用了</span><br><span class="line">git merge --abort</span><br><span class="line"></span><br><span class="line">//撤销指定的merge</span><br><span class="line">1.找到最后一次提交到master分支的版本号，即【merge前的版本号】</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">2.回退到某个版本号</span><br><span class="line">git reset --hard 【merge前的版本号】</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>git 撤销</strong></p>
<img src="/2019/08/20/git%E5%AE%9E%E8%B7%B5/reset.jpg" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft: 将分支回退到指定提交，工作区维持现状不变,暂存区会在现有基础上增加该commit之后的提交。</span><br><span class="line">git reset --mixed: （默认操作）将分支回退到指定提交，暂存区也被同步为该指定提交，工作区保持不变。</span><br><span class="line">git reset --hard: 将分支回退到指定分支，暂存区和工作区都会被同步为该指定的提交。</span><br><span class="line">git reset --hard 可以回退到某个提交</span><br><span class="line">git revert可以撤销某个提交，撤销会产生一个新的提交</span><br></pre></td></tr></table></figure>

<p> <strong>回退到某个版本并应用指定的几次提交</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切换到目标分支上， 假如当前状态为新合并进了一条commit，只需执行 git reset --hard HEAD~1即可回退到合并前。</span><br><span class="line">或者回退到任何你想要的状态中 git reset --hard commitId, 其中commitId为你想要处于的版本hash code。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">git reset --hard 1d7444 #回退到某个版本</span><br><span class="line">git cherry-pick 626335 #将某次commit的更改应用到当前版本 </span><br><span class="line">git push origin HEAD --force  #强制提交</span><br></pre></td></tr></table></figure>



<p><strong>根据关键字搜索提交记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --all-match --grep=登录</span><br><span class="line"></span><br><span class="line">commit 9f3e61ad63626c3e2e7541430d4af9693e3357ccAuthor: caofu &lt;[caofu@ruijie.com.cn](mailto:caofu@ruijie.com.cn)&gt;Date:  Fri Dec 7 13:09:55 2018 +0800  完成单点登录xxxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看某次提交的内容</span><br><span class="line">git show 9f3e61ad63626c3e2e7541430d4af9693e3357cc</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 配置</title>
    <url>/2022/07/13/hexo-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>hexo 搞坏了几次了，记录一下咋修复的。</p>
<p><a href="https://theme-next.js.org/docs/getting-started/configuration.html">https://theme-next.js.org/docs/getting-started/configuration.html</a></p>
<p><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/base/%E8%8F%9C%E5%8D%95%E6%A0%8F/">https://hexo-next.readthedocs.io/zh_CN/latest/next/base/%E8%8F%9C%E5%8D%95%E6%A0%8F/</a></p>
<p><a href="https://www.lvxuefei.top/%E5%88%A9%E7%94%A8Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/">https://www.lvxuefei.top/%E5%88%A9%E7%94%A8Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/</a></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器是怎样工作的</title>
    <url>/2018/07/10/how-brower-work/</url>
    <content><![CDATA[<p>干了一段时间前端，老想着什么时候能搞明白点什么。要搞明白点前端的东西，前端的技术五花八门的，顾不过来，既然顾不过来那就别顾了，找到他们的基石就对了。不管技术怎么变，最终都得在浏览器解析。所以我想着先搞清楚浏览器是咋工作的，可能会让我对前端没那么惊慌。</p>
<p>一google找到了这个姐妹-<strong>Tali Garsiel</strong>，看到有好几篇文章都是基于她的文章来的。这姐姐人干了N多年的前端开发，看了各个开源浏览器的源码，用尽洪荒之力总结出了这篇文档<a href="http://www.taligarsiel.com/Projects/howbrowserswork1.htm" title="how brower work">http://www.taligarsiel.com/Projects/howbrowserswork1.htm</a>。那我也厚颜无耻的用她写的文章作为了解浏览器的入门。虽然文章的年代比较老，但是浏览器的核心概念是不变的，这点从近年来大家的解读可以看出来。</p>
<p>文章主要是针对开源或者部分开源的Chrome、Firefox、Safari。文章有很多章节，我就挑我喜欢的来说了。</p>
<p><strong>The browser’s main functionality</strong></p>
<p>这个章节我了解到一个很有意思的事情就是浏览器的界面，其实是没有任何规范或者说标准的，几大浏览器厂商你抄我我抄你最后大家就基本上长得一样了。比如都有地址栏，都有工具栏等等。</p>
<p>所以浏览器基本上都有以下几大功能：</p>
<ul>
<li>用来输入 URI 的地址栏</li>
<li>前进和后退按钮</li>
<li>书签设置选项</li>
<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>
<li>用于返回主页的主页按钮</li>
</ul>
<p><strong>The browser’s high level structure</strong></p>
<p>这章节讲的是浏览器的主要结构。</p>
<ul>
<li><p>用户界面 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</p>
</li>
<li><p>浏览器引擎 在用户界面和呈现引擎之间传送指令。</p>
</li>
<li><p>呈现引擎 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</p>
</li>
<li><p>网络 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</p>
</li>
<li><p>用户界面后端 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</p>
</li>
<li><p>JavaScript 解释器。用于解析和执行 JavaScript 代码。</p>
</li>
<li><p>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</p>
</li>
</ul>
<img src="/2018/07/10/how-brower-work/structure.png" class="" title="来源于https:&#x2F;&#x2F;codeburst.io&#x2F;how-browsers-work-6350a4234634">

<p>这几个组件中，最主要的或者说前端开发最应该关注的就是呈现引擎了，你想嘛，你做的everything最终不就是为了让浏览器把你想要的效果呈现给用户么，呈现引擎就是干这个事的。</p>
<p>这个地方可能需要注意一下，可能会有疑惑为什么javascript单独拎出来了，请注意啊，javascript它最初的作用就是操作dom，从而实现一些动态效果而发明的。所以它本身是不能直接作为呈现给用户的，需要一个编译执行的过程，所以不属于呈现引擎的组成部分。当前现在javascript不仅用于前端开发了，后端也常常作为某种函数脚本的存在，比如java8以后的MapReduce可运行对应格式的js脚本、java的mango客户端也能用js脚本…</p>
<p>呈现引擎先主要有两种一种是Firefox 的<strong>Gecko</strong>，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 <strong>WebKit</strong>。不管是哪一种引擎都是为了让浏览器能更好更多的支持内容的呈现。虽然现在浏览器能呈现的内容远远不止HTML+CSS，但是主要的还是对html和css进行解析呈现。</p>
<p>如图所示，呈现引擎一开始通过网络组件请求需要呈现的文档内容，拿到内容后开始解析，首先解析html，把html分割成大量的标记（标签），进而把每个标记转化为一颗dom tree上的节点，同时解析css样式，并和dom tree转换为另一种树：Render Tree（该树包含有多个视觉属性的矩形，并存在排列顺序）。</p>
<p>接着根据<strong>Render Tree</strong>进行布局，因为呈现树上包含有视觉属性以及顺序，所以可以为呈现树里各个节点（矩形）分配坐标。</p>
<p>分配好坐标以后由另一个组件<strong>用户界面后端</strong>进行树的绘制。最终呈现给用户。Gecko，WebKit略有不同但是总体的流程是一样的。</p>
<img src="/2018/07/10/how-brower-work/parser.png" class="" title="来源于我">

<p>整个过程是渐进的过程，浏览器不会等着所有html文档都解析完再呈现，而是解析过程中就开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>
<blockquote>
<p>专业解释：HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree（呈现树），最终用来进行绘图。Render Tree 中的元素与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。</p>
</blockquote>
<img src="/2018/07/10/how-brower-work/attachment.png" class="" title="Attachment(对上眼) | 来源于我和网络">


<p>这儿需要注意的是，html的解析是正向的从上到下（从左到右）的（从根节点开始），而css是逆向的从下到上（从右到左）的。为什么html是从上到下的，这个很好理解，你想想html解析后是一棵树，你想想树的构成肯定是先有个主干然后再有分叉，这样才是一个整体，不然不就是一盘散货么。那css为什么就一定要从下到上呢，通过下面的叙述你会知道如果css也采取从上到下的顺序，那dom tree和style rules两个需要对上眼的消耗是很大的（因为通常dom节点多，css样式也多）,从概率上来讲逆向匹配的概率是远远高于正向匹配的概率的。</p>
<blockquote>
<p>专业解释：在建立 Render Tree 时， DOM Tree 中的元素需要根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>
</blockquote>
<blockquote>
<p>如果<strong>正向解析</strong>，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。</p>
<p><strong>逆向匹配</strong>则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。其实更深入的理解需要深入了解Html Parser和css Parser的工作过程。</p>
</blockquote>
<img src="/2018/07/10/how-brower-work/render-engine.png" class="" title="来源于https:&#x2F;&#x2F;codeburst.io&#x2F;how-browsers-work-6350a4234634">



<p>关键字解释：</p>
<p><strong>style rules</strong></p>
<img src="/2018/07/10/how-brower-work/style-rule.png" class="" title="来源于https:&#x2F;&#x2F;blog.csdn.net&#x2F;li_jiayu&#x2F;article&#x2F;details&#x2F;5123727">



<p>源引：</p>
<blockquote><footer><strong>By Tali Garsiel and Paul Irish</strong><cite><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browsers_we_will_talk_about">浏览器的工作原理：新式网络浏览器幕后揭秘</a></cite></footer></blockquote>

<blockquote><footer><strong>Yongsheng</strong><cite><a href="https://blog.csdn.net/milado_nju/article/details/7685517">理解WebKit和Chromium: WebKit的CSS实现</a></cite></footer></blockquote>

<blockquote><footer><strong>liumf2005</strong><cite><a href="https://blog.csdn.net/liumf2005/article/details/8663887">Webkit CSS引擎分析</a></cite></footer></blockquote>

<blockquote><footer><strong>奇舞周刊mp</strong><cite><a href="https://blog.csdn.net/liumf2005/article/details/8663887">几张图带你揭秘一个超快的 CSS 引擎</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Brower</tag>
      </tags>
  </entry>
  <entry>
    <title>js工具库</title>
    <url>/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近整理产品中积累下来的工具类，因为要用新框架了要对之前的代码进行移植。当然咱是个追求完美的人，实在是团队小伙伴们一路疯狂操作下来，工具类是茫茫多啊，基本上想要维护是注定两行泪，所以咱们借着这次机会把工具类好好整理一下。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="诉求："><a href="#诉求：" class="headerlink" title="诉求："></a>诉求：</h4><ol>
<li>可维护性强。</li>
<li>能进行包管理。</li>
<li>每个方法有详细的说明，且能友好的查看。</li>
</ol>
<p><strong>具象化要求</strong></p>
<ul>
<li>工具方法需要分门别类，不能一个文件一把梭，一定要控制代码量，不能让人一打开文件，心里就是wc。</li>
<li>更新（删除、新增、修改）某个工具方法时不影响其它方法的使用，达到我改我的，你别瞪我的效果。</li>
<li>不能发生函数名、变量名冲突。	</li>
<li>每个方法的注释遵循统一规范，根据统一规范可生产类似swagger那样的api文档（有张好的面皮大家爱看也耐看，不用不断打扰写方法的人）。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>秉着能抄袭就不自己动手的精神，看了很多star上千的工具库，总结了一下方式方法。</p>
<ul>
<li>基本上大家都采用的方式是一个方法一个文件，这一个文件<strong>暴露</strong>出来的就一个方法也只有一个方法，如果该方法需求其他辅助方法，直接通过import引用，而不直接写到该文件中，整个文件特别整洁，如果方法比较复杂则会建立一个文件夹从而存放辅助方法的文件，辅助方法的文件里也只有一个方法。虽然看上去可能这样文件有点多了，但是确实很清晰很整洁，对于维护来说很友好。<em>所以就用这种方式了</em>。</li>
<li>看了下生产api的几种库，比如jsdoc、ddoc等，大体是jsdoc还是多一些，用起来也挺简单，<em>所以就选jsdoc了</em>。</li>
</ul>
<h5 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h5><p>一个方法一个文件</p>
<img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/code.png" class="">

<h5 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h5><img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/rollup.jpg" class="">

<p>打包工具用rollup，以为是工具库所以用更简单的rollup。</p>
<ul>
<li>自动 Tree-shaking(Tree-shaking, 也被称为 “live code inclusion,” 它是清除实际上并没有在给定项目中使用的代码的过程，但是它可以更加高效。)</li>
<li>打包速度快</li>
<li>配置简单</li>
</ul>
<h5 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h5><p> jest开箱即用挺好，另外我们多用react，jest是Facebook出的，与react具有天然亲和力。</p>
<img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/jest.png" class="">

<h5 id="Api-Doc"><a href="#Api-Doc" class="headerlink" title="Api Doc"></a>Api Doc</h5><p>选择了jsdoc，使用简单且较普遍。</p>
<img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/jsdoc-500.jpg" class="">



<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h5><img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/dir.png" class="">

<h4 id="关键手法"><a href="#关键手法" class="headerlink" title="关键手法"></a><strong>关键手法</strong></h4><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a><strong>编码</strong></h5><img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/code1.png" class="">

<p>进行编码后记得在<code>index.js</code>处暴露方法。</p>
<h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h5><img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/jest2.png" class="">

<img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/jest1.png" class="">

<p>单元测试时，如果想打断点，记得修改上图中的配置后重新生成库。</p>
<h5 id="dist说明"><a href="#dist说明" class="headerlink" title="dist说明"></a><strong>dist说明</strong></h5><img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/dist.png" class="">

<h5 id="打包"><a href="#打包" class="headerlink" title="打包"></a><strong>打包</strong></h5><p>如下图：</p>
<ul>
<li>每次修改库时，记得改<code>3</code>处的版本号，以及<code>1</code>处的CHANGELOG对本次修改进行一个简要的说明。</li>
<li><code>2</code>所示部分根据不同时期的需求可对应进行更改，从而改变打包的内容。</li>
<li>完事之后直接npm publish，如果需要关联到fusion design 则直接iceworks sync就行。</li>
</ul>
<img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/package.png" class="">

<h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h5><img src="/2020/07/11/js%E5%B7%A5%E5%85%B7%E5%BA%93/use.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i @riil-frontend/utils</span><br><span class="line"></span><br><span class="line">import &#123; arrayToTree,UnitFormat,Units,getNumberLength &#125; from &#x27;@riil-frontend/utils&#x27;;</span><br></pre></td></tr></table></figure>



<h5 id="重复提交"><a href="#重复提交" class="headerlink" title="重复提交"></a>重复提交</h5><p>加节流防止重复提交</p>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5">防抖和节流</a></p>
<p><a href="https://juejin.im/post/6844904004850286605">https://juejin.im/post/6844904004850286605</a></p>
<p><a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a></p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>如果本身已经引入了第三方得工具库，比如lodash、underscore等，先看看它们得API看是否有现成得，如果没有再自己整一个，不然重复造轮子没多大意思，更何况有可能你造的轮子有可能是扁的…</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>工具库</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s debug</title>
    <url>/2022/09/26/k8s%20debug/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p> 最近主要工作是现场支持，所以经常会用到k8s的命令等工具用于现场问题的排查，<br> 遂做个记录。</p>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/_print/">https://kubernetes.io/zh-cn/docs/tasks/debug/_print/</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-docker</title>
    <url>/2020/11/21/nginx-docker/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于事业部专门成立团队做部署平台，由于各种因素迟迟没有上线，以前的Jenkins也不能用了，但是前后端需要有环境进行联调，后端还好说每个模块本地起个服务就行，前端就尴尬了本地起服务限制太多，所以需要想办法搞个环境，遂想着悄悄咪咪（深藏功与名…）搞了个环境让大家能先跑起来不至于耽误工期。</p>
<p>满足以下要求：</p>
<ol>
<li>前端更新简单</li>
<li>无脑一条命令搞定start\stop\restart</li>
<li>于生成环境尽量贴合</li>
</ol>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>因为生成环境是基于docker做部署，所以先弄个nginx的镜像。nginx的镜像茫茫多，不过大体都很全面，我觉得太重，所以就弄了个最简单的。</p>
<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">my-nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">new-monitor-nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">&quot;journald&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/xxx/mount/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/xxx/mount/html:/etc/nginx/html</span></span><br><span class="line"> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">core:</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用官方的nginx镜像</span></span><br><span class="line">FROM nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ENTRYPOINT 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，用于传参。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eg:docker run  nginx:one -c /etc/nginx/new.conf,容器内会运行nginx -c /etc/nginx/new.conf</span></span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">COPY 复制，从上下文目录中复制文件或者目录到容器里指定路径。</span></span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">COPY html /etc/nginx/html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RUN，在 docker build时作用</span></span><br><span class="line">RUN rm /etc/nginx/nginx.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">EXPOSE 声明端口，镜像服务的守护端口，以方便配置映射。</span></span><br><span class="line">EXPOSE 8088</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VOLUME 用于挂载数据卷</span></span><br><span class="line">VOLUME /var/log/nginx/log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">CMD 类似于 RUN 指令，在docker run 时运行。</span></span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="构建、启动容器"><a href="#构建、启动容器" class="headerlink" title="构建、启动容器"></a>构建、启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t xxx</span><br><span class="line">docker-compose down</span><br><span class="line">sleep 10</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>后续直接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart 容器名</span><br></pre></td></tr></table></figure>



<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>其实最终我又把docker干掉了….因为有同事悄悄咪咪手动装了nginx，优化了一下把nginx挂到了系统服务上，同样的也是直接systemctl xxx就行了。</p>
<p>反正结果是好的，结合alibaba toolkit也是玩的飞快了。</p>
<p>干研发的不就得折腾吗，对吧。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nodeJs 部署</title>
    <url>/2020/10/29/nodeJs-%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近新产品线，因为架构调整，增加了一个node应用，关于node混淆部署了解了一下，保护自主知识产权嘛。</p>
<p>在这儿简单做个记录。</p>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p><a href="https://sailsjs.com/">https://sailsjs.com/</a></p>
<p>安装 forever：sudo npm install -g forever<br>更多关于 forever 的资讯：<a href="https://github.com/nodejitsu/forever">https://github.com/nodejitsu/forever</a><br>或安装 PM2：sudo npm install pm2 -g –unsafe-perm<br>更多关于 PM2 的资讯：<a href="https://github.com/Unitech/pm2">https://github.com/Unitech/pm2</a></p>
<p><a href="https://github.com/Unitech/pm2">https://github.com/Unitech/pm2</a></p>
<p><a href="https://github.com/vercel/ncc">https://github.com/vercel/ncc</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>npm版本锁定</title>
    <url>/2021/06/08/npm%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>源起于同事找我帮忙排查一个认为诡异的问题。</p>
<p>同样的代码，同样的package.json本地和流水线部署效果不一样。问我可能是什么原因，我当时想到的可能就两种情况：</p>
<ol>
<li>依赖包的版本不一样</li>
<li>流水线本身存在问题，比如没有拉到最新的代码？</li>
</ol>
<p>我简单提供用排除法的思路让她走了一遍，排除了不是最新代码的问题，然后让其对比了一下pacage-lock.json文件，的确发现了依赖包的版本变了，当手动在package.json锁死了本地使用的版本号之后，再执行部署则没有问题。</p>
<p>所以最终问题出在package-lock.json上，那为什么package-lock.json每次跑流水线的时候都会变化呢，是因为流水线脚本里部署前端时脚本里会有：</p>
<blockquote>
<p>1.npm clean </p>
<p>2.rm- rf node_modules  </p>
<p>3.npm i …等步骤</p>
</blockquote>
<p>所以导致每次会更新package-lock.json，那我们提交的package-lock.json就失去了它的价值，即可能每次CI都会有不同版本的包依赖。</p>
<p>经过这次的排查，遂记录一下锁包的个人理解。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h4><p>npm 关于<a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-lock-json/">package-lock.json</a>的解释说的挺清楚了。主要作用锁定（描述）包依赖关系及其子依赖项。保证对其他开发人员或其他环境安装包的依赖关系一致。</p>
<p>如图：eslint-plugin-react依赖树</p>
<img src="/2021/06/08/npm%E7%89%88%E6%9C%AC/b.png" class="">

<blockquote>
<p>修改node_modules或package.json将自动生成package-lock.json。 它描述了包版本的<strong>依赖树</strong>，使得后续可以保证无论在哪儿安装能够生成相同的依赖树（也就是相同的包版本），而不管中间依赖性更新如何。</p>
<p>每当我们运行更改依赖项的NPM命令时，如npm i <package>或npm uninstall <package>或npm i 等，都将更新包锁定即更新package-lock.json文件。</p>
<p>所以每次提交时必须把package-lock.json也提交到git。</p>
<p>执行npm i 时会读取根据package.json创建的依赖项列表，并使用package-lock.json来通知哪些版本的这些依赖项需要安装。 如果依赖项不在package-lock.json中，它将通过npm i 添加。</p>
</blockquote>
<p>根据上面总结的信息，我理解解决上述问题的其中一个方案就是每次CI的时候只需要拉代码之后再<strong>npm i</strong> 即可，从而保持依赖一致。</p>
<h4 id="npm-ci"><a href="#npm-ci" class="headerlink" title="npm ci"></a>npm ci</h4><p>在深入了解package-lock.json的过程中，<strong>npm ci</strong>进入了我的视线，详见<a href="https://docs.npmjs.com/cli/v7/commands/npm-ci">npm ci</a>。</p>
<p><strong>npm ci</strong>（ci：持续集成）直接从package-lock.json安装依赖关系，并使用package.json验证是否存在不匹配的版本。 如果缺少任何依赖项或具有不兼容的版本，则会抛出错误。 </p>
<p>因为npm ci是基于package-lock.json进行安装，所以就体现了该命令在包一致性上的作用，在需要重复构建、持续集成等场景下好用。</p>
<img src="/2021/06/08/npm%E7%89%88%E6%9C%AC/a.png" class="">

<h6 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h6><blockquote>
<p>必须有package-lock.json文件，即项目第一次初始安装时不能用npm ci，这也说明了为什么上面章节谈到package-lock.json也需要提交到git，这也是原因之一。</p>
</blockquote>
<p>所以另一个方案就是每次CI的时候只需要拉代码之后再<strong>npm ci</strong> 即可，也可保持依赖一致（前提是package.json、package-lock.json每次都进行了同步提交）。</p>
<h4 id="npm-i-vs-npm-ci"><a href="#npm-i-vs-npm-ci" class="headerlink" title="npm i vs npm ci"></a>npm i vs npm ci</h4><ol>
<li>npm ci不会更新package-lock.json和package.json，即npm ci 不能更新依赖。</li>
<li>npm ci必须基于package-lock.json。</li>
<li>一般情况下npm ci安装速度会更快。npm ci时如果存在node_modules则会先删除node_modules。</li>
<li>初始安装以及更新依赖时，只能使用npm i。</li>
</ol>
<h4 id="另一个问题：咋个解决package-lock-json冲突"><a href="#另一个问题：咋个解决package-lock-json冲突" class="headerlink" title="另一个问题：咋个解决package-lock.json冲突"></a>另一个问题：咋个解决package-lock.json冲突</h4><p>这是一个延申出来的问题，因为需要提交package-lock.json，由于一些原因就可能出现冲突的情况，那咋解决呢？</p>
<ol>
<li>最好别上来就先删除package-lock.json，人是自动生成的没必要跟它较劲。从基线上拉一个package-lock.json文件下来。</li>
<li>处理package.json的冲突。</li>
<li>执行npm i。</li>
</ol>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><blockquote><footer><strong>Solving conflicts in package-lock.json</strong><cite><a href="https://tkdodo.eu/blog/solving-conflicts-in-package-lock-json">tkdodo.eu/blog/solving-conflicts-in-package-lock-json</a></cite></footer></blockquote>

<blockquote><footer><strong>difference-between-npm-install-and-npm-ci</strong><cite><a href="https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci">stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci</a></cite></footer></blockquote>



<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>page-lifecycle-api</title>
    <url>/2021/06/21/page-lifecycle-api/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近又把前端监控的兴趣提了起来，学习过程中了解到了google的page-lifecycle-api，特此做个记录撒。</p>
<p><a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api">https://developers.google.com/web/updates/2018/07/page-lifecycle-api</a></p>
<p><a href="https://github.com/GoogleChromeLabs/page-lifecycle">https://github.com/GoogleChromeLabs/page-lifecycle</a></p>
<p><a href="https://mp.weixin.qq.com/s/sbmUPOQ8a5ffFPEuMzY79w">https://mp.weixin.qq.com/s/sbmUPOQ8a5ffFPEuMzY79w</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm</title>
    <url>/2021/01/13/pnpm/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>因为最近遇到一个包多版本依赖的问题，遂研究研究npm包管理…</p>
<p>结果发现了这个宝藏**<a href="https://github.com/pnpm">pnpm</a>**</p>
<p><a href="https://zhuanlan.zhihu.com/p/137535779">https://zhuanlan.zhihu.com/p/137535779</a></p>
<h3 id="PNPM"><a href="#PNPM" class="headerlink" title="PNPM"></a>PNPM</h3><p>pnpm使用内容可寻址文件系统将磁盘上所有模块目录中的所有文件存储在磁盘上。 </p>
<p> 使用pnpm，lodash将存储在可寻址内容的存储中，因此：</p>
<p>如果您依赖lodash的不同版本，则仅将不同的文件添加到存储中。 如果lodash有100个文件，而新版本仅对其中一个文件进行了更改，则pnpm update将仅向存储添加1个新文件。</p>
<p>所有文件都保存在磁盘上的单个位置。 安装软件包时，它们的文件从该单个位置链接，不占用额外的磁盘空间。 使用硬链接或ref链接（写时复制）执行链接。</p>
<p>结果，您在磁盘上节省了数GB的空间，并且安装速度大大提高了！ 如果您想了解有关pnpm创建的唯一node_modules结构以及为什么它可以在Node.js生态系统中正常工作的更多详细信息，请阅读这篇小文章：平坦的node_modules不是唯一的方法。</p>
<img src="/2021/01/13/pnpm/a.png" class="">

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL(1)</title>
    <url>/2019/11/29/postgresql(1)/</url>
    <content><![CDATA[<img src="/2019/11/29/postgresql(1)/1.jpg" class="" title="Photo by fabio on Unsplash">

<p>最近产品提了一个需求，要做菜单优化。</p>
<p>菜单优化：</p>
<ol>
<li>重写菜单数据初始化sql脚本，数据结构两层变为三层</li>
<li>权限数据调整</li>
<li>兼容原有菜单权限数据</li>
</ol>
<p>这里面第三点是最麻烦的，兼容原有的菜单数据，我给需求说了两个方案。</p>
<p>PlanA：从时间方面（因为是个小迭代，整个迭代的功能只有一周时间开发）考虑管理员菜单权限保留，其它普通角色菜单权限一律置空，需求也接受（因为客户现场大多数情况都是用管理员账号）。</p>
<p>PlanB：保留原有数据，但是需要1-2天预研一下升级方案是否可行，我提出的方案是直接用sql脚本做，需求也认可，PlanA为兜底方案。</p>
<p>我就提个解决方案，结果这事最后让我支援一下给做了…，所以在这简单记录一下过程产物。</p>
<h3 id="PLV8"><a href="#PLV8" class="headerlink" title="PLV8"></a>PLV8</h3><p>简单地说就算PostgreSQL里加个扩展，这个扩展就是V8引擎，是的，你理解的没错，就是Google开源的JavaScript引擎，有了这个扩展那就能在sql里写js代码了，这对于在脚本里写逻辑那可是爽歪歪了。</p>
<p>安装过程我就不多说了，网上有很多，大体流程就是</p>
<ol>
<li>从GitHub wget 下来</li>
<li>make install</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加扩展</span><br><span class="line">CREATE EXTENSION plv8;</span><br><span class="line"></span><br><span class="line">#验证plv8的版本，出来版本号就证明装上了</span><br><span class="line">SELECT plv8_version();</span><br></pre></td></tr></table></figure>



<p>然后你就可以写JS代码了，ES6、coffeeScript等都可以，只要最终是v8能解析的就成。</p>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>好现在开始写了，一开始不太了解，打算用存储过程做，但是后来老前辈提醒我，我这个是升级脚本，只需要执行一遍就成，所以没必要做存储过程，最后还得删掉，因为留着没意义。</p>
<p>然后建议我用DO $$的写法,此方式执行完不会留下其它痕迹就跟执行一条长sql一样，贴个代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DO</span><br><span class="line">$$</span><br><span class="line">plv8.elog(INFO, &#x27;------------------------------------update user menus start------------------------------------&#x27;);</span><br><span class="line">buildTree = function(list) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let temp = &#123;&#125;;</span><br><span class="line">    let tree = &#123;&#125;;</span><br><span class="line">    for (let menu of list) &#123;</span><br><span class="line">      temp[menu.id] = menu;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i in temp) &#123;</span><br><span class="line">      if (temp[i].parent) &#123;</span><br><span class="line">        if (!temp[temp[i].parent].children) &#123;</span><br><span class="line">          temp[temp[i].parent].children = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        temp[temp[i].parent].children[temp[i].id] = temp[i];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        tree[temp[i].id] = temp[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tree;</span><br><span class="line"></span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    plv8.elog(ERROR, &#x27;buildTree &#x27; + error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getTreeOfMenus = function() &#123;</span><br><span class="line">  let cmdb = require(&#x27;xxx&#x27;);</span><br><span class="line">  let result = cmdb.service.query(&#x27;default&#x27;, &#x27;&#123;xxx&#123;id name&#125;&#125;&#x27;, &#123;&#125;);</span><br><span class="line">  return buildTree(result);</span><br><span class="line">&#125;;</span><br><span class="line">let allMenus = getTreeOfMenus();</span><br><span class="line"></span><br><span class="line">delete allMenus[&#x27;xxx&#x27;];</span><br><span class="line"></span><br><span class="line">let ids = [];</span><br><span class="line">idsOfflatten = function(data) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    for (let id in data) &#123;</span><br><span class="line">      ids.push(id);</span><br><span class="line">      if (data[id].children) &#123;</span><br><span class="line">        idsOfflatten(data[id].children);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ids;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    plv8.elog(ERROR, &#x27;idsOfflatten &#x27; + error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let flatIds = idsOfflatten(allMenus);</span><br><span class="line">plv8.elog(INFO, &#x27;new menu ids:&#x27; + flatIds);</span><br><span class="line">getNormalMenus = function(menus) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    plv8.elog(INFO, &#x27;old menus : &#x27; + JSON.stringify(menus));</span><br><span class="line">    let old_keys = Object.keys(menus);</span><br><span class="line">    old_keys.forEach(id =&gt; &#123;</span><br><span class="line">      if (!flatIds.includes(id)) &#123;</span><br><span class="line">        plv8.elog(INFO, &#x27;delete menu id: &#x27; + id);</span><br><span class="line">        delete menus[id];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return menus;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    plv8.elog(ERROR, &#x27;getNormalMenus &#x27; + error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">updateMenus = function() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let ROLE_ADMIN = &#x27;admin&#x27;,</span><br><span class="line">      ROLE_DOMAIN = &#x27;domain&#x27;;</span><br><span class="line">    let query = &#x27;SELECT name,  menus, role_type FROM xxx&#x27;;</span><br><span class="line">    let updateAdmin =</span><br><span class="line">      &#x27;UPDATE xxx SET  menus=NULL,  last_modified=CURRENT_TIMESTAMP where  name = $1&#x27;;</span><br><span class="line">    let updateNormal = &#x27;UPDATE xxx SET  menus=$1, last_modified=CURRENT_TIMESTAMP where name = $2&#x27;;</span><br><span class="line">    let execCount=0;</span><br><span class="line">    plv8.execute(query).forEach(row =&gt; &#123;</span><br><span class="line">      let roleType = row.role_type;</span><br><span class="line">      if (roleType === ROLE_DOMAIN || roleType === ROLE_ADMIN) &#123;  </span><br><span class="line">        let adminCount = plv8.execute(updateAdmin, [row.name]);</span><br><span class="line">        plv8.elog(INFO, &#x27;update admin user menus is null ,count: &#x27;+adminCount );</span><br><span class="line">        adminCount&gt;0 ? execCount+=1:null;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let newMenus = getNormalMenus(row.menus);</span><br><span class="line">      let normalCount = plv8.execute(updateNormal, [newMenus, row.name]);</span><br><span class="line">      plv8.elog(INFO, &#x27;update normal user menus , &#x27; + JSON.stringify(newMenus)+&#x27;,count:&#x27;+normalCount);</span><br><span class="line">      normalCount&gt;0 ? execCount+=1:null;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   return execCount;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    plv8.elog(ERROR, &#x27;updateMenus &#x27; + error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let updateCount=updateMenus();</span><br><span class="line">plv8.elog(INFO,&#x27;total of successes :&#x27;+updateCount);</span><br><span class="line">plv8.elog(INFO,&#x27;------------------------------------update user menus end------------------------------------&#x27;);</span><br><span class="line">$$ LANGUAGE plv8;</span><br></pre></td></tr></table></figure>



<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>PostgreSQL很强大，这是我初试水，后续有机会会再写写工作中的一些PostgreSQL的实践例子。</p>
<p>其实PostgreSQL几乎可扩展主流的所有编程语言比如C++、Java、nodejs等。</p>
<p>参考文档：</p>
<blockquote><footer><strong>plv8 documention</strong><cite><a href="https://plv8.github.io/">plv8.github.io</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux ps、top、free命令</title>
    <url>/2020/04/21/ps-grep-top-free/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>虽然我们系统有建设一些监控工具比如Grafana、Prometheus等，但是很多时候还是愿意直接先到服务器上去瞧一眼，特别是客户现场的问题，因为客户现场暂时不会装这些工具。因为我们是做NPMD的，流量大的时候资源消耗就比较大，加上前期先铺功能非功能需求的细节待完善，所以有时候会出现客户现场机器在一段时间后会变得比较慢的情况，这个时候那当然就说劈里啪啦一堆装逼的命令敲上去瞅瞅服务器咋了。</p>
<p>用的比较高频的命令就是<strong>ps、grep、top</strong>。用的倒是还算一般，不过一直没有深深的了解，所以刚好借着这个机会，深入的学习一下。演示用的是安装centos系统的vps。</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>这命令应该是我使用的命令中的top one了，该命令用于获取正在运行的进程信息。 我们在看一些服务是否运行的时候通常都是用这个命令。我们可以获取任何用户在当前系统上运行的进程之类的信息，例如进程ID（PID）。</p>
<p>ps命令本身是一个扩展工具，ps –help a一下，会发现有很多的命令选项，说是有80多个。</p>
<img src="/2020/04/21/ps-grep-top-free/ps.png" class="" title="from 我">

<p>当然我们只说说常用的。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>如果在Linux中使用不带任何选项的ps命令，它将显示当前shell中正在运行的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure>

<p>只会看到ps和bash。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 2053 pts/0    00:00:00 ps</span><br><span class="line">31585 pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure>

<ul>
<li>PID是进程的唯一ID</li>
<li>TTY是已登录终端用户的类型。pts表示伪终端</li>
<li>TIME给您进程运行了多长时间</li>
<li>CMD是您运行以启动该过程的命令</li>
</ul>
<p>很明显，我们并没有得到任何真实，有用的信息。</p>
<h5 id="1-查看所有运行过程"><a href="#1-查看所有运行过程" class="headerlink" title="1.查看所有运行过程"></a>1.查看所有运行过程</h5><p>如果要查看自己运行的所有进程，可以将ps命令与选项x一起使用，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -x</span><br></pre></td></tr></table></figure>

<p>x选项将显示所有进程，即使它们与当前tty（终端类型）不相关。</p>
<p>“– ”是可选的，但一般的Linux约定是加上“–”选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">  543 tty1     Ss+    0:00 /sbin/agetty --noclear tty1 linux</span><br><span class="line">  544 ?        Ssl    0:01 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line">  546 ?        S      0:00 [hwrng]</span><br><span class="line">  556 ?        I&lt;     0:00 [cryptd]</span><br><span class="line">  943 ?        Ss     0:00 /sbin/dhclient -1 -q -lf /var/lib/dhclient/dhclient--eth0.lease -pf /var/run/dhclient-eth0.pid -H vultr eth0</span><br><span class="line"> 1009 ?        Ssl    0:53 /usr/bin/python2 -Es /usr/sbin/tuned -l -P</span><br><span class="line"> 1012 ?        Ssl    0:59 /usr/sbin/rsyslogd -n</span><br><span class="line"> 1052 ?        Ss     0:00 nginx: master process /usr/sbin/nginx</span><br><span class="line"> 1265 ?        Ss     0:02 /usr/libexec/postfix/master -w</span><br><span class="line">12385 ?        R      0:00 [kworker/u2:0-ev]</span><br><span class="line">12684 ?        Ss     0:00 sshd: root@pts/0</span><br><span class="line">12688 ?        Ss     0:00 sshd: root@notty</span><br><span class="line">12690 pts/0    Ss     0:00 -bash</span><br></pre></td></tr></table></figure>

<p>上面输出中的STAT表示过程状态代码。有兴趣可以查一下详细的说明。其实很少会看到仅使用选项x的ps命令。通常以这种方式伴随选项u：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ux</span><br></pre></td></tr></table></figure>

<p>使用选项u，您将获得有关每个进程的详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">abhishek   503  0.0  0.4 681580 37516 pts/0    Sl   18:09   0:00 gedit</span><br><span class="line">abhishek  2245  0.0  0.0  11300  1496 ?        S    18:37   0:00 /usr/bin/ssh-agent -D -a /run/user/1000/keyring/.ssh</span><br><span class="line">abhishek  3039  0.0  0.0  77344  3508 ?        Ss   10:37   0:00 /lib/systemd/systemd --user</span><br><span class="line">abhishek  3040  0.0  0.0 114632   360 ?        S    10:37   0:00 (sd-pam)</span><br><span class="line">abhishek  3054  0.0  0.1 517104 11512 ?        SLl  10:37   0:01 /usr/bin/gnome-keyring-daemon --daemonize --login</span><br></pre></td></tr></table></figure>

<p>如您所见，现在您获得了每个进程的用户名以及CPU <a href="https://linuxhandbook.com/linux-memory-usage/">使用率</a>和<a href="https://linuxhandbook.com/linux-memory-usage/">内存使用率</a>。RSS显示该进程当前在RAM中有多少内存，而VSZ显示该进程总共有多少虚拟内存。</p>
<h5 id="2-使用ps-aux命令查看所有正在运行的进程"><a href="#2-使用ps-aux命令查看所有正在运行的进程" class="headerlink" title="2.使用ps aux命令查看所有正在运行的进程"></a>2.使用ps aux命令查看所有正在运行的进程</h5><p>您可能会一直在Linux教程和文档中看到<code>ps -aux</code>或看到<code>ps aux</code>它们。</p>
<p>使用添加的-a选项，您可以查看<a href="https://linuxhandbook.com/linux-list-users/">Linux系统上所有用户</a>的运行进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure>

<p>命令输出与ps -ux相同，但是现在您也具有其他用户的进程。由于使用-u选项，您可以识别哪个进程属于哪个用户。</p>
<h5 id="3-在Linux中使用ps-ef命令查看所有正在运行的进程"><a href="#3-在Linux中使用ps-ef命令查看所有正在运行的进程" class="headerlink" title="3.在Linux中使用ps -ef命令查看所有正在运行的进程"></a>3.在Linux中使用ps -ef命令查看所有正在运行的进程</h5><p>除了ps -aux以外，您还可以使用-e命令列出所有正在运行的进程。通常的做法是将与“f”结合使用，以获得用于运行进程的命令的完整列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure>

<p>还可以加上“H”，显示所有的父进程以及其下的子进程一起：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -efH</span><br></pre></td></tr></table></figure>

<h5 id="4-查看特定用户的所有正在运行的进程"><a href="#4-查看特定用户的所有正在运行的进程" class="headerlink" title="4.查看特定用户的所有正在运行的进程"></a>4.查看特定用户的所有正在运行的进程</h5><p>要获取有关特定用户运行的所有进程的信息，可以将“-U”选项与用户名一起使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -U user_name</span><br></pre></td></tr></table></figure>

<p>例如，我可以看到root用户正在运行的所有进程是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -U root</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:41 systemd</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    3 ?        00:00:00 rcu_gp</span><br><span class="line">    4 ?        00:00:00 rcu_par_gp</span><br><span class="line">    8 ?        00:00:00 mm_percpu_wq</span><br><span class="line">    9 ?        00:00:03 ksoftirqd/0</span><br><span class="line">   10 ?        00:01:22 rcu_sched</span><br></pre></td></tr></table></figure>

<h5 id="5-查看小组运行的所有进程"><a href="#5-查看小组运行的所有进程" class="headerlink" title="5.查看小组运行的所有进程"></a>5.查看小组运行的所有进程</h5><p>您还可以通过按组名或组ID来对正在运行的进程进行分类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -G group_name_or_id</span><br></pre></td></tr></table></figure>

<p>您可以与选项f结合使用以获取完整列表。</p>
<h5 id="6-获取程序的所有出现次数和PID"><a href="#6-获取程序的所有出现次数和PID" class="headerlink" title="6.获取程序的所有出现次数和PID"></a>6.获取程序的所有出现次数和PID</h5><p>ps命令的基本用法之一是获取正在运行的程序的进程ID（PID）。通常，当要终止行为异常的程序时，将搜索该程序的所有实例，获取其PID并使用kill命令终止该过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -C program__name</span><br></pre></td></tr></table></figure>

<p>例如，如果我必须找到apt软件包管理器的所有正在运行的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -C apt</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">11425 pts/1    00:00:00 apt</span><br></pre></td></tr></table></figure>

<p>您也可以<a href="https://linuxhandbook.com/grep-command-examples/">使用grep命令</a>获得类似的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | grep program_name</span><br></pre></td></tr></table></figure>

<h5 id="7-获取有关PID的过程信息"><a href="#7-获取有关PID的过程信息" class="headerlink" title="7.获取有关PID的过程信息"></a>7.获取有关PID的过程信息</h5><p>好的！您有一个PID，但您不知道它属于哪个进程。您可以通过以下方式使用ps命令从其PID查找过程信息，N即PID：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -pN</span><br></pre></td></tr></table></figure>

<p>您可以通过使用逗号分隔多个PID，以使用多个PID：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -pN1,N2,N3</span><br></pre></td></tr></table></figure>

<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>其实上面提到了一点，结合ps命令搜索进程，所以可以看出grep命令就像一个过滤器一样的作用，grep在文件中搜索匹配条件的内容，并显示包含该条件的所有行。 </p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]# grep --help</span><br><span class="line">Usage: grep [OPTION]... PATTERN [FILE]...</span><br><span class="line">Search for PATTERN in each FILE or standard input.</span><br><span class="line">PATTERN is, by default, a basic regular expression (BRE).</span><br><span class="line">Example: grep -i &#x27;hello world&#x27; menu.h main.c</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat &gt; geekfile.txt</span><br><span class="line">unix is great os. unix is opensource. unix is free os.</span><br><span class="line">learn operating system.</span><br><span class="line">Unix linux which one you choose.</span><br><span class="line">uNix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.</span><br></pre></td></tr></table></figure>

<p><strong>1.不区分大小写的搜索：</strong> -i选项允许在给定文件中不区分大小写地搜索字符串。比如“ UNIX”，“ Unix”，“ unix”等词都可匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$grep -i &quot;UNix&quot; geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unix is great os. unix is opensource. unix is free os.</span><br><span class="line">Unix linux which one you choose.</span><br><span class="line">uNix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.</span><br></pre></td></tr></table></figure>

<p><strong>2. 显示与条件匹配的文件名</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$grep -l &quot;unix&quot; *</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"> </span><br><span class="line">$grep -l &quot;unix&quot; f1.txt f2.txt f3.xt f4.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>3. 检查文件中的整个单词 :</strong> 默认情况下，即使grep在文件中找到子字符串，它也只会匹配给定的字符串。 grep的-w选项使其仅匹配整个单词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -w &quot;unix&quot; geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<img src="/2020/04/21/ps-grep-top-free/image-20200422105439799.png" class="">


<p><strong>4.使用grep -n在显示输出时显示行号：</strong>要显示匹配行的文件的行号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -n &quot;unix&quot; geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:unix is great os. unix is opensource. unix is free os.</span><br><span class="line">4:uNix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.</span><br></pre></td></tr></table></figure>

<p><strong>5.反转模式匹配：</strong>您可以使用-v选项显示与指定搜索字符串模式不匹配的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -v &quot;unix&quot; geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">learn operating system.</span><br><span class="line">Unix linux which one you choose.</span><br></pre></td></tr></table></figure>

<p><strong>6.匹配以字符串开头的行：</strong> ^正则表达式模式指定行的开头。可以在grep中使用它来匹配以给定的字符串开头的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep &quot;^unix&quot; geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unix is great os. unix is opensource. unix is free os.</span><br></pre></td></tr></table></figure>

<p><strong>7.匹配以字符串结尾的行：</strong>“ $”正则表达式模式指定行的结尾。可以在grep中使用它来匹配以给定字符串结尾的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep &quot;os$&quot; geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vultr home]# grep &quot;system.$&quot; geekfile.txt</span><br><span class="line">learn operating system.</span><br></pre></td></tr></table></figure>

<p>grep正则有兴趣的可以看下<a href="https://www.geeksforgeeks.org/regular-expression-grep/?ref=rp">regular-expression-grep</a>。通常我是ps和grep结合在一起用，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vultr home]# ps -ef |grep -i &quot;v2ray&quot;</span><br><span class="line">root      1008     1  0 Apr17 ?        00:01:57 /usr/bin/v2ray/v2ray -config /etc/v2ray/config.json</span><br><span class="line">root     29435 28377  0 11:09 pts/0    00:00:00 grep --color=auto -i v2ray</span><br></pre></td></tr></table></figure>

<h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><table>
<thead>
<tr>
<th align="left">Linux grep command options</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i</td>
<td align="left">忽略大小写</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">强制PATTERN只匹配整个单词</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">反向匹配</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">输出匹配的行号</td>
</tr>
<tr>
<td align="left">-h</td>
<td align="left">在输出中禁止Unix文件名前缀</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">在Linux上递归搜索目录</td>
</tr>
<tr>
<td align="left">-R</td>
<td align="left">就像-r一样，但是遵循所有符号链接</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">仅打印具有选定行的文件名称称</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">每个文件仅打印选定行的数量</td>
</tr>
<tr>
<td align="left">–color</td>
<td align="left">颜色显示匹配的内容</td>
</tr>
</tbody></table>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top命令提供系统信息的快速概述，它提供了正在运行的系统的动态实时视图，每3秒刷新一次（默认情况下）。 视图内容分为两部分：</p>
<ol>
<li>系统的摘要信息</li>
<li>当前由Linux内核管理的进程或线程的列表。</li>
</ol>
<p>一旦运行此命令，它将打开一个交互式命令模式，其中上半部分将包含进程和资源使用情况的统计信息。 下半部分包含当前正在运行的进程的列表。 按q会退出命令模式。</p>
<img src="/2020/04/21/ps-grep-top-free/top.png" class="">

<h5 id="上半部分"><a href="#上半部分" class="headerlink" title="上半部分"></a>上半部分</h5><p>如图，在终端的顶部，我们获得了概览数据，包括当前任务数、内存使用率和cpu负载。 </p>
<p><strong>第一行：任务队列信息</strong>，同uptime命令的结果一样。</p>
<blockquote>
<p>4:06:23 — 当前系统时间</p>
<p> up 4 days, 22:36 — 系统已经运行了4天22小时36分钟（在这期间系统没有重启过的吆！）</p>
<p>2 users — 当前有2个用户登录系统</p>
<p>load average: 0.00, 0.00, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。例如，负载为1.0表示当前负荷为100％。</p>
</blockquote>
<p><strong>load average</strong>：平均负载部分表示一分钟，五分钟和十五分钟的平均“负载”，数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。。 “负载”是系统执行的计算工作量的度量。 在Linux上，负载是在任何给定时刻处于R和D状态的进程数。 “平均负载”值为您提供了一个等待时间，可以用来衡量您需要等待多长时间才能完成工作。</p>
<p>在多核系统上，您应该首先将平均负载除以CPU核数以得到类似的度量。</p>
<p><strong>第二行：Tasks — 任务（进程）</strong></p>
<p>系统进程也称为任务。进程可以以许多不同的方式运行，并使用各种算法确定优先级。 这有助于优化计算机执行任务的方式和时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tasks:  83 total,   1 running,  48 sleeping,   0 stopped,   0 zombie</span><br></pre></td></tr></table></figure>

<p>对状态进行简单的说明:</p>
<table>
<thead>
<tr>
<th align="left">State</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Running</td>
<td align="left">运行中&#x2F;待处理（Active &#x2F; in Queue to be Processed）</td>
</tr>
<tr>
<td align="left">Sleeping</td>
<td align="left">休眠（Waiting for a Process to Complete）</td>
</tr>
<tr>
<td align="left">Stopped</td>
<td align="left">停止（Interrupted by Job Control Signal ）</td>
</tr>
<tr>
<td align="left">Zombie</td>
<td align="left">僵尸进程（Made up of “Orphaned” Child Tasks &#x2F; No Longer Running）</td>
</tr>
</tbody></table>
<p><strong>第三行：cpu状态信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%Cpu(s):  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure>

<p>CPU使用率部分显示了在各种任务上花费的CPU时间的百分比。 </p>
<table>
<thead>
<tr>
<th align="left">Abbreviation</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">us</td>
<td align="left">CPU在用户空间（各个进程使用）中花费在执行进程上的时间</td>
</tr>
<tr>
<td align="left">sy</td>
<td align="left">运行内核空间（内核使用）进程所花费的时间</td>
</tr>
<tr>
<td align="left">ni</td>
<td align="left">优先级</td>
</tr>
<tr>
<td align="left">id</td>
<td align="left">CPU保持空闲的时间</td>
</tr>
<tr>
<td align="left">wa</td>
<td align="left">CPU等待I &#x2F; O完成所花费的时间</td>
</tr>
<tr>
<td align="left">hi</td>
<td align="left">处理硬件中断花费的时间（中断是向处理器发出有关需要立即关注的事件的信号）</td>
</tr>
<tr>
<td align="left">si</td>
<td align="left">处理软件中断花费的时间（中断是向处理器发出有关需要立即关注的事件的信号）</td>
</tr>
<tr>
<td align="left">st</td>
<td align="left">CPU在虚拟机上花费的时间</td>
</tr>
</tbody></table>
<p><strong>第四行：内存状态信息</strong></p>
<p>“内存”部分显示有关系统内存使用情况的信息。 标记为“ Mem”和“ Swap”的行分别显示有关RAM和交换空间的信息。 简而言之，交换空间是硬盘的一部分，就像RAM一样使用。 当RAM使用率接近满时，RAM的不常用区域将写入交换空间，以备以后需要时检索。 但是，由于访问磁盘的速度很慢，因此过多地依赖交换会损害系统性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KiB Mem :  1006744 total,   200872 free,   146212 used,   659660 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   660908 avail Mem</span><br></pre></td></tr></table></figure>

<p>  “avail Mem”值是可以分配给进程而不会引起更多交换的内存量。</p>
<p>Linux内核还尝试以各种方式减少磁盘访问时间。 它在RAM中维护“磁盘缓存”，在RAM中存储磁盘的常用区域。 另外，磁盘写操作存储在“磁盘缓冲区”中，内核最终将其写出到磁盘。 它们消耗的总内存为“ buff &#x2F; cache”值。缓存使用的内存将在需要时分配给进程。</p>
<h5 id="下半部分"><a href="#下半部分" class="headerlink" title="下半部分"></a>下半部分</h5><p>在终端的下部，我们有一个任务信息的表格，其中包含许多详细信息，先简单解释一下表头。</p>
<table>
<thead>
<tr>
<th align="left">Abbreviation</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PID</td>
<td align="left">进程ID(唯一正整数)</td>
</tr>
<tr>
<td align="left">USER</td>
<td align="left">用户名</td>
</tr>
<tr>
<td align="left">PR</td>
<td align="left">代表任务的优先级</td>
</tr>
<tr>
<td align="left">NI</td>
<td align="left">代表任务的价值。 负值表示优先级较高，正值表示优先级较低</td>
</tr>
<tr>
<td align="left">VIRT</td>
<td align="left">任务使用的虚拟内存</td>
</tr>
<tr>
<td align="left">RES</td>
<td align="left">任务使用的物理内存</td>
</tr>
<tr>
<td align="left">SHR</td>
<td align="left">任务使用的共享内存</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">进程状态（正在运行，已停止等）</td>
</tr>
<tr>
<td align="left">%CPU</td>
<td align="left">CPU 负载</td>
</tr>
<tr>
<td align="left">%MEM</td>
<td align="left">物理内存&#x2F;总内存的百分比</td>
</tr>
<tr>
<td align="left">TIME +</td>
<td align="left">自启动以来该进程使用的总CPU时间，精确到百分之一秒</td>
</tr>
<tr>
<td align="left">COMMAND</td>
<td align="left">进程名称</td>
</tr>
</tbody></table>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="杀进程"><a href="#杀进程" class="headerlink" title="杀进程"></a><strong>杀进程</strong></h4><p>如果您想终止进程，只需在top运行时按“ k”。 这将弹出提示，提示您输入进程的进程ID，然后按Enter。</p>
<p>如下图中的：<span style=color:red>PID to signal&#x2F;kill [default pid &#x3D; 1]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Tasks:  81 total,   2 running,  46 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1006744 total,   202708 free,   144288 used,   659748 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   662828 avail Mem</span><br><span class="line">&lt;span style=color:red&gt;PID to signal/kill [default pid = 1]&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h4 id="进程列表排序"><a href="#进程列表排序" class="headerlink" title="进程列表排序"></a><strong>进程列表排序</strong></h4><p>使用诸如top之类的工具的最常见原因之一就是找出哪个进程消耗最多的资源。 您可以按以下键对列表进行排序（记住是<strong>大写</strong>哦）：</p>
<ul>
<li>“ M”按内存使用量排序</li>
<li>“ P”按CPU使用率排序</li>
<li>“ N”按进程ID排序</li>
<li>“ T”按运行时间排序</li>
</ul>
<p>默认情况下，top按降序显示所有结果。 但是，您可以通过按’R’切换到升序。</p>
<p>您也可以使用-o+表头的名称对列表进行排序。 例如，如果要按CPU使用率对进程进行排序，可以使用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -o %CPU</span><br></pre></td></tr></table></figure>

<h4 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -H</span><br><span class="line">//出现的视图中的Tasks会变为Threads</span><br><span class="line">Threads: 103 total,   3 running,  68 sleeping,   0 stopped,   0 zombie</span><br></pre></td></tr></table></figure>

<h4 id="显示完整路径（绝对路径）"><a href="#显示完整路径（绝对路径）" class="headerlink" title="显示完整路径（绝对路径）"></a>显示完整路径（绝对路径）</h4><p>默认情况下，top不显示程序的完整路径，也不区分内核空间进程和用户空间进程。 如果您需要此信息，请在top运行时按“ c”，再次按“ c”返回默认设置。内核空间进程周围带有方括号标记。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2036 root      20   0  158820   8852   7532 S  0.3  0.9   0:00.01 sshd: root [priv]</span><br><span class="line">   1 root      20   0   46124   8060   5616 S  0.0  0.8   0:15.58 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">   2 root      20   0       0      0      0 S  0.0  0.0   0:00.13 [kthreadd]</span><br><span class="line">   3 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 [rcu_gp]</span><br><span class="line">   4 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 [rcu_par_gp]</span><br></pre></td></tr></table></figure>

<p>或者运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure>

<h4 id="树状显示"><a href="#树状显示" class="headerlink" title="树状显示"></a>树状显示</h4><p>如果希望查看进程的子级父级。 按“ V”。比如下图所示systemd为系统启动的第一个进程，该进程又创建了sshd等其它进程…。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1 root      20   0   46124   8060   5616 S  0.0  0.8   0:15.58 systemd</span><br><span class="line">  439 root      20   0   37204   3708   3396 S  0.0  0.4   2:00.59  `- systemd-journal</span><br><span class="line"> 1012 root      20   0  258612   9696   8084 S  0.0  1.0   1:14.57  `- rsyslogd</span><br><span class="line"> 1052 root      20   0  131160   2188     60 S  0.0  0.2   0:00.00  `- nginx</span><br><span class="line"> 1053 nginx     20   0  132160  10100   7252 S  0.0  1.0   0:46.42      `- nginx</span><br><span class="line"> 1265 root      20   0   89716   4836   3804 S  0.0  0.5   0:02.67  `- master</span><br><span class="line"> 1268 postfix   20   0   89888   6600   5596 S  0.0  0.7   0:00.65      `- qmgr</span><br><span class="line"> 1608 postfix   20   0   89820   6628   5624 S  0.0  0.7   0:00.01      `- pickup</span><br><span class="line">13138 root      20   0  112936   7732   6708 S  0.0  0.8   0:16.48  `- sshd</span><br><span class="line">28367 root      20   0  159228  10264   8572 S  0.0  1.0   0:03.73      `- sshd</span><br><span class="line">28377 root      20   0  115464   3624   3208 S  0.0  0.4   0:00.13          `- bash</span><br><span class="line"> 2053 root      20   0  161908   4444   3804 R  0.3  0.4   0:00.21              `- top</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="列出指定用户的进程"><a href="#列出指定用户的进程" class="headerlink" title="列出指定用户的进程"></a>列出指定用户的进程</h4><p>要列出某个用户的进程，请在top运行时按“ u”。 </p>
<p>或者用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -u root</span><br></pre></td></tr></table></figure>

<h4 id="过滤进程"><a href="#过滤进程" class="headerlink" title="过滤进程"></a>过滤进程</h4><p>如果只想查看某些进程，可以使用top的过滤。 要激活此模式，请按“ o” &#x2F;“ O”。 顶部会出现一个提示，您可以在此处键入过滤器表达式。如下图中的<span style=color:red>add filter #1 (ignoring case) as: [!]FLD?VAL</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KiB Mem :  1006744 total,   198520 free,   147308 used,   660916 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   659616 avail Mem</span><br><span class="line">add filter #1 (ignoring case) as: [!]FLD?VAL</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   46124   8060   5616 S  0.0  0.8   0:15.74 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.13 kthreadd</span><br><span class="line">    3 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 rcu_gp</span><br></pre></td></tr></table></figure>

<p>过滤器表达式是指定属性和值之间关系的语句。 过滤器的一些示例是：</p>
<ul>
<li>COMMAND &#x3D; getty：过滤在COMMAND属性中包含“ getty”的进程。</li>
<li>！COMMAND &#x3D; getty：过滤在COMMAND属性中没有“ getty”的进程。</li>
<li>％CPU&gt; 3.0：筛选CPU利用率超过3％的进程。</li>
</ul>
<p>添加过滤器后，您可以通过添加更多过滤器来进一步简化操作。 要清除添加的所有过滤器，请按“ &#x3D;”。</p>
<h4 id="更改CPU和内存统计信息的默认外观"><a href="#更改CPU和内存统计信息的默认外观" class="headerlink" title="更改CPU和内存统计信息的默认外观"></a>更改CPU和内存统计信息的默认外观</h4><p>如果觉得top显示CPU和内存统计信息的默认方式不喜欢。 可以按“ t”和“ m”来更改CPU和内存统计信息的样式。 </p>
<img src="/2020/04/21/ps-grep-top-free/top1.png" class="">

<h4 id="保存设置"><a href="#保存设置" class="headerlink" title="保存设置"></a>保存设置</h4><p>如果您对top的输出进行了任何更改，则可以按“ W”将其保存以备后用。 top将其配置写入主目录中的.toprc文件。</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><blockquote><footer><strong>top1</strong><cite><a href="http://man7.org/linux/man-pages/man1/top.1.html">man7.org</a></cite></footer></blockquote>

<blockquote><footer><strong>grep-command-in-unixlinux</strong><cite><a href="https://www.geeksforgeeks.org/grep-command-in-unixlinux">geeksforgeeks</a></cite></footer></blockquote>

<blockquote><footer><strong>howto-use-grep-command-in-linux-unix</strong><cite><a href="https://www.cyberciti.biz/faq/howto-use-grep-command-in-linux-unix/">Vivek Gite</a></cite></footer></blockquote>

<blockquote><footer><strong>guide-linux-top-command</strong><cite><a href="https://www.booleanworld.com/guide-linux-top-command/">SUPRIYO BISWAS</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>six months learn a language</title>
    <url>/2022/07/25/six-months-learn-a-language/</url>
    <content><![CDATA[<p>最近看到一个视频：<a href="https://www.youtube.com/watch?v=d0yGdNEWdn0">如何在六个月内掌握一门外语</a>挺让我惊喜的，里面的内容跟以往我看到的一些教学习语言的内容有挺大不同，做个记录。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="两大误解"><a href="#两大误解" class="headerlink" title="两大误解"></a>两大误解</h4><ol>
<li>Talent（需要天赋）</li>
<li>Immersion per se（沉浸式语言环境）</li>
</ol>
<p>特别是第二点再没看到这个视频之前我一直以为学习一门新语言最好的方式是去到说该语言的环境中，沉浸式体验才能快速学会，看过视频后最起码让我觉得这应该不是最好的方式，因为我回过头来一想，之前在重庆上学的时候因为学校就在重大旁边，所以认识了几个公派留学生，他们在中国留学2年，据我的了解，这些留学生没一人能说超过10句中文，尽管他们天天待在中文的环境。</p>
<h4 id="5个原则"><a href="#5个原则" class="headerlink" title="5个原则"></a>5个原则</h4><h4 id="7个动作"><a href="#7个动作" class="headerlink" title="7个动作"></a>7个动作</h4>]]></content>
  </entry>
  <entry>
    <title>《价值》</title>
    <url>/2023/05/14/%E3%80%8A%E4%BB%B7%E5%80%BC%E3%80%8B/</url>
    <content><![CDATA[<p>最近看了本书《价值》，高瓴资本的张磊写的，人和其所在的行业虽然我都不熟，但是当时在书店随便拿了本看看。</p>
<p>这是目前唯一一本从序，开始就抓住我眼球的书，当然我看的书不多就是了，我估计是因为刚好最近有些焦虑和颓废的原因吧，这本书仿佛是孙悟空派来叫醒我的。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>坚持长期主义，这是一条越走越不孤独的路，这是一条越走越行稳致远的路。</p>
<p>长期主义-把时间和信念投入到能够长期产生价值的事件中，尽力学习最有效率的思维方式和行为标准，遵循第一性原理，永远探求真理。</p>
<p>长期主义与个人而言，是一种清醒，帮助人们建立理性的认知框架，不受短期诱惑和繁杂噪声的影响。</p>
<p>对企业而言，是一种格局，帮助企业拒绝狭隘的零和游戏，在不断创新、不断创造的价值历程中，重塑企业的动态护城河。</p>
<p><mark>一个人的知识、能力和价值观，才是深藏于心，并真正属于自己的”三把火“</mark></p>
<p>方法和策略能战胜市场，但对长期主义的信仰却能够赢得未来。</p>
<p>发表自己真实的想法和意见，不去争论谁是对的，而是去争论什么是对的。</p>
<p>更多的研究是为了更少的决策，更久的研究是为了更准的决策。</p>
<h4 id="对于数据的理解"><a href="#对于数据的理解" class="headerlink" title="对于数据的理解"></a>对于数据的理解</h4><ol>
<li>数据不等同于真相，真相往往比数据更加复杂。（需要看到具象的真相，而不是抽象的数据）</li>
<li>数据本身没有观点，研究时不能预设观点、只喜欢那些能够支持自己观点的数据。</li>
<li>数据不一定永远有用，不同情况下，一些曾经有用的数据变得不再有用，需要新的指标。</li>
</ol>
<p>很多时候迷恋数据是为了拿数据当挡箭牌，抵挡因为懒惰带来的错误，从而把责任怪到数据上。</p>
<p><mark>正确的理解应该是：精确的数据无法代替大方向上的判断，战术上的勤奋不能弥补战略上的懒惰</mark></p>
<h4 id="关于创新"><a href="#关于创新" class="headerlink" title="关于创新"></a>关于创新</h4><p>克莱顿·克里斯坦森关于创新的诠释：创新不在于技术进步，更不在于科学发现，而在于对市场变迁的主动响应。<br>世界上只有一条护城河，就是企业家门不断创新，不断疯狂地创造长期价值。</p>
<p>克莱顿·克里斯坦森《创新者的窘境》将创新定位两类：</p>
<ol>
<li>维持性创新<blockquote>
<p>不断完善和改进现有产品，通过精耕细作满足更挑剔的需求。但是偶然的非主观的主义则无法融入企业创新流程。</p>
</blockquote>
</li>
<li>破坏性创新<blockquote>
<p>追求的根本性的改变，从底层出发改变现有的技术发展路径和思维方式，创造出区别于现有主流市场的全新产品合服务，这种创新可能会对原油的护城河降维打击。</p>
</blockquote>
</li>
</ol>
<h3 id="教育是对人生最重要、最明智的投资"><a href="#教育是对人生最重要、最明智的投资" class="headerlink" title="教育是对人生最重要、最明智的投资"></a>教育是对人生最重要、最明智的投资</h3><h4 id="长期主义的人才观"><a href="#长期主义的人才观" class="headerlink" title="长期主义的人才观"></a>长期主义的人才观</h4><p>较长的员工成长的还得益于足够扁平的组织机制。扁平的组织机制能够保证更多有价值的想法随时听到，“多汇报，少请示”。特别是对于新人，即使反馈，从而得到反馈，能得到足够的尊重。</p>
<p>团队内营造更好的倾听反馈和给予关怀的氛围。</p>
<p>自我驱动能力。</p>
<p>员工的成长有两方面：</p>
<ol>
<li>素质和业务上的提高。</li>
<li>与公司形成情感上的连接和默契。</li>
</ol>
<p>对于有潜质、价值观一致的员工，我们奉行长期主义，不着急，慢慢来，给予其充分的成长时间。</p>
<h4 id="长成长型的人才培养机制"><a href="#长成长型的人才培养机制" class="headerlink" title="长成长型的人才培养机制"></a>长成长型的人才培养机制</h4><h5 id="拥有多学科思维的"><a href="#拥有多学科思维的" class="headerlink" title="拥有多学科思维的"></a>拥有多学科思维的</h5><h5 id="共创、共享的知识大脑。"><a href="#共创、共享的知识大脑。" class="headerlink" title="共创、共享的知识大脑。"></a>共创、共享的知识大脑。</h5><blockquote>
<p>全力打造学习型组织。倡导“传、帮、带”文化与跨团队的交流和分享，创造一切条件促进内部学习。“传、帮、带”不是为了消灭个性。</p>
</blockquote>
<p>分享周？跨团队分享机制。</p>
<p>团队协作,复盘和纠错机制。</p>
<h3 id="做时间的朋友"><a href="#做时间的朋友" class="headerlink" title="做时间的朋友"></a>做时间的朋友</h3><p>第二曲线理论。</p>
<p>《七律·和柳亚子先生》</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>自省</tag>
      </tags>
  </entry>
  <entry>
    <title>三大主义要不得</title>
    <url>/2018/06/27/%E4%B8%89%E5%A4%A7%E4%B8%BB%E4%B9%89%E8%A6%81%E4%B8%8D%E5%BE%97/</url>
    <content><![CDATA[<p>一天看冯大的文章，里面有个词语叫 <strong>本位主义</strong>，知识渊博的我，不得不去百度一下，看看到底啥意思。然后竟然有意外收获，还找到了其它两个主义，感觉挺有用的，做个记录，告诫自己！</p>
<p>三大主义分别为：</p>
<ul>
<li>本位主义</li>
<li>老大主义</li>
<li>怨职主义</li>
</ul>
<h2 id="本位主义"><a href="#本位主义" class="headerlink" title="本位主义"></a>本位主义</h2><p>指在处理单位与部门、整体与部分之间的关系时只顾自己，而不顾整体利益，对别部、别地、别人漠不关心的思想作风或行为态度和心理状态。</p>
<p>这种主义是我见过最多的，基本上呆过的公司都存在这种人才，营销尤盛。这种人其实我是很不喜欢的，因为我太无私了，哈哈！没有其实我也顾自己，但是我不只顾自己，我是正儿八经的为大家放弃小家的那种革命人士，只要公司或者领导没有对我不仁我绝对是把公司、领导的利益放在我前面的。好了夸了自己半天，说回正题。本位主义的人他们有个优势，就是通常他们的kpi都是比较不错的，至于原因你想想kpi的重点不就是考核个人么，只为个人，能不kpi好么。幸好我做的是技术岗，通常这类人很少在身边。</p>
<h2 id="老大主义"><a href="#老大主义" class="headerlink" title="老大主义"></a>老大主义</h2><p>老大主义为特权主义、目中无人、不知天高地厚，总感觉自己现在已经是天下第一，殊不知天外有天人外有人。</p>
<p>这类人 是我敬仰的一批人，对他们来说没有所谓的雨天，能装逼天天是晴天。这种人也遇到过，国企尤盛，之前在国企待过一段时间，天天看他们装逼，是在看不下去然后就走了。有两把刷子你在装逼呗。千万不能成为这种人，幸好我看了看镜子中的自己，没有这份潜力，我就安心了。主要是太低调。</p>
<h2 id="怨职主义"><a href="#怨职主义" class="headerlink" title="怨职主义"></a>怨职主义</h2><p>怨职主义就是公司某些员工天天抱怨公司不好、产品不好、待遇不好，整天怨天尤人，总认为自己的这份工作干不干无所谓，从不考虑自己是否对这份工作做专、做精、做透、做熟的一种现象。</p>
<p>这类人应该是比较普遍，我也偶有这样的情绪，因为总避免不了遇见傻逼，当然也可能是我看你是傻逼，你看我也是傻逼。我一度自己思考过为什么会抱怨，后来总结了一下主要是两点，一点是不公，另一点是遇见了傻逼队友。现在的我很少抱怨了，因为我发现首先不公是到处存在的，要想天平往你这边倾一点那你就创造更大的价值，说起来俗，但最后其实就是看这个。另一个你不能避免遇到傻逼队友，你知道吧，生活就是这样，哪来一帆风顺，你想想西游记没了猪八戒，你能想象么。而且一个人负能量不能太多，多了容易长皱纹。</p>
<p><em><strong>要以此为戒，做一个三无主义的好青年。</strong></em></p>
<p>定义参考：</p>
<blockquote><footer><strong>阿里|以商会友</strong><cite><a href="https://club.1688.com/threadview/48868412.html">企业中的三个“陷阱”</a></cite></footer></blockquote>
<blockquote><footer><strong>百度百科</strong><cite><a href="https://baike.baidu.com/item/%E6%9C%AC%E4%BD%8D%E4%B8%BB%E4%B9%89/757058?fr=aladdin">本位主义</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>告诫</tag>
      </tags>
  </entry>
  <entry>
    <title>个人发展战略</title>
    <url>/2019/10/08/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95%E6%88%98%E7%95%A5/</url>
    <content><![CDATA[<img src="/2019/10/08/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95%E6%88%98%E7%95%A5/0.jpg" class="" title="下班路上">

<h3 id="为什么要谈个人发展"><a href="#为什么要谈个人发展" class="headerlink" title="为什么要谈个人发展?"></a>为什么要谈个人发展?</h3><p>这个话题其实我很怕的….，因为我发育迟读书少，所以一直都懵懵懂懂+凄凄惨惨戚戚，自认为放荡不羁其实就是无知逗逼。我是从17年开始才意识到有个概念叫“以后的路咋走”，文气点就是<strong>个人发展</strong>。因为17年开始面临买房、小孩儿上学等一系列问题，深深感到自己的无力，表象就是缺钱，内里就是焦虑。那段时间常常展开双臂抬头望问天“咋整？我该咋整？”，夜深人静常常哭湿了我的小黄人枕巾。就想着不能这样，得变，得抗。</p>
<p>这两年其实我一直在摸索适合自己地发展路径，包括之前地一篇也在写<span style=color:blue;><a href="#">Post not found: 个人定位</a></span>，从个人定位&#x3D;&gt;个人发展，我认为应该是这样地顺序，虽然现在个人发展长远地战略还不是非常明确，但是至少我认识到了个人发展地重要性，并且找到了最近3-5年自己地发展路径。</p>
<p>当然这篇不是来说我的，是结合之前老大的分享以及平时自己的学习来试着说明一下，个人发展的必要性。</p>
<p>**我们先聊聊几个点，看是否能达成共识。达不成共识可能这篇文章对你来说就没什么意义 **</p>
<h2 id="工作压力大，没时间"><a href="#工作压力大，没时间" class="headerlink" title="工作压力大，没时间"></a><span style=color:red;>工作压力大，没时间</span></h2><p>不用我说大家都知道，个人发展是需要时间来铺垫的，同时个人发展肯定跟工作会有联系，这种联系根据个人的处境可强可弱。另外一个共识点是，工作肯定会压缩我们的可自由支配的时间。所以很多时候我们会得出一个结论，<strong>工作压力大，没时间</strong>。作为程序员我承认确实会存在这样的情况，究其原因：公司的业务压力大，需要堆人堆时间来跟上时代的节奏。另外一点则是个人的精力有限，就像电池一样，在工作上就把电耗尽了，就算会有一些休息时间，也已经没电了。但是我们可以这么想想：现在的工作强度是否有利于个人发展？得到报酬能否多到让我暂时放弃个人发展的程度？工作压力是否真的有我们想象得那么大，时间是否真的就没了？</p>
<p>所以核心的问题是，我们对个人发展这件事情有多重视？愿意投资多少时间和精力？</p>
<p>我的观点是：如果光感受到工作压力大让你没有时间，但又无法获得一些正反馈，那这不是你有没有时间得问题，而是先考虑这份工作是不是应该继续做下去的问题。如果有正反馈，我们再想想是否现在处境就算我想要的的”个人发展”。</p>
<p>怎么来判断，我通常是这样做的：</p>
<ol start="2">
<li>列出来公司的晋升制度，薪酬制度。</li>
<li>尽可能的根据各种反馈，试着评估一下公司的发展前景或者产品线的发展前景。</li>
<li>列出来所在职位的工作内容（在不晋升的情况下），以及如果晋升了的工作内容（从与领导交流，加上观察基本上能预估出80%左右）。</li>
<li>列出来如果因为某些因素，导致被动的离开公司，自己会怎样？</li>
</ol>
<p>不出意外你列完之后，会说一句“卧槽xxxx”，这样就对了，好好考虑一下个人发展的重要性吧。</p>
<p><strong>有点扯远了，其实我是想说，自己愿意的话，不会没有时间。</strong></p>
<h2 id="工作生活要平衡"><a href="#工作生活要平衡" class="headerlink" title="工作生活要平衡"></a><span style=color:red;>工作生活要平衡</span></h2><p><strong>我不想这么辛苦，我期望生活和工作平衡</strong></p>
<blockquote>
<p>很多人都期望活少钱多还开心，朋友圈那些天天晒美食，旅行，老婆孩子热炕头的生活就是理想人生。每个行业都有其辛苦的部分，这才是现实。有的要付出体力之苦，有的要付出健康的代价，有的要付出脑力之苦。既然选择了薪酬相对高一些的IT行业，持续学习新技术，新知识就是你必须面对的。你是想要今天的生活和工作平衡，还是中年油腻后的生计艰难？</p>
<p>假如你不是富二代，官二代，还是更现实，更长期地看待工作和生活平衡的事情。如果你从事的工作是你热爱的工作，不存在平衡问题，从中获得的成就感就是你生活的一部分。如果你从事的工作是你谋生的手段，想持续获得这个收入，就遵循这个工作的本质规律。</p>
</blockquote>
<p>以上是老大的原话我觉得已经说的很透彻了，我认为要想追求工作生活的平衡是不可能的，当然我不是说工作和生活就必须得纠缠在一起才好，我是觉得<strong>平衡</strong>这词应该是心理上的划分而不是物理上的划分。</p>
<h3 id="个人发展战略"><a href="#个人发展战略" class="headerlink" title="个人发展战略"></a>个人发展战略</h3><p>然后我们再来说怎么找到属于自己的个人发展战略，内容总结来自<strong>圈外商学院</strong>的个人发展战略主体纲要，因为平台不让看了，我就直接不要脸的引用有识之士的了。大家如果觉得有用请去链接点赞，就当我对其微薄的回报了。</p>
<p><strong>一、一个模型，帮你找到真正热爱的工作</strong></p>
<ul>
<li><p>冰山模型；美国著名心理学家麦克利兰</p>
</li>
<li><ul>
<li><p>显性30%；</p>
</li>
<li><ul>
<li>知识（专业，书籍），慌乱</li>
<li>技能（编程，技术），焦虑</li>
<li>能力（思考能力，学习能力），挫败低效</li>
</ul>
</li>
<li><p>隐性70%；</p>
</li>
<li><ul>
<li>价值观（判断事物标准），矛盾纠结</li>
<li>性格特质（行为偏好），心累</li>
<li>动机（成就动机，权力动机），没热情</li>
</ul>
</li>
<li><p>四个步骤找到适合的工作</p>
</li>
<li><ul>
<li>找专业；找自己喜欢的专业和爱好的相关岗位</li>
<li>搜索岗位；在招聘网上，搜索岗位的要求</li>
<li>分析需求；用冰山模型，分析这份岗位需要的知识，技能和能力</li>
<li>对比自己；用冰山模型匹配自己的价值观，性格特质和动机，确定适不适合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>二、四大要素，决定你的市场价值</strong></p>
<ul>
<li><p>用冰山模型说明该投入到哪里，才能提升自己的市场价值</p>
</li>
<li><ul>
<li>投入知识；容易获取，但如果不能运用来解决问题，几乎没有竞争力。</li>
<li>投入技能；有门槛，但市场价值取决于稀缺程度，所有技能都会走向供需平衡，高收入不可持续，需要不断持续学习新技能。</li>
<li>投入能力；能力可迁移，积累到一定高度，行业不对称，也能发挥作用。</li>
<li>投入自我发现；难以改变和发现，但如有清晰的认识，找到相匹配的工作也能提升价值。</li>
</ul>
</li>
<li><p>为什么大多数人都选择投入到知识和技能，不断碎片化学习，练习并不稀缺的技能。</p>
</li>
<li><ul>
<li>因为知识和技能容易习得</li>
<li>惰性让自身受限于岗位</li>
<li>没明白工作本质是解决问题</li>
</ul>
</li>
<li><p>汇总；我们的时间，永远应该花在正确的事情上，而不是容易的事情上。</p>
</li>
</ul>
<p><strong>三、四类迹象，发现你的隐藏能力</strong></p>
<ul>
<li><ul>
<li>虽然成功的道路有千万条，但成功人士基本都在遵循了一个原则，就是将自己的自身天赋发挥到了极致。</li>
<li>天赋就是隐藏的能力，让一个人可以在同样起点的情况下，更加加速成长。</li>
</ul>
</li>
<li><p><strong>天赋探索方法；“SIGN”</strong></p>
</li>
<li><ul>
<li>自我效能（Self-efficacy）；对某类事情非常有信心，觉得自己肯定能做好。</li>
<li>本能（Instinct）；迫不及待想要尝试的事情</li>
<li>成长（Growth）；发现自己明显比别人进步的快一些</li>
<li>满足（Needs）；做完后及时很累，也会觉得满足</li>
</ul>
</li>
<li><p>如何在日常中发现自己的SIGN特质</p>
</li>
<li><ul>
<li><p>围绕SIGN特质问自己</p>
</li>
<li><ul>
<li>自我效能；认为自己能教别人什么？别人向你请教什么？跟别人聊天倾向聊什么？聊什么话题会让你感到自信？做什么事情不会感到焦虑和担心？</li>
<li>本能；做什么事的时候很少拖延？长时间休息后，你最想念工作的哪个方面？你宁愿放弃休息时间也要做的事情是什么？</li>
<li>成长；什么事情会让你沉浸其中忘记时间？不容易感到疲累和厌烦？</li>
<li>满足；过去工作和生活中，有什么让你获得巨大的成就感和满足感？</li>
</ul>
</li>
<li><p>围绕SIGN特质问他人</p>
</li>
<li><ul>
<li><p>你觉得我身上有什么不同于别人的特质？</p>
</li>
<li><p>你最欣赏或者佩服我的方面是什么？</p>
</li>
<li><p>在你看来，我做什么的时候最兴奋？</p>
</li>
<li><p>我做过什么让你印象深刻的事情么？</p>
</li>
<li><p>在以下方面，你觉得我那些更加擅长？</p>
</li>
<li><ul>
<li>思维方式；条理清晰，逻辑严密，脑洞很大，专注专业</li>
<li>沟通协调；化解冲突，争取资源，知人善用</li>
<li>计划执行；执行力强，强求完美，目标导向</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>四、三种方法，将知识内化成能力</strong></p>
<ul>
<li><p>惰性知识；不能及时有效调用，占用大脑内存的知识</p>
</li>
<li><p>如何把知识内化成能力，让自己的能力快速提升的三个方法</p>
</li>
<li><ul>
<li><p>1.掌握20%的核心；二八原则，一个领域的20%的核心内容，能够解决80%的问题</p>
</li>
<li><ul>
<li>如结构化思维20%的三个特征；主题鲜明，归类分明，逻辑递进。</li>
<li>擅长找师傅，找领域内专业人士，了解领域的核心20%</li>
</ul>
</li>
<li><p>2.知识和问题相互靠</p>
</li>
<li><ul>
<li><p>让知识和问题链接起来，知识向问题靠，问题向知识靠。</p>
</li>
<li><p>知识（想应用）问题；看到一个知识就去思考这个知识可以用来解决什么问题？</p>
</li>
<li><ul>
<li>如；马斯洛的五层次需求，可以用来分析奢侈品为什么这么贵？</li>
</ul>
</li>
<li><p>问题（找解释）知识，遇到问题，抛弃第一反应，去想想有什么方法论模型可以用</p>
</li>
<li><ul>
<li>看书遇到有趣的理论，先记下思考3个可以用该模型解决的问题。下次不要下意识反应，学会去翻一下以前的笔记，把问题补充到笔记里。</li>
</ul>
</li>
</ul>
</li>
<li><p>3.做系统化训练</p>
</li>
<li><ul>
<li>刻意练习；一个月中，显示每天练习三段式，再提炼主题，然后积累结构</li>
<li>我们的习惯，是高估几天的变化，而低估几个月的变化。</li>
</ul>
</li>
</ul>
</li>
<li><p>汇总；如何具体到行动中；</p>
</li>
<li><p>1.找专业人士了解领域的核心20%，先去学习20%</p>
</li>
<li><p>2.在学习的过程中，思考各个知识点的应用场景，并记录下来，遇到问题再回去找</p>
</li>
<li><p>3.能力提升是一个系统性过程，所以需要坚持至少1个月。</p>
</li>
</ul>
<p><strong>五、三大系统，让学习不靠意志力</strong></p>
<ul>
<li><p>为什么我们如此难坚持</p>
</li>
<li><ul>
<li>意志力是有限的，并不是学习这件事情类到你，而是“坚持”</li>
<li>移动互联网时代，诱惑越来越多</li>
<li>威尔海姆。霍夫曼主持的一项研究表明；人们醒着的时候，把大约1&#x2F;4的时间用来抵制欲望。</li>
</ul>
</li>
<li><p>意志力不够用，就用行为改变来学习。</p>
</li>
<li><ul>
<li>决定事情时起作用的大脑内部的两个系统；理性和感性。</li>
</ul>
</li>
<li><p>如何让我们坚持做一件事的三个关键因素；</p>
</li>
<li><ul>
<li><p>理性上；知道要学习（树立明确的目标）</p>
</li>
<li><ul>
<li>明确的目标是坚持学习的第一步</li>
</ul>
</li>
<li><p>感性上；愿意去学习（利用情绪冲动）</p>
</li>
<li><ul>
<li>截止日期的紧迫感</li>
<li>比较产生的焦虑感</li>
<li>鼓励带来的成就感</li>
</ul>
</li>
<li><p>情景上；制造适合学习的场景（创造学习环境）</p>
</li>
<li><ul>
<li>人是社会动物，我们会观察周围人的行为来调整自己的行为。</li>
<li>如果可以利用环境，就不要用你的意志力来抵制欲望</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>六、三个建议，让你不做“定制化人才”</strong></p>
<ul>
<li>1.调整主体，给自己定好发展方向</li>
<li>2.提升能力，让自己成为横向可迁移的人才</li>
<li>3.提升认知高度，让自己成为纵向可拓展的人才</li>
</ul>
<p>源引感谢：</p>
<blockquote><footer><strong>圈外同学——个人发展战略</strong><cite><a href="https://zhuanlan.zhihu.com/p/68267559">zhuanlan.zhihu.com/p/68267559</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>中美贸易战</title>
    <url>/2018/08/11/%E4%B8%AD%E7%BE%8E%E8%B4%B8%E6%98%93%E6%88%98/</url>
    <content><![CDATA[<p>  这段时间被“中美贸易战”的各种文章和声音吵得恶心，不知道为毛那么多喊麦式的文章后面还有那么多跟着喊麦的吃瓜群众，那么没有营养的内容一个个读的陶醉不已，不得不感叹现如今信息传播的可怕。我看了篇说实话的文章，结合着那篇文章我也在这儿发表发表比较粗犷的感言。</p>
<img src="/2018/08/11/%E4%B8%AD%E7%BE%8E%E8%B4%B8%E6%98%93%E6%88%98/01.jpg" class="" title="来源百度">

<p>醒醒吧，我其实搞不懂，中国人哪来那么深厚的底气，觉得自己哪哪都是牛x的，谁都干不过，后来经过中美贸易战这段时间，我大概知道，各种所谓的大V、自媒体、甚至所谓的官媒，都他么传递着各种鸡汤、各种所谓的正能量、各种吹嘘、各种爱国情怀、各种川普吓得尿裤子….。一遍又一遍一波又一波的洗脑着咱们老百姓，这种就是典型的误人子弟，害人害己，关键是老百姓也爱信也爱看啊。中兴那么明显的例子，大家都装作看不到。平时营收上百亿上千亿的企业，人就跟你断个芯片啥的，你就歇菜了，典型的外强中干，这应该让国人意识到，我们与美国在高新技术领域的差距还是比较明显的，当然如果再给个10来年，可能就赶上了，但是人美国不干啊，为什么这个时候弄你，因为他们顿悟了啊，发现被中国忽忽悠悠的就改革开放了40年，再不下手弄就真的弄不动了。</p>
<p>去看看中美的贸易额你就知道，很明显的中国对美国的依赖更强，如果真的继续干下去，大家都等着勒紧裤腰带过日子吧。继续干下去，受伤的都是老百姓。当然美国也会有损失但是相较而言，中国是更吃亏的。所以求那些所谓的各种扯淡大V之流，别他么再瞎歪歪挣流量了，坐下来静静的想想怎么让国人能对自己的国家有更准确的认知。我也希望我们老百姓能有时间看看一些国外的报道，以及国内有正经背景的经济学家、社会学家等发表的文章或者演讲、采访等，少他么花时间在抖音啊、今日头条等App上。</p>
<p>我之前看王煜全先生的一个采访，我觉得他说的挺有道理，主要内容是：中美贸易战实际就是你打我一拳我踢你一脚，如果不想办法解决问题，最后就会变成互殴，这样又受伤（受伤最多的还是老百姓）又解决不了问题。正确的解决方式是，找到问题的解决办法。为什么美国会出手，很明显是不满是抱怨中国不地道嘛，那咱们就坐下来好好谈谈，怎么滴能解他的怨气嘛。或者委婉点，川普不是代表工人阶级嘛，美国不是就是就业问题很严重吗，那咱们中国政府牵头推一批一批的企业去美国建厂提供就业嘛，我们就是在国外建的厂太少了，所以影响力太小，你想想如果我们在美国早早建立了很多企业，提供了大批就业，川普还敢通过现在的方式弄我们么？还没出手，估计国内就一波波游行示威了。别不信，中国很多企业是有能力在美国建厂的，只是缺少经验，同时缺少政府的支持。比如曹德旺先生就是比较成功的例子。</p>
<p>其实你看那小日本为啥那么恬不知耻的跟着美国，毫无节操，地地道道的狗腿子，因为人家知道美国能弄它，而且他禁不住弄。当然我们不需要像日本那样，而且也不会也不能像日本那样。我们有底气啊，有人，有地盘，有一大堆钱砸出来的黑哥们，有党，有钱，某些方面还是有技术的。所以不需要像日本一样。但是我们得有自己的认知，不天天一副<strong>无敌是多么寂寞</strong>的样子，老祖宗几千年传下来的，我们要谦虚，谦虚使人进步。</p>
<p><strong>本文纯属扯淡，随便看看。</strong></p>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
  </entry>
  <entry>
    <title>中间件到底该不该用</title>
    <url>/2019/03/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%B0%E5%BA%95%E8%AF%A5%E4%B8%8D%E8%AF%A5%E7%94%A8/</url>
    <content><![CDATA[<p>前几天，组织上让我参加了一下咱们产品系统架构评估方面的一个会议，虽然内容较少但是我受益颇多。主持人是刚进入没多久的架构师，议题是现系统架构中一个很大的问题：现有架构（没做集群，因为大多数情况下客户现场只会给到2台服务器）吃不下每秒15000条syslog（网络交易日志），问题在于我们加的中间件kafka。</p>
<p>所以最终议题为：什么时候需要中间件—即为什么我们要拿掉kafka。</p>
<p>架构师抛了这几个问题：</p>
<ol>
<li><p>解耦 怎么解？</p>
<blockquote>
<p>比如 redis 用于做数据的交换，这个数据是不能丢的。</p>
<p>比如kafka，不保证时间，不保证顺序性。。。</p>
</blockquote>
</li>
<li><p>如果去掉这个中间层（件）会怎样？</p>
</li>
</ol>
<p>特别是第二个问题，要随时问自己，如果去掉了会怎样？别盲目解读<strong>在我们领域，不是什么是加一层不能解决的</strong>这句话。</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>乔布斯</title>
    <url>/2018/08/09/%E4%B9%94%E5%B8%83%E6%96%AF/</url>
    <content><![CDATA[<p>前段时间读了《乔布斯传》这本书，一是因为好奇这个人，二是因为想了解下苹果的历史。不得不承认，苹果的产品应该是目前世界上最好用的产品之一，至少我是这么认为的。</p>
<img src="/2018/08/09/%E4%B9%94%E5%B8%83%E6%96%AF/001.jpeg" class="">


<p>这本书看的过程中其实会觉得有些无聊，不是说书不好，基本上都是源于个人的原因，一个可能是本身我不是乔布斯的信徒，再一个是因为看这本书会对我有一种局限，局限来源于从小到大接触的教育、社会环境、人文环境等有关，读了该书，我就有种感觉如果乔布斯或者是书中提及的与乔布斯有交集的一部分人，如果生在中国。我估计绝对会首先被贴上一个问题少年、怪胎等标签，然后遭受各种来自老师、同学、亲戚朋友等的白眼，大家根本不会看到或者不会在意他们身上的闪光点或者天赋，早就把他们扼杀的不能再扼杀了。当然这是我的个人见解不代表广大群众，下面简单的记录一下这本书带给我的感悟。</p>
<p><strong>拿取</strong></p>
<p>从书中能拿取到对我有启发的如下：</p>
<ol>
<li><p>专注</p>
<p> 乔帮主以及他招揽的那帮人，那种对自己所做的事的那种专注，真的是你从字里行间都能感受到强大的力量，专注到最后就是成功。所以你自己选择了你现在做的事，那就保持专注吧，至少你提高了成功的机率。</p>
<p> 这个点是我需要提升的，我只好码代码时最专注的，其它事情好像都容易走神，所以我现在都在自我训练。<br> 自己每天定个目标列表，必须完成，在有限的时间，你不专注根本完不成，完不成，你看到你的目标全是没划掉的那种感觉很憋屈。</p>
</li>
<li><p>现实扭曲立场</p>
<p> 说的通俗点我觉得是一种感染力、一种吸引力，他就像太阳一样，不但发光发热而且你不自觉的还得围绕着他转，他会让你相信他并跟着他干。其实在书中这个“现实扭曲立场”这个词语不一定就是褒义的，有的人就比较反感，因为他们有时候会感觉一种压迫感。我们事业部的ceo在我看来就是有点“现实扭曲立场”的感觉，总是自信并能感染人，给人一种力量。我希望今后我也能给人一种感染力和自信，那其实是挺美好的一件事。</p>
</li>
<li><p>简单</p>
<p> 这个对我们这行的来说，其实这个一直是我们的最大的追求，我们现在所做的一切努力都是为了让事情变得更简单，能更快响应外界的变化。乔帮主一直在追求这样一种极致的简，为此付出了多少人力物力都不管。所以很多时候面临问题时，你得想办法把他简单化，复杂化其实很简单但是最后很痛苦，简单化他很难但是很舒畅。</p>
<p> 特别是在我们工作中往往都会让问题变得越来越复杂化，其实我们停下来，静静思考一下，分析清楚利害关系，往往有个更简单的解法。</p>
</li>
<li><p>营销</p>
<p> 从书中你会发现其实乔帮主真的时一位营销专家或者叫产品推广专家，每次发布的产品，文案、发布会都会亲自参与，对产品你说他吹毛求疵都忍了，一个广告方案他也能吹毛求疵。当然最终的结果大家应该印象都很深，苹果的广告用美轮美奂、创意十足…等词语来形容都不过分。包括苹果的发布会的造势、发布会的主题、演讲内容、方式等都是精心设计的。所以每次苹果有新产品发布都是世界的一场大讨论，当然买那么好核心在于产品好，但是不得不说苹果那么有影响力有很大的一部分原因是因为推广的好。包括公司困难时他重新回来，为了挽救当时的苹果，他定的广告方案完全就唤起了大家对苹果的热情，所以你不得不服他在营销推广方面的实例，</p>
<p> 所以现在真没有酒香不怕巷子深了，好东西就是要秀出来，对待自己也是，老是抱怨自己默默无闻，那你想过没有如果你通过很多方式输出自己认为好的东西，并且帮助一些人，到时候你会发现你其实还是挺牛的（哈哈，当然前提是你自己得有实力），别觉得自我营销就是一个贬义词。</p>
</li>
<li><p>完美</p>
<p> 乔帮主一直追求——产品必须是科技和人文的完美融合。这种始终如一对完美的追求，才有了现在的苹果，但是在现在的社会好像追求完美变成了不太像褒义词的褒义词，总感觉如果说出这个词语马上就会有人给你怼回来。我觉得追求完美他就是一个褒义词，我们应该提倡，但是执着与完美可能就容易陷入痛苦。</p>
</li>
<li><p>坚持</p>
<p> 从书中你可以看到乔帮主有一种盲目的坚持，最大的体现就是在于他的癌症，很多人都讲，如果他不那么坚持对待工作而选择懈怠癌症这件事，可能结果没那么糟。所以我会这么认为：可能做到“坚持”和知道什么该坚持什么不该坚持相比较的话，做到坚持肯定更容易一点点，大家都知道力得用对。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>代码整洁之道</title>
    <url>/2022/06/06/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>断断续续的在看一本书《代码整洁之道》</p>
<p>记录一下我认为实用的点。</p>
<h3 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h3><ul>
<li>有意义的名称。</li>
<li>好搜索的名称，比如常量的命名。</li>
<li>可读出来的名称。</li>
</ul>
<p>可能会说这玩意还用说吗？这是基础的基础，一般情况下的命名我自认为做的挺好，但是看书之后我才发现我一个小毛病，就是习惯于把较长的命名给死命缩短（通常就是改变单词的缩写），感觉不缩短就难受。这样下来就有个问题。下一次再看代码的时候有时候会卡壳，忘了这个缩写是表示啥意思了。我这就是犯了上面的第三点“名称不可读”。</p>
<p>所以命名的前提是首先要能让人看懂，别整虚头巴脑的，一定要描述完整，当然有时候你发现你的命名需要装下好几个单词，得反过来再看看，是不是代码结构存在问题。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote>
<p>一个函数只做一件事，每个函数一个抽象层级（向下规则）。<br>函数要么做什么事，要么回答什么事，二则不可兼得。</p>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>抽离try&#x2F;catch代码块</li>
<li>使用异常替代错误码</li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>参数能少则少，至多三个，实在超出了三个用对象。</li>
<li>尽量不使用标识参数。比如Boolean isXXX。加了标识参数通常就代表函数最少也做了两件事，是方法变得复杂了起来。</li>
<li>应避免使用输出参数，通常情况下直接修改对象就行，不用再返回。</li>
</ul>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2019/08/27/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><a href="https://scotch.io/tutorials/understanding-scope-in-javascript#toc-lexical-scope">https://scotch.io/tutorials/understanding-scope-in-javascript#toc-lexical-scope</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>疫苗你妹</title>
    <url>/2018/07/24/%E4%BD%A0%E5%A6%B9/</url>
    <content><![CDATA[<p>兽爷的《疫苗之王》原篇。做个保留，作为一名小女孩的爸爸，仅以此文诅咒他么的长生生物之类的不良商家以及背后的各种势力各种任务，滚你妈的祖宗十八代。诅咒他们得癌症了发现能治，然后吃药发现吃的是假药，然后就只有等死。气死老子了，一想到自己女儿就气不打一处来。</p>
<img src="/2018/07/24/%E4%BD%A0%E5%A6%B9/yimiao01.jpg" class="" title="兽爷">

<img src="/2018/07/24/%E4%BD%A0%E5%A6%B9/yimiao02.jpg" class="" title="兽爷">

<img src="/2018/07/24/%E4%BD%A0%E5%A6%B9/yimiao03.jpg" class="" title="兽爷">

<img src="/2018/07/24/%E4%BD%A0%E5%A6%B9/yimiao.jpg" class="" title="兽爷">]]></content>
      <categories>
        <category>滚粗</category>
      </categories>
      <tags>
        <tag>诅咒</tag>
      </tags>
  </entry>
  <entry>
    <title>关键路径渲染</title>
    <url>/2021/07/21/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/</a></p>
<p><a href="https://classroom.udacity.com/courses/ud884/lessons/1469569174/concepts/15244185570923">https://classroom.udacity.com/courses/ud884/lessons/1469569174/concepts/15244185570923</a></p>
]]></content>
  </entry>
  <entry>
    <title>代码写的好看一点</title>
    <url>/2019/08/02/%E5%86%99%E7%9A%84%E5%A5%BD%E7%9C%8B%E4%B8%80%E7%82%B9/</url>
    <content><![CDATA[<p>当自己都觉得代码看起来不爽，或者不好读懂时 ，这块代码一定写的有问题。</p>
<p>在《Clean Code》一书中Bob大叔认为在代码阅读过程中人们说脏话的频率是衡量代码质量的唯一标准。</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>怎么写高效的css</title>
    <url>/2021/07/14/%E5%86%99%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84css/</url>
    <content><![CDATA[<p><a href="https://thenextweb.com/news/writing-efficient-css-understand-your-selectors">https://thenextweb.com/news/writing-efficient-css-understand-your-selectors</a><br><a href="https://programmerinnervoice.wordpress.com/2013/12/18/how-does-browser-read-css-selector/">https://programmerinnervoice.wordpress.com/2013/12/18/how-does-browser-read-css-selector/</a><br><a href="https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-leftt">https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-leftt</a></p>
<p>Don’t Use Inline-Styles</p>
<p>Avoid the !important tag</p>
<p><a href="https://www.freecodecamp.org/news/7-important-tips-for-writing-better-css/">https://www.freecodecamp.org/news/7-important-tips-for-writing-better-css/</a></p>
<p><a href="https://csswizardry.com/2011/09/writing-efficient-css-selectors/">https://csswizardry.com/2011/09/writing-efficient-css-selectors/</a></p>
<p><a href="https://www.youtube.com/watch?v=Qhaz36TZG5Y">https://www.youtube.com/watch?v=Qhaz36TZG5Y</a></p>
<p><a href="https://www.youtube.com/watch?v=iHEkRIF7zxI">https://www.youtube.com/watch?v=iHEkRIF7zxI</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>几个版本之后</title>
    <url>/2019/02/28/%E5%87%A0%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<p>发篇文章感慨一下，从去年4、5月份开始，产品线正式成立（刨去mvp时间），到现在10个多月，从0到1，经历了太多。两地跑，累计飞了8万多公里，150多个小时。经济舱你懂的，真的是坐飞机都坐吐那种…..</p>
<p>从0开始建立产品线团队，现在产品线大大小小五个团队：产线组、平台组、测试组、产品组、架构组以及管理团队。团队已经相对完善。</p>
<p>从0开始确立产品目标、产品受众、产品价值，产品版本从0.1&#x3D;&gt;0.2&#x3D;&gt;0.3&#x3D;&gt;0.3.3&#x3D;&gt;1.0&#x3D;&gt;1.1。产品的roadmap已经清晰。</p>
<p>当然这段过程走过来，发现了一些需要提升的地方，为了让产线更加阳光灿烂。</p>
<p><strong>年前大家做了下总结，确定了一下2019年的节奏。</strong></p>
<ol>
<li>严格按照产品roadmap进行产品的迭代。力保核心功能。</li>
<li>产品需求定义需更加清晰和严谨，必须有功能优先级，如果遇到无法自圆其说或者技术投入和产出存在较大差距的，应根据评估情况，决定做不做（由于产品上线的客户不是很多，对于某些需求不是很确定其价值，所以确立了这条规则）。功能不是越多越好。</li>
<li>技术选型的出口人只能是平台组负责人，平台负责人对技术选型负全责。</li>
<li>现有技术架构的优化、技术团队的工作流程优化、文档管理等由架构组负责，负责人为业务架构师。</li>
<li>产线组、平台组、测试组三个组合并进行重新（虚拟）划分，划分为虚拟团队的形式（业务功能小组，非功能需求小组、现场支持和研发目标承接小组）。每个组暂由Scrum Master负责日常工作管理。</li>
</ol>
<p>领导说了团队一直在用敏捷的方式再跑，但是还不够特别敏捷，今年会邀请Scrum中文网的创建人来继续对团队进行敏捷训练。找到适合团队的小步快跑方式。</p>
<p><em>一个团队是否有活力或者是否有能力，我觉得就是看团队目标是否对齐、管理团队是否足够开放、看团队是不是能自省、是否能自驱动、是否有立规矩。</em></p>
<p><strong>2019 会怎样谁知道呢？</strong></p>
<h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p><strong>虚拟团队为了解决什么问题？</strong></p>
<ol>
<li><pre><code>运转效率提升。围绕不同的目标，把相关的各职能的人员放到一个团队，解决大家之前反馈的沟通决策链过长效率低，团队优化跨组织推动麻烦等问题。
</code></pre>
</li>
<li><pre><code>保障非功能需求等长期目标。按照目标拆分团队，保障纳入产线规划的技术规划，持续有人去做。
</code></pre>
</li>
</ol>
<p><strong>虚拟团队的拆分原则是什么？</strong></p>
<p>根据产线规划目标，按照目标的耦合程度，把目标做拆分，由不同的小组去承接这些目标。根据各组的目标和个人发展诉求相结合，把不同的同事放在不同的小组。不同的周期，小组的组成会有适度调整</p>
<p><strong>都说了虚拟团队的设立是为了提升运转效率和更加敏捷的自优化，那么哪些事情我们可以自己做决定？</strong></p>
<p>一句话：不涉及约定目标定义调整、目标优先级调整、周目标是否能达成的事项，团队都可以先决定，再做向上和左右的同步。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离</title>
    <url>/2018/08/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>事业部去年年底开始推前后端分离，到现在我参与了前端，也参与了后端。一点心得体会说一说。</p>
<p>首先为什么要前后端分离，其实原因没那么复杂，比较简单就一条。</p>
<ol>
<li>试错，因为在这之前都是传统的研发，前后端不分家，至于是好还是不好，就不多说了，这个跟很多因素有关，比如客户场景、公司资源等等。既然有问题，所以就想试试新的玩法，看是否利大于弊。是否适合我们的公司和场景。</li>
</ol>
<p>当然肯定不是随随便便的试错，试错是带有愿景的。</p>
<ol>
<li>分流，清晰的职能划分，让大家更加专注，也给大家更多选择，当然还是尽量让专业的人做专业的事。</li>
<li>能跟上小步快跑的产品节奏，及时响应需求。</li>
<li>提升开发效率，并以此做好工程实践以及开发规范的落地。</li>
</ol>
<p>目前来看愿景是基本上都达到了，只是有待精进。我要说的是，前后端分离后跟我们带来的最大的问题，即前后端的边界问题，哪些是前端干的哪些是后端干的。扯皮就从这儿拉开了帷幕。</p>
<p>前后端分离后很多友爱温馨的画面就出现了。</p>
<pre><code>前端：这个字段能不能跟我处理一下.
后端：这个应该是前端干的，我不管。
前端：我顶你个肺，明明是后端处理更方便。
后端：我也顶你个肺，这个前端也能处理。
..........................

前端：这个数据能不能跟我转换一下.
后端：这个应该是前端干的，我不管。
前端：我顶你个肺，明明应该是后端处理。
后端：我也顶你个肺，这个明明是前端处理。
.................


后端：这个我这边不好处理，你多发一次请求自己组装吧。
前端：不应该是组装好了给我吗？
..........................
</code></pre>
<p>为什么会出现这样的局面，我认为究其原因就是前后端的边界不清晰，如果一开始没有一个前后端的《开发边界协议》，到后面就是各种甩锅的操作。前端抱怨后端，后端抱怨前端。慢慢的负能量。</p>
<p>我觉得边界的界定不是一刀切，应该是和公司文化、组织结构、业务场景等等契合的。在我们事业部，我认为可以从这些层面来作为划分边界的参考。</p>
<ul>
<li><p>业务场景：因为我们是做的APM，本身就是监控别人，这样的系统在客户那儿大概率就是个二线系统，那你就不能奢望客户能给你怎样怎样的资源，我们自己心里有数，要做到尽可能的少用客户的资源，并且要响应快速。</p>
</li>
<li><p>人员配置：高层领导基于各方面的考虑，没有专门招聘更多专业的前端，而是从后端研发里抽调几人到前端，边学边做。</p>
</li>
<li><p>前后端实现的复杂度。</p>
</li>
</ul>
<p>我们是这么做的，首先<strong>大</strong>的前提有两个：</p>
<ol>
<li>所有的API跟着详设走，所有的前后端交互接口录入RAP，参数结构、返回数据结构、业务响应码、异常信息都做好了同步。</li>
<li>原则上前端只负责解析数据，后端负责组装数据。前端倾向于呈现。* 前端着重处理用户体验相关的问题；后端则倾处于业务逻辑、数据处理和持久化等。在设计清晰的情况下，后端只需要以数据为中心对业务处理算法负责，并按约定为前端提供 API 接口；而前端使用这些接口对用户体验负责-<a href="https://my.oschina.net/jamesfancy/blog/1604237">https://my.oschina.net/jamesfancy/blog/1604237</a>*</li>
</ol>
<p>但是有了这些前提之后前后端还是存在公共地带，有些是前端可以做后端也可以做。比如字段值得转换，某些数据的补点或者聚合等等，我们都会具体情况参照上面《开发边界协议》进行权衡。</p>
<p>1.比如需要前端多发请求的肯定移到后端，通过后端的tcp代替前端的http。</p>
<p>2.前端如果需要改多个地方，而后端只需要加一段代码的能实现的，由后端做。</p>
<p>3.业务逻辑尽量放在后端，前端聚焦于交互和样式。</p>
<p>4.前端不做复杂的运算，尽可能让前端小而轻，哪怕后端重一点也无所谓，因为后端有太多方案变快，但是前端页面、样式等就是一套，轻就是轻，重就是重。</p>
<p>5.参照<strong>伯斯塔尔法则</strong>，后端尽量严谨保守给数据，减少前端解析数据的多样性，前端做好数据解析的校验，尽量开放接收数据，不理想化。</p>
<p><strong>其实说那么多，最重要的还是那句话，让专业的人做专业的事，让前端把大部分的精力都投入到交互、样式、以及优化上面。后端做好一切的兜底方案，前端要什么后端给什么就完了。</strong></p>
<p><strong>实际操作还是建议以前端为主导，因为前端是对用户负责。前端就像一个消息中心，研发阶段，対前连接产品、UCd、测试，对后对接后端服务提供方。所以前端主导后端兜底是比较合适的方案。</strong></p>
<h2 id="关键字解释"><a href="#关键字解释" class="headerlink" title="关键字解释"></a>关键字解释</h2><p><strong>伯斯塔尔法则</strong></p>
<p>源引：</p>
<blockquote><footer><strong>使用空列表，避免返回null</strong><cite><a href="http://janlay.com/blog/2013/always-use-empty-list-instead-of-null/">janlay.com/blog/2013/always-use-empty-list-instead-of-null</a></cite></footer></blockquote>










]]></content>
      <categories>
        <category>闲扯</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>通用工具类</title>
    <url>/2019/03/18/%E5%89%8D%E7%AB%AF-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>通用工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>前端埋点(一)</title>
    <url>/2020/04/28/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们是做NPMD工具的，但是对自身的产品本身确没有监控，说起来就很惆怅了，当然主要原因还是产品从0到1这个过程，前期放荡不羁的功能造作，导致对基础设施建设这块做的很少。</p>
<p>这是一贯坚持基础建设重要性的我的又一篇分享。关于前端埋点。</p>
<p>所以我当然承认基础建设是体系化的漫长的一个过程，但是因为各种不可抗因素，现没法体系化落地，所以只能先捡最能产生价值的且能引起更多不同之能的同事关注的事开始做，比如前端埋点。</p>
<p><strong>先说痛点：</strong></p>
<ol>
<li><p>整个质量体系监控缺失，前端报错后端报错，全靠经验、人肉日志和用户主动反馈。</p>
<blockquote>
<p>特别是现场问题排查，通常都会先找到前端定位问题，现场又不能远程。</p>
</blockquote>
</li>
<li><p>业务数据的效果无从跟踪。</p>
<blockquote>
<p>如使用某功能的频率无从得知，需要人肉从客户处拿此类数据，且还不准。</p>
</blockquote>
</li>
<li><p>用户的访问行为&#x2F;设备特征&#x2F;应用性能信息完全无感知。</p>
<blockquote>
<p>如活跃时间点(避开做升级)，软硬件系统和设备比例(做兼容)，慢页面优化等无从做起。</p>
</blockquote>
</li>
</ol>
<p><strong>前端埋点对我们产品的好处：</strong></p>
<ol>
<li><p>记录访问行为&#x2F;设备特征&#x2F;应用性能信息。</p>
<blockquote>
<p>为产品的设计，提供参考数据，对于我们这种从0到1的ToB产品，我个人觉得是特别需要这类用户反馈数据的，避免闭门造车。</p>
<p>为产品的优化（性能、产品设计…）提供参考。</p>
</blockquote>
</li>
<li><p>记录异常。</p>
<blockquote>
<p>便于问题的排查，我们处理的问题一般是客户现场问题，通常情况下又都是客户的内网，所以是无法远程的，这类异常记录手段刚好能丰富异常记录数据，便于问题的排查。</p>
</blockquote>
</li>
</ol>
<p>所以可以看出，前端埋点至少会影响的到产品、UCD、研发、测试，当利益方多的时候，事情才更有推下去的可能性。</p>
<h3 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h3><p>决策源于数据，而数据源于采集，采集源于规则梳理，让这一切发生源于工程师的创造力和执行力。</p>
<h4 id="埋点的方式"><a href="#埋点的方式" class="headerlink" title="埋点的方式"></a>埋点的方式</h4><ol>
<li><p>手动埋点</p>
<blockquote>
<p>手动代码埋点比较常见，即需要在采集数据的地方调用埋点的方法。</p>
<p>优点是流量可控，业务方可以根据需要在任意地点任意场景进行数据采集，采集信息也完全由业务方来控制。这样的有点也带来了一些弊端，需要业务方来写死方法，如果采集方案变了，业务方也需要重新修改代码，重新发布。</p>
<p>百度统计等第三方数据统计服务商大都采用这种方案；</p>
</blockquote>
</li>
<li><p>可视化埋点</p>
<blockquote>
<p>即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据。</p>
<p>优点业务方工作量少，缺点则是技术上推广和实现起来有点难（业务方前端代码规范是个大前提，比如唯一ID等）。</p>
<p> 代表方案是已经开源的<a href="https://github.com/mixpanel">Mixpanel</a>；</p>
</blockquote>
</li>
<li><p>“无痕埋点”</p>
<blockquote>
<p>无痕埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是前端只要加载埋点脚本。缺点是流量和采集的数据过于庞大，服务器性能压力山大，主流的 GrowingIO 就是这种实现方案。</p>
</blockquote>
</li>
</ol>
<p><strong>那我们产品现阶段比较适合的方式时什么呢？</strong></p>
<blockquote>
<p>手动代码埋点的方案，代码埋点虽然使用起来灵活，但是开发成本较高且对业务代码有强侵入性，并且一旦发布就很难修改，更何况我们这是部署在客户现场的。</p>
</blockquote>
<blockquote>
<p>可视化埋点也是不太可行的，我们连工程化、规范化都没做到，而且是部署在客户现场的，先天不足，再一个可视化埋点通常基于xpath的方式，只能读取页面上标签元素展示出来的属性，不能够获取上下文（通常内存里）的一些属性。而且页面的结构发生变化时，需重新标记操作。</p>
</blockquote>
<p>所以几乎只有考虑无痕埋点，虽然无痕埋点流量消耗和数据计算成本很高，但是因为我们是ToB运维工具，企业内部用的，使用人数也不多，所以也还好，当然这是第一版如果确实在实验局发现压力挺大，我们可以再改进一下，比如采用手动埋点+无痕埋点的方式或者三种结合的方式。</p>
<p>OK先把埋点方式定下来了，我们现在考虑剩下的东西。</p>
<h4 id="埋点需求整理原则"><a href="#埋点需求整理原则" class="headerlink" title="埋点需求整理原则"></a>埋点需求整理原则</h4><p>埋点不能乱埋，埋点的原则是基于一系列问题展开，并基于这些问题确定埋点需求，怎么确定埋点需求，可以照下面的问题切入进行梳理</p>
<p><strong>HOW：</strong></p>
<ul>
<li>怎样证明新功能效果？</li>
<li>需要哪些埋点？我们要采集什么内容，进行哪些采集接口的约定？</li>
<li>我该怎么埋这些点？</li>
<li>部分埋点的计算逻辑是什么？</li>
<li>数据结果怎么看？</li>
<li>通过什么方式来调用我们的采集脚本？</li>
<li>无埋点：考虑到数据量对于服务器的压力，我们需要对无埋点进行开关配置，可以配置进行哪些元素进行无埋点采集</li>
</ul>
<p><strong>WHO：</strong></p>
<ul>
<li>我的产品设计面对的用户群里是谁？</li>
<li>用户特征是什么？</li>
<li>这部分特征用户对功能预期的数据结果是什么？</li>
<li>用户习惯是什么？</li>
</ul>
<p><strong>WHAT：</strong></p>
<ul>
<li>产品包含哪几个模块？</li>
</ul>
<p><strong>WHERE：</strong></p>
<ul>
<li>新功能展示在产品端的哪个位置？</li>
<li>在哪些版本生效？</li>
<li>哪些功能的展示或作用在哪里需要跟服务端等交互？</li>
</ul>
<p><strong>WHEN：</strong></p>
<ul>
<li>功能是在用户场景什么时候调用产生？</li>
<li>调用过程中什么时候和服务端交互？</li>
<li>功能调用正常情况下需要大概需要多长时间？</li>
<li>什么情况会影响调用结果？</li>
<li>调用有风险的时候，是否需要加监测？</li>
</ul>
<hr>
<p>回答了上面的问题，基本上能知道埋点的意义在哪儿以及需要收集哪些数据等，接下来就得开始指定埋点规范了。</p>
<h4 id="埋点规范"><a href="#埋点规范" class="headerlink" title="埋点规范"></a>埋点规范</h4><p>埋点规范就跟编码规范一样，不按照规范就会有很大的隐患比如以下问题：</p>
<ol>
<li><p>埋点混乱</p>
</li>
<li><p>常常埋错，漏埋</p>
</li>
<li><p>业务变化后，老埋点数据失去意义</p>
</li>
<li><p>埋点数据无人使用，浪费资源</p>
</li>
<li><p>数据团队、研发团队、产品团队协作配合难度大</p>
</li>
<li><p>很多时候不太重视数据，而是重视业务的快速上线</p>
</li>
<li><p>埋点语义不明确，同一个按钮存在多种描述，不易检索</p>
</li>
<li><p>无用&#x2F;重复埋点太多，干扰了正常埋点数据</p>
</li>
<li><p>大量存量埋点Owner离职或者转岗，导致大量僵尸埋点信息</p>
<blockquote>
<p><em>所以为了避免以上问题我们需要建立一个好的规范，比如命名规范和流程规范。</em></p>
</blockquote>
<p><strong>埋点命名规范</strong></p>
<p>我们当前的做法是埋点名称只能是由字母、数字、下划线组成，并保证在应用内唯一，比如sw是展示，ck是点击。</p>
<p>常用规则的举例如下：<br>比如行为埋点：<code>&#123;团队|业务|角色&#125;_&#123;组件|页面&#125;_&#123;具体元素&#125;_&#123;动作&#125;</code><br>示例：<br>front_alarm_sw ： front代表项目，alarm代表功能，sw是展示，ck是点击<br>front_alarm1_detail_table_point_ck ：front代表项目，alarm1_detail代表功能，table组件，point小圆点组件，ck点击</p>
</li>
</ol>
<p><strong>埋点流程规范</strong></p>
<p>如果你发现每天有大量埋点错误反馈，并导致很多错误的分析结论，一个错误的分析结果还不如没有数据分析结果。造成这个问题的原因包括：</p>
<ol>
<li>前端埋点涉及复杂的交互，难以找准埋点位置；<ol start="2">
<li>埋点的验收流程不完善，没有经过测试和产品经理的测试和验收，验证不完备；</li>
</ol>
</li>
</ol>
<p>好的埋点需求应该和业务功能需求同等重要，也需要经历软件开发的整个生命周期，如果能严格按照一个规范的流程处理埋点，以上问题会得到更好的解决。</p>
<h4 id="规范内容"><a href="#规范内容" class="headerlink" title="规范内容"></a>规范内容</h4><p><strong>需求阶段：</strong></p>
<p>确定埋点信息，核心包括五方面信息：事件ID、埋点名称、埋点描述、埋点属性以及截图。</p>
<p><em>如何落地：</em></p>
<p>如果不按照规则和流程埋点将不会上报相关数据，制定强制规定。</p>
<p><em>开发什么功能：</em></p>
<p>埋点全文检索能力、自动找到重复埋点（语义相近或者数据相近）功能。</p>
<p><strong>开发阶段：</strong></p>
<p>务必和开发沟通，并让开发在完全理解业务语义的情况下，在前端按照埋点代码规范进行埋点。</p>
<p><em>如何落地：</em></p>
<p>静态代码检查。</p>
<p><em>开发什么功能：</em></p>
<p>开发探测每个埋点对应到的代码文件和代码行，开发根据人均事件量级进行监控报警功能。</p>
<p><strong>测试阶段：</strong></p>
<p>务必和测试沟通，并让测试在完全理解业务语义的情况下，通过CodeReview和埋点测试两种方式对埋点正确性进行验证。</p>
<p><em>如何落地：</em></p>
<p>规定如果未经测试的埋点不允许上报埋点数据。</p>
<p><em>开发什么功能：</em></p>
<p>提供所见即所得的埋点测试平台。</p>
<p><strong>验收阶段：</strong></p>
<p>确保相关人员在完全理解业务语义的情况下，可以通过与自比较和他比较的方式来进行验证。</p>
<p><em>举例：</em></p>
<ul>
<li>他比较验证：前端某业务点数量和对应服务端数据应该基本相当。</li>
</ul>
<p><em>如何落地：</em></p>
<p>规定如果未经验证的埋点不允许上报埋点数据。</p>
<p><em>开发什么功能：</em></p>
<p>提供埋点实时数据查询。</p>
<p><strong>清理阶段：</strong></p>
<p>确认完全理解语义的情况下，可对业务发生巨大变化或者不在维护的埋点进行废弃。</p>
<p><em>如何落地：</em></p>
<p>3个月以上未被使用的埋点、1个月以上数据为0的埋点自动废弃。3个月后使用次日会自动开启采集。</p>
<p><em>开发什么功能：</em></p>
<p>根据规则提供针对未使用埋点的计算、并自动废弃。</p>
<p>可以看出，规范要落地，需要整个公司的共识，也需要从上而下的压力，还有强势的制度。比如针对全公司个部门做评分，评分规则基于埋点和数据分析抽象出来。</p>
<hr>
<p>另外我们在前端埋点中也遇到过一些注意事项，整理如下，希望对大家有所帮助。</p>
<p><strong>注意事项：</strong></p>
<p><em>一些埋点安全性问题：</em></p>
<p>如果你使用普通的http 协议，在数据传输的过程存在被劫持(包括不限于：JS代码注入等)的可能性，造成H5页面中出现诸如：未知的广告或者原网页被重定向等问题。为了降低此类事件发生的可能性，建议最好使用https 协议（倡导全站https），以确保数据传输过程的完整性，安全性。</p>
<p><em>版本迭代的时候埋点需要注意什么？</em></p>
<ul>
<li>如果是公用模块，可以非常放心安全的全量迁移埋点；<ul>
<li>如果是新增模块，那就需要注意是否遵循了最新的埋点规范，有没有重复的埋点命名存在，埋点是否符合业务逻辑；</li>
<li>如果是下线模块，那就需要评估下线后对数据的影响范围，而且要第一时间充分周知相关方，让各方参与评估；</li>
<li>如果是更新模块，需要评估在原有埋点上需要修改的埋点内容，是否需要重新埋点，删除不需要的埋点，而且要修改功能的数据承接。</li>
</ul>
</li>
</ul>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><blockquote><footer><strong>前端埋点的那些事</strong><cite><a href="https://www.imooc.com/article/27151?block_id=tuijian_wz">www.imooc.com/article/27151?block_id=tuijian_wz</a></cite></footer></blockquote>

<blockquote><footer><strong>美团点评前端无痕埋点实践</strong><cite><a href="https://juejin.im/entry/58e8aa25a22b9d00589bd297">juejin.im/entry/58e8aa25a22b9d00589bd297</a></cite></footer></blockquote>

<blockquote><footer><strong>从零开始写一个前端数据埋点工具</strong><cite><a href="https://juejin.im/post/5d2c188651882547b2361bdf">juejin.im/post/5d2c188651882547b2361bdf</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习资料</title>
    <url>/2019/07/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p><a href="https://caniuse.com/">浏览器是否支持</a></p>
<p><a href="https://github.com/wesbos/beginner-javascript/">https://github.com/wesbos/beginner-javascript/</a></p>
<p><a href="https://javascript.info/">https://javascript.info/</a></p>
<p><a href="https://wesbos.com/javascript/01-the-basics/welcome">https://wesbos.com/javascript/01-the-basics/welcome</a></p>
<p><a href="https://www.freecodecamp.org/learn">https://www.freecodecamp.org/learn</a></p>
<p><a href="https://medium.com/@gordon_zhu/how-to-be-great-at-asking-questions-e37be04d0603">https://medium.com/@gordon_zhu/how-to-be-great-at-asking-questions-e37be04d0603</a></p>
<p><a href="https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/html-and-css-basics">https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/html-and-css-basics</a></p>
<p><a href="https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/html-and-css-basics">https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/html-and-css-basics</a></p>
<p><a href="https://github.com/zero-to-mastery/resources/blob/master/JavaScript.md">https://github.com/zero-to-mastery/resources/blob/master/JavaScript.md</a></p>
<p><a href="https://www.freecodecamp.org/news/a-beginners-javascript-study-plan-27f1d698ea5e/">https://www.freecodecamp.org/news/a-beginners-javascript-study-plan-27f1d698ea5e/</a></p>
<p><a href="https://github.com/WebHu/art-of-node">https://github.com/WebHu/art-of-node</a></p>
<p><a href="https://eloquentjavascript.net/">https://eloquentjavascript.net/</a></p>
<p><a href="https://every-layout.dev/layouts/stack/">https://every-layout.dev/layouts/stack/</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificityper.mozilla.org/zh-CN/docs/Web/CSS/Specificityocs/Web/CSS/Specificity">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificityper.mozilla.org/zh-CN/docs/Web/CSS/Specificityocs/Web/CSS/Specificity</a></p>
<p>about: <a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/iterate-with-javascript-while-loops">https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/iterate-with-javascript-while-loops</a> There’s a few lessons on different kinds of loops, is just the first.There’s also a section in The Odin Project on loops that you can check out: <a href="https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/fundamentals-part-4And">https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/fundamentals-part-4And</a> here’s a book on Javascript, but I’ll just include the link to the loop section: <a href="https://cdn.gomakethings.com/products/vanilla-js-pocket-guide-sample.pdf#__WKANCHOR_m">https://cdn.gomakethings.com/products/vanilla-js-pocket-guide-sample.pdf#__WKANCHOR_m</a> Aaaaand, finally, since you’re new to Javascript, here’s a giant list of places to learn all the things: <a href="https://github.com/zero-to-mastery/resources/blob/master/JavaScript.md">https://github.com/zero-to-mastery/resources/blob/master/JavaScript.md</a> (There a <strong>bunch</strong> of info there and not all of it is immediately necessary for you, so don’t let the length overwhelm ya!)</p>
<p>Best of luck! <a href="https://github.com/zero-to-mastery/resources/blob/master/JavaScript.md">JavaScript.md</a>**&lt;&#x2F;README.md&#x2F;|Back&gt;****Resources to Become a JavaScript Expert</p>
<p><strong>• <a href="https://www.w3schools.com/js/default.asp">W3Schools JavaScript Tutorial</a> Examples, and documentations, for those who are advanced, and beginners, to learn JavaScript.</strong></p>
<p>• <a href="https://medium.freecodecamp.org/a-beginners-javascript-study-plan-27f1d698ea5e">A JavaScript Curriculum</a>: A great curriculum for learning JavaScript from newbie to <a href="https://github.com/getify/You-Dont-Know-JS">You Don’t Know JS</a>.</p>
<p>• <a href="https://github.com/maxogden/art-of-node#the-art-of-node">The Art of Node</a>: Short introduction to Node that has some great information.</p>
<p>• <a href="https://eloquentjavascript.net/">Eloquent JavaScript</a>: Eloquent JavaScript goes beyond the cut-and-paste scripts of the recipe books and teaches you to write code that’s elegant and effective. You’ll start with the basics of programming, and learn to use variables, control structures, functions, and data structures. Then you’ll dive into the real JavaScript artistry: higher-order functions, closures, and object-oriented programming. Highly recommended.</p>
<p>• <a href="http://exploringjs.com/">Exploring JS: JavaScript books for programmers</a> by Dr. Axel Rauschmeyer: free online books that delve deep into the Javascript language - always up-to-date with new books on the latest Ecmascript features</p>
<p>• <a href="https://medium.com/@benastontweet/lesson-1a-the-history-of-javascript-8c1ce3bffb17">A brief history of JavaScript</a> by Ben Aston: It is a medium article describing and throwing light upon the History of JavaScript.</p>
<p>• <a href="https://www.freecodecamp.org/">FreeCodeCamp Beginning JavaScript</a>: Learn JavaScript with an online community, examples, and tons of more advanced JavaScript topics when you are done. Certificate available too. All free.</p>
<p>• <a href="https://github.com/getify/Functional-Light-JS">Functional Light JS</a>: Pragmatic, balanced Functional Programming in JavaScript.</p>
<p>• <a href="https://www.safaribooksonline.com/library/view/javascript-cookbook/9781449390211/">JavaScript Cookbook</a>: Why reinvent the wheel every time you run into a problem with JavaScript? This cookbook is chock-full of code recipes that address common programming tasks, as well as techniques for building web apps that work in any browser. Just copy and paste the code samples into your project—you’ll get the job done faster and learn more about JavaScript in the process.• <a href="http://jsforcats.com/">JavaScript For Cats</a>: An introduction for new programmers.</p>
<p>• <a href="https://www.codecademy.com/learn/introduction-to-javascript">JavaScript Fundamentals on Codecademy</a>: You will learn programming fundamentals and basic object-oriented concepts using the latest JavaScript syntax. The concepts covered in these lessons lay the foundation for using JavaScript in any environment.</p>
<p>• <a href="https://www.youtube.com/watch?v=ei2HLyHwt-k">JavaScript Fundamentals for Absolute Beginners</a>: A 7 hour long video with detailed explanations to give a strong foundation in JavaScript fundamentals. Taught by Bob Tabor, one of the most effective web development teachers.</p>
<p>• <a href="https://devchat.tv/js-jabber/">JavaScript Jabber</a>: A weekly podcast discussing the superb language JavaScript.• <a href="http://javascript.info/">JavaScript.Info</a>: How it’s done now. From the basics to advanced topics with simple with JavaScript, but detailed explanations.</p>
<p>• <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition">JavaScript: The Core</a>: This is a very solid foundation to work with, for anyone who might have struggled with the contexts and how arrow functions, local variables, and prototypes fit into the bigger picture. A quick introduction into the deeper ideas in JavaScript.</p>
<p>• <a href="https://javascript30.com/">JavaScript30</a>: A 30-day coding challenge in which you will build 30 things using vanilla JavaScript.</p>
<p>• <a href="https://jsfiddle.net/">JS Fiddle</a>: JSFiddle is an online community to test and collaborate JavaScript code snippets, known as ‘fiddles’. It also allows for simulated AJAX calls. It can also be used to test HTML &amp; CSS.</p>
<p>• <a href="http://book.mixu.net/node/">Mixu’s Node Book</a>: An online tutorial that received much praise for explaining Node.js in a well-structured way. It is a book that teaches you to write the code for Node.js and not only rely on third-party libraries. Anyone that wants to have a deep grasp of the Node.js framework will benefit from Mixu’s book.</p>
<p>**• <a href="https://watchandcode.com/p/practical-javascript">Practical JavaScript</a>: The excellent teachers at <strong>Watch and Code</strong> have released their beginning JavaScript course for free. If you haven’t been able to learn elsewhere, try this tutorial.</p>
<p>• <a href="https://stateofjs.com/">State of JavaScript</a>: An annual survey of over 20,000 JavaScript developers regarding the major JavaScript libraries, frameworks, languages, and other tools. A useful resource for understanding where the industry is headed and deciding what to learn next.</p>
<p>• <a href="https://github.com/getify/You-Dont-Know-JS">You Don’t Know JS</a>: No matter how much experience you have with JavaScript, odds are you don’t fully understand the language. These concise yet in-depth guides take you inside core concepts that can help you become a more efficient and effective JavaScript programmer. This is a series of books diving deep into the core mechanisms of the JavaScript language.</p>
<p>• <a href="https://edabit.com/challenges/javascript">Edabit JavaScript Challenges</a>: Learn JavaScript with real world, interactive challenges. Gain XP, unlock achievements and level up. It’s kind of like Duolingo for learning to code.</p>
<p>• <a href="https://www.jstips.co/">JS Tips - A JavaScript tip per day!</a>: JS Tips is a collection of useful daily JavaScript tips that will allow you to improve your code writing.</p>
<p>• <a href="https://www.udemy.com/course/the-complete-javascript-course/learn/lecture/10788532?start=0#overview">The Complete JavaScript Course 2020: Build Real Projects!</a> A comprehensive video course from beginner to mastery with real world projects.• <a href="http://superherojs.com/">Superhero.js</a>: This page is a collection of the best articles, videos and presentations related to JavaScript.</p>
<p>• <a href="http://www.asmarterwaytolearn.com/js/index-of-exercises.html">a smarter way to learn</a> : javascript exercises for beginners</p>
<p>• <a href="https://www.learn-js.org/">JavaScript for Complete Beginners - Interactive Tutorial</a>: A short interactive website which has exercises for introducing new programmers to the primary concepts in JavaScript.</p>
<p>• <a href="https://scrimba.com/learn/introtoes6">JavaScript ES6: Scrimba</a>: Learn JavaScript ES6 concepts with this short, interactive course at Scrimba. This includes interactive screencasts so you can learn along with the teacher. This is a pretty unique way of instruction.</p>
<p>• <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN Web Docs</a>: This provides different tutorials for JavaScript, resources and an explanation of the JavaScript.<strong>Advanced Javascript Articles</strong></p>
<p>• <a href="https://alligator.io/js/async-functions">Exploring Async&#x2F;Await Functions in JavaScript</a>: Async&#x2F;await functions, a new addition with ES2017 (ES8), help us even more in allowing us to write completely synchronous-looking code while performing asynchronous tasks behind the scenes.</p>
<p>• <a href="https://medium.com/@prashantramnyc/javascript-closures-simplified-d0d23fa06ba4">A simple guide to help you understand closures in JavaScript</a>: A closure is a function that has access to its outer function scope even after the return of the outer function (For better understanding head inside the blog).<strong>Tools, Frameworks, and Libraries</strong></p>
<p>• <a href="https://sdras.github.io/array-explorer/">JavaScript Array Explorer</a>: Find the array method you need for your JavaScript array without digging through the docs. A useful resource that can make using arrays easier.</p>
<p>• <a href="https://sdras.github.io/object-explorer/">Javascript Object Explorer</a>: The same tool for objects.</p>
<p>• <a href="https://medium.com/@uistephen/style-guides-for-linting-ecmascript-2015-eslint-common-google-airbnb-6c25fd3dff0">Linting ES2015+ — ESLint with StyleGuides: Google, AirBnB, Common</a>: An excellent breakdown of linting’s purpose and history while also g…</p>
<p><a href="https://animista.net/">css动画</a></p>
<p><a href="https://openhome.cc/eGossip/JavaScript/Event.html">https://openhome.cc/eGossip/JavaScript/Event.html</a></p>
<p><a href="https://www.w3.org/TR/WD-DOM-Level-2/events.html">https://www.w3.org/TR/WD-DOM-Level-2/events.html</a></p>
<p><a href="https://www.quirksmode.org/js/events_early.html">https://www.quirksmode.org/js/events_early.html</a></p>
<p><a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a></p>
<p><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">https://www.w3.org/TR/DOM-Level-3-Events/#event-flow</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/2020/07/30/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们的产品通常进入客户现场之前都会有一系列的安全扫描（公司级的、客户级的），去年我们团队就解决了好几个安全问题，不过通常都是后端的方式来解决，但其实某些安全问题前端也能解，有些问题前端解更合适，这不借着重新出发的春风，往前端工程化中加了一步<strong>安全</strong>。</p>
<p>此篇文章收获颇多。<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjY3OTgwMA==&mid=2652469355&idx=1&sn=fd1a47ea216beae53f5d807c21186566&chksm=bd4f4a7c8a38c36a116a659c10e08367b217448a24752ac677e378cad1b9e1cf9b2d6705e113&mpshare=1&scene=1&srcid=0717EknGxzkoHpNBlCIP6O4G&sharer_sharetime=1594989878682&sharer_shareid=77df2eafd0a472623696abf038541666&version=3.0.25.2103&platform=win&rd2werd=1#wechat_redirect">WEB前端安全自查和加固</a></p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h5 id="对于安全方面的共识"><a href="#对于安全方面的共识" class="headerlink" title="对于安全方面的共识"></a>对于安全方面的共识</h5><ol>
<li>对于第三方包的引入，必须经过<code>npm audit+snyk</code>安全扫描后且经过小组内评审通过后方才能引入。</li>
<li>对于我们自己发布的包，必须去掉敏感信息。</li>
<li>每次更新了package.json之后都需要进行安全扫描。</li>
</ol>
<p>如下图，是我们项目里我用<strong>snyk</strong>执行扫描之后报出问题的包信息。</p>
<img src="/2020/07/30/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/image-20200730110550740.png" class="">

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>后续会把考虑把该步骤拿到流水线里去做，因为虽然大家意识层面共识了，落地的时候可能还是会有各种遗漏，所以干脆直接交给机器来做。</p>
<p>安全无小事，先动起来！</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端小总结一下</title>
    <url>/2019/02/24/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>最近前后端都在写，而且相对来说前端写的多一些，因为领导说了，咱们这条产线实行前后端分离策略，但是团队里不再招专业前端，那xxx你先上，你不是常说你是一块砖吗，哪里需要哪里搬。是的，xxx就是我，所以朋友们在公司切记谨言慎行。当然主要还是我觉得了解下前端还是可以的（但是打死不写css）。</p>
<p>所以我就从一个后端干到了前端，当然团队里肯定是有专业得前端的，不过因为咱们事业部有几条产线，所以资源稍有紧张，给到咱们产线就两个前端，有一个只会css，css肯定得有得，不然你想想啊，就算领导放心让你写css，你也肝颤啊。so，我就从产品mvp开始到正式产品立项，就主要精力在前端。</p>
<h2 id="一入前端深似海啊"><a href="#一入前端深似海啊" class="headerlink" title="一入前端深似海啊"></a>一入前端深似海啊</h2><img src="/2019/02/24/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/gratisography-sad-bunny-thumbnail.jpg" class="" title="from gratisography">

<p>前段的东西太多，而且层出不穷。抵御诱惑的最好办法是什么？我觉得是先仔细想想需不需它，当不确定时，先放着不着急做决定，只要坚定自己所要的东西，什么诱惑对你都是过眼云烟。</p>
<p>脚手架的选择就出现了两派，一派以我为首，崇尚拿来即用避免重复造轮子，一派以专业前端同学为首，崇尚自己搭一套脚手架。具体就不细说，反正双方谁也说服不了谁。最终领导说了，谁是主要负责人谁说了算，当然专业前端是主要负责人，所以最终就决定自己搭建脚手架。当然这个过程是很痛苦的，时间也很长…曾今一度放弃这个方案，但是想着已经花了那么多精力了，就咬咬牙继续整了。最终大概前前后后花了3-4个月时间才算稳定了，当然这个过程编码还是断断继续在进行的。</p>
<p>所以这块主要说下webpack，现在的前端打包工具我估计没谁说不用webpack吧，webpack教程我就不恬不知耻的讲了，网上一堆。不过我还是觉得大家尽量系统的看教程，别东一块西一块凑。</p>
<h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p>对于<strong>webpack</strong>打包工具，涉及到性能，我认为的三个关注点：</p>
<ol>
<li><p>包大小</p>
<p> <em>主要是从压缩、去重（注意依赖公共部分单独打包）方面考虑，能从现有的配置解决的就不要引入新的插件，用了插件需要在官方了解每个数的意义。</em></p>
<p> <em>项目中：js压缩用的UglifyJsPlugin，第三方库处理我们用的是CommonsChunkPlugin（有人说DllPlugin更好用），后面会抽时间试下。</em></p>
</li>
<li><p>包拆分</p>
<p> <em>打包时，注意包的拆分，按模块按页面，可以分得细一些，让页面按需加载…，别都打到一个包里，一开始我们就遇到这个问题，打开一个页面光渲染所需的内容就要下载半天。</em></p>
</li>
<li><p>打包速度</p>
<p> <em>能用缓存的用缓存，不需要转译的就别转译，Happypack能多进程执行打包，会快点</em></p>
<p> <em>有两个很漂亮的可视化插件，*<em>JARVIS、webpack-bundle-analyzer</em></em> ，对于优化打包很有用。*</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>前端选型一定要适合团队和自己业务发展的。其它人觉得好用，你得看看其它人的场景和公司的体量。</p>
</li>
<li><p>没有特别与众不同的要求或者很多的个性化，避免重复造轮子。</p>
</li>
<li><p>当资源有限的时候，先保证功能性，再保证性能，但是性能优化一定是一个长期的非功能需求。</p>
</li>
</ul>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>没什么好说的……，都是主流的</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/2019/11/04/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>过去一年多的时间，整个产品是从0到1的，整个前端团队也几乎是从0到1（大多都是后端转的前端），被产品迭代的车路推动，滚滚向前，处于野蛮生长的阶段。最近产品大体进入了一个思考过去未来的阶段，相对较平缓。可以有喘息的时间干点想干的事情了。</p>
<p>你知道的，干一行爱一行，既然在前端了就想着咋个把它做的更好，因为以前做后端，后端的工程化的工具箱（CI、CD、监控…有一大堆实践）是很成熟的也较容易搭建起来，不过前端相对就很陌生了，据说也没那么容易。</p>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>刚好关注了【前端早早聊】，发现里面有这部分的内容，盗了两张图，让我对前端工程化有了很宽的认识，做个记录，后续慢慢实践。</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/1.jpeg" class="前端早早聊大会">

<img src="/2019/11/04/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2.png" class="前端早早聊大会">

<p><code>本文引用的图片，如有侵权请联系我删除。</code></p>
<blockquote><footer><strong>前端早早聊大会</strong><cite><a href="https://www.yuque.com/zaotalk/road/gn7l3z">www.yuque.com/zaotalk/road/gn7l3z</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端测试</title>
    <url>/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>其实老早以前就想在产品中引入单元测试，领导也让我好好做一个分享主题，分享好做花功夫就行，但是我觉得此主题的分享最终目的是为了落地，所以需要一个契机，不然大家听了就完了也没啥x用。</p>
<p>刚好大佬们上个月做了个决定，决定从前到后整体重新架构，重新梳理，做一个带中台属性的系统，从而是产品能有更多平台能力，也能更好的和另外的产线想结合。当然我说的比较云淡风轻的，干起来你才知道这是一个多么有挑战的目标，扯远了，下面说说前端测试这块的内容。</p>
<h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p>基础组件：antd、next等提供的组件。</p>
<p>通用组件：咱们系统中抽取出来的组件公用的组件（完全自定义的以及基于基础组件改造的）&#x3D;&gt;<strong>单元测试</strong>（UI测试可选）</p>
<p>业务组件：通过基础组件、通用组件等组合起来的组件（区块）&#x3D;&gt;<strong>单元测试、集成测试</strong>（UI测试可选）</p>
<h3 id="为什么需要测试？"><a href="#为什么需要测试？" class="headerlink" title="为什么需要测试？"></a>为什么需要测试？</h3><ul>
<li>提高代码质量</li>
<li>倒逼开发对编码的设计更加低耦合以及合理，方便后续的迭代&#x2F;重构</li>
<li>最大程度保证产品符合预期（因为各种场景都测试）</li>
<li>减少测试的投入（比如回归）</li>
<li>提升开发的信心（bug少）</li>
</ul>
<h3 id="前端测试的类型"><a href="#前端测试的类型" class="headerlink" title="前端测试的类型"></a>前端测试的类型</h3><p><strong>单元测试（Unit Test）</strong>、<strong>集成测试（Integration Test）</strong>、<strong>UI 测试（UI Test）</strong></p>
<h5 id="单元测试应用："><a href="#单元测试应用：" class="headerlink" title="单元测试应用："></a>单元测试应用：</h5><ul>
<li><p>代码中多个组件共用的工具类库、多个组件共用的子组件等。</p>
</li>
<li><p>能进行单元测试的函数&#x2F;组件，一定是低耦合的，这也从一定程度上保证了我们的代码质量。</p>
<p>比如我们的<strong>工具库、组件库</strong>这类通用低耦合的内容就比较适用单元测试。</p>
</li>
</ul>
<p><em>「通常情况下，在公共函数&#x2F;组件中一定要有单元测试来保证代码能够正常工作。单元测试也应该是项目中数量最多、覆盖率最高的。」</em></p>
<h5 id="集成测试应用："><a href="#集成测试应用：" class="headerlink" title="集成测试应用："></a>集成测试应用：</h5><ul>
<li>耦合度较高的函数&#x2F;组件、经过二次封装的函数&#x2F;组件、多个函数&#x2F;组件组合而成的函数&#x2F;组件等。</li>
<li>集成测试的目的在于，测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期。</li>
</ul>
<p><em>「集成测试是安全感较高的测试，能很大程度提升开发者的信心，集成测试用例设计合理且测试都通过能够很大程度保证产品符合预期。」</em></p>
<h5 id="UI测试应用："><a href="#UI测试应用：" class="headerlink" title="UI测试应用："></a>UI测试应用：</h5><p>先做个说明，大家不要把UI 测试（UI Test）和端到端测试（E2E Test）混为一谈，认为是同一个测试类型。</p>
<p>事实上，UI 测试（UI Test）和端到端测试（E2E Test）是稍有区别的：</p>
<blockquote>
<p>UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。</p>
<p>端到端测试（E2E Test）则是将整个应用放到真实的环境中运行，包括数据在内也是需要使用真实的。</p>
</blockquote>
<p>就前端而言，UI 测试（UI Test）更贴近于我们的开发流程。在前后端分离的开发模式中，前端开发通常会使用到 Mock 的服务器和数据。因而我们需要在开发基本完成后进行相应的 UI 测试（UI Test）。</p>
<p>可以理解为交付测试之前的自测阶段我们做的就是UI测试。而测试做的就是<strong>端到端</strong>测试。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><strong>此篇介绍的是单元测试的应用。</strong></p>
<p>先简单画下边界，此篇只说明基于<code>工具库、组件库</code>的分享示例。高耦合的组件或者自动化测试应用不在此次讨论范围内。</p>
<h4 id="选择何种测试思想"><a href="#选择何种测试思想" class="headerlink" title="选择何种测试思想"></a>选择何种测试思想</h4><p>其实本不用做这个说明，因为其实我们已经选好了（BDD）。</p>
<p>但是避免有像我一样懵懂的同学，所以这儿咱们也简单说明一下。因为测试框架对不同规范的支持可能不一样。所以我们先搞明白测试思想有哪些？</p>
<p><a href="https://en.wikipedia.org/wiki/Test-driven_development">测试驱动开发（TDD）</a>和<a href="https://en.wikipedia.org/wiki/Behavior-driven_development">行为驱动开发（BDD）</a>。</p>
<img src="/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/TDD.png" class="">



<p><strong>TDD</strong>是一种开发技术，更多地侧重于功能的实现。</p>
<blockquote>
<p>TDD代表测试驱动开发。 在这种软件开发技术中，我们首先创建测试用例，然后编写这些测试用例的基础代码。 尽管TDD是一种开发技术，但它也可以用于自动化测试开发。</p>
<p>实施TDD的团队需要花费更多的时间进行开发，但是，他们发现的缺陷很少。 <strong>TDD可以提高代码质量</strong>，并提高代码的可重用性和灵活性。</p>
<p>TDD还有助于实现大约90-100％的高测试覆盖率。 对于遵循TDD的开发人员而言，最具挑战性的事情是在编写代码之前先编写测试用例。</p>
</blockquote>
<p><strong>BDD</strong>是一种专注于系统行为的开发技术。</p>
<blockquote>
<p>BDD是TDD的扩展，<strong>它不是编写测试用例，而是从编写行为开始</strong>。 后来，我们开发了应用程序执行该行为所需的代码。</p>
<p>BDD方法中定义的<em>方案使开发人员，测试人员和业务用户易于协作</em>。</p>
<p>当涉及自动测试时，BDD被认为是最佳实践，因为它专注于应用程序的行为，而不是考虑代码的实现。</p>
<p>应用程序的行为是BDD的关注重点，它迫使开发人员和测试人员去了解产品以及用户。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">TDD</th>
<th align="left">BDD</th>
</tr>
</thead>
<tbody><tr>
<td align="left">该过程从编写测试用例开始。</td>
<td align="left">该过程从编写测试用例开始。</td>
</tr>
<tr>
<td align="left">TDD专注于功能的实现方式。</td>
<td align="left">BDD专注于最终用户的应用程序行为。</td>
</tr>
<tr>
<td align="left">测试用例是用编程语言编写的。</td>
<td align="left">与TDD相比，场景以简单的Given、When、Then关键字编写，因此更具可读性。</td>
</tr>
<tr>
<td align="left">应用程序功能的变化对TDD中的测试用例有很大影响。</td>
<td align="left">BDD方案基本不受功能更改的影响。</td>
</tr>
<tr>
<td align="left">仅在开发人员之间需要协作。</td>
<td align="left">所有利益相关者之间都需要合作。</td>
</tr>
<tr>
<td align="left">只有具有编程知识的人才能理解TDD中的测试。</td>
<td align="left">任何人都可以理解BDD中的测试，包括那些没有任何编程知识的人。</td>
</tr>
<tr>
<td align="left">TDD降低了测试中出现错误的可能性。</td>
<td align="left">与TDD相比，测试中的错误很难跟踪。</td>
</tr>
</tbody></table>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>我简单总结下大家有个简单的概念，具体有兴趣大家再下去查资料。</p>
<p><strong>TDD</strong>主体是开发，说白了就是测试用例也是开发来写，先写测试用例，很显然测试用例肯定都过不了因为还没编码，那怎么办呢，就通过编码的方式不断的丰富功能然后再回去跑测试用例，如此循环最终达到所有测试用例都通过。比较适用后端API的测试。</p>
<p><strong>BDD</strong>没有主体，因为所有人都需要参与（测试、开发、产品），大家用同一套语言来理解产品的功能和用户行为，大家的思考角度会更侧重用户方。比较适用前端测试的场景，因为前端是直接面对用户的。</p>
<p><em>Jest用的断言库就是BDD的思维。eg：expect(wrapper.find(‘.bar’)).toHaveLength(3);一品就是given、when、then的路数</em></p>
<h4 id="找测试框架"><a href="#找测试框架" class="headerlink" title="找测试框架"></a>找测试框架</h4><p><strong>诉求</strong></p>
<ol>
<li>能跑JavaScript也能跑React。</li>
<li>最好能开箱即用，不需要做很多配置。</li>
<li>社区生态良好，能及时支持新特性且能及时响应issue。</li>
</ol>
<h4 id="Jest、Enzyme"><a href="#Jest、Enzyme" class="headerlink" title="Jest、Enzyme"></a>Jest、Enzyme</h4><blockquote>
<p><strong>Jest：</strong></p>
<p>其实测试框架茫茫多，最终选择它的原因就是其完美匹配上诉的所有诉求，Facebook亲生的，star 接近32K，React不用说了，同时也能跑JavaScript。另外Jest还具备Mock等能力，所以Jest不仅仅是个测试框架而且还是一个集合多种能力的结合体，开箱即用。</p>
</blockquote>
<blockquote>
<p><strong>Enzyme:</strong></p>
<p>用于测试的React工具库,可看作是一个集成测试框架，与Jest组合也是备受推崇的。它提供获取元素的能力。</p>
<p>Enzyme渲染一个或多个组件，以及查找元素以及与元素进行交互的能力，触发事件处理程序等能力。</p>
</blockquote>
<p><strong>首先任何框架都有优点和缺点，那为什么选这两个呢：</strong></p>
<ol>
<li>ice用的就是这两个，有大厂（阿里）的前面探路，对于我们没有经验的团队来说作为第一次的试水我觉得跟风不是一个贬义词。</li>
<li>基于我们的诉求我也做了一下简单的调研，因为我们主要还是以React为主所以选择Jest是自然而然的过程，另外Enzyme+Jest也是国内外热度都比较高的，两则的社区也比较活跃，所以很显然两者搭配是没有问题的，刚好ice就是用的这两个所以没什么好纠结的。</li>
</ol>
<p>Enzyme只是提供了额外的能力对React组件进行测试，不用Enzyme只用Jest可测试，但是只有Enzyme则不能测试，Enzyme是在测试框架上能力的扩展。</p>
<ul>
<li><strong>Jest主要提供测试框架（提供测试需要的所有能力）</strong></li>
<li><strong>Enzyme（React测试工具库）基于Jest等测试框架增加DOM操作的能力，提供了强大的 API 能力支持 UI 交互测试</strong></li>
</ul>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install jest</span><br><span class="line">npm install babel-plugin-transform-class-properties --save-dev</span><br><span class="line">npm install react-test-renderer</span><br></pre></td></tr></table></figure>

<p><strong>修改根目录下.babelrc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;],</span><br><span class="line">	&quot;plugins&quot;: [&quot;@babel/plugin-syntax-jsx&quot;,&quot;transform-class-properties&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h4><p><a href="https://www.bookstack.cn/read/ice-0.x/dev-test.md">icejs测试</a></p>
<p><a href="https://github.com/jest-community">jest-community</a>&#x2F;<strong><a href="https://github.com/jest-community/awesome-jest">awesome-jest</a></strong></p>
<p>提供了很多能力，增强测试的体验。</p>
<p>以下几个是比较有代表性的</p>
<ul>
<li><a href="https://github.com/jest-community/vscode-jest">vscode-jest</a>，vscode jest插件</li>
<li><a href="https://github.com/jest-community/jest-extended">jest-extended</a>，提供结果判断的扩展</li>
<li><a href="https://github.com/jest-community/eslint-plugin-jest">eslint-plugin-jest</a></li>
<li><a href="https://github.com/jest-community/awesome-jest">awesome-jest</a>，跟jest相关的所有第三方库列表</li>
</ul>
<h4 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h4><p>Jest使用 Snapshot 进行 UI 测试</p>
<p>Snapshot 测试是 Jest 提供的能力，可以自动生成组件 UI 输出的描述文件，确保你的 UI 不会发生意外的改变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更新快照</span><br><span class="line">jest --updateSnapshot</span><br></pre></td></tr></table></figure>

<p>组件实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import React from &quot;react&quot;;</span><br><span class="line">import &#123; Card, Button &#125; from &quot;@alifd/next&quot;;</span><br><span class="line"></span><br><span class="line">const RCard = (props) =&gt; &#123;</span><br><span class="line">  const &#123; title, subTitle, content, deleteFunc &#125; = props;</span><br><span class="line">  const commonProps = &#123;</span><br><span class="line">    subTitle: subTitle || &quot;&quot;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Card free style=&#123;&#123; width: 300 &#125;&#125;&gt;</span><br><span class="line">        &lt;Card.Header title=&#123;title || &quot;&quot;&#125; &#123;...commonProps&#125; /&gt;</span><br><span class="line">        &lt;Card.Content&gt;&#123;content || &quot;&quot;&#125;&lt;/Card.Content&gt;</span><br><span class="line">        &lt;Card.Actions&gt;</span><br><span class="line">          &lt;Button type=&quot;primary&quot; onClick=&#123;deleteFunc || null&#125;&gt;</span><br><span class="line">            删除</span><br><span class="line">          &lt;/Button&gt;</span><br><span class="line">        &lt;/Card.Actions&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default RCard;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import renderer from &#x27;react-test-renderer&#x27;</span><br><span class="line">import RCard from &#x27;../../../src/components/Card/index&#x27;</span><br><span class="line">import &#123; shallow &#125; from &#x27;enzyme&#x27;</span><br><span class="line"></span><br><span class="line">const props = &#123;</span><br><span class="line">    title: &#x27;firstRCard&#x27;,</span><br><span class="line">    subTitle: &#x27;测试&#x27;,</span><br><span class="line">    content: &#x27;这是第一个测试demo&#x27;,</span><br><span class="line">    deleteFunc: jest.fn((e) =&gt; &#123;</span><br><span class="line">        // throw &#x27;error&#x27;</span><br><span class="line">        return &#x27;OK&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UI快照测试</span><br><span class="line">test(&#x27;jest renders Snapshot&#x27;, () =&gt; &#123;</span><br><span class="line">    const tree = renderer.create(&lt;RCard &#123;...props&#125; /&gt;).toJSON()</span><br><span class="line">    expect(tree).toMatchSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在第一次运行后，Jest Snapshot 将会生成对应的 <code>.snap</code> 文件。</p>
<img src="/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/snapshot.png" class="">

<p>对于一个React组件而言， 传入相同的props，我们是期望得到相同的输出，所以后续如果组件的输出内容发生变更，则会导致测试用例无法通过。</p>
<p><strong>ice结合 Jest CLI参数</strong></p>
<p>–watch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg：&quot;test&quot;: &quot;icejs test --jest-watch&quot;,</span><br></pre></td></tr></table></figure>

<p>监视文件是否有更改，并重新运行与已更改文件相关的测试。 如果要在文件更改后重新运行所有测试，请改用–watchAll选项。</p>
<p>–watchAll</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg：&quot;test&quot;: &quot;icejs test --jest-watchAll&quot;,</span><br></pre></td></tr></table></figure>

<p>监视文件中的更改，并在发生更改时重新运行所有测试。 如果只想重新运行依赖于已更改文件的测试，请使用–watch选项。</p>
<p><strong>也可单独运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&quot;coverage&quot;: &quot;jest --colors --coverage&quot;,</span><br><span class="line">&quot;test&quot;: &quot;jest --watch&quot;,</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><strong>vscode插件</strong></p>
<ul>
<li><p>jest</p>
</li>
<li><p>jest runner</p>
</li>
</ul>
<p><strong>编辑根目录下的jest.config.js</strong></p>
<p>使其支持jsx、es6等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	verbose: true,</span><br><span class="line">	roots: [&#x27;&lt;rootDir&gt;/src/&#x27;, &#x27;&lt;rootDir&gt;/test/&#x27;],</span><br><span class="line">	testMatch: [&#x27;&lt;rootDir&gt;/test/**/*.js&#x27;],</span><br><span class="line">	setupFilesAfterEnv: [&#x27;&lt;rootDir&gt;/src/setupTests.js&#x27;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Jest具体的概念说明看<a href="/2020/07/13/Jest/" title="Jest">Jest</a>。</p>
<p><a href="https://jestjs.io/docs/en/expect">expect</a>，各种断言。</p>
<p>随便看几个实例</p>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><img src="/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/1.png" class="" title="from Hello FE">

<p><strong>Jest生命周期钩子：</strong></p>
<img src="/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/2.png" class="" title="from Hello FE">

<p><strong>异步代码测试</strong></p>
<img src="/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/3.png" class="" title="from Hello FE">



<h3 id="使用-Enzyme-测试组件"><a href="#使用-Enzyme-测试组件" class="headerlink" title="使用 Enzyme 测试组件"></a>使用 Enzyme 测试组件</h3><p><a href="https://enzymejs.github.io/enzyme/">Enzyme</a> 是 Airbnb 提供的测试类库，它提供了一套简洁强大的 API。能够灵活操作 DOM，是 React 社区推荐的测试方案。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装测试相关依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev enzyme enzyme-adapter-react-16 react-test-renderer</span><br></pre></td></tr></table></figure>

<p>基于 React 开发的测试，需要安装对应的 React Adapter 来保证 enzyme 渲染的版本和项目中使用的版本一致，以 react 16 版本为例，需要进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; configure &#125; from &#x27;enzyme&#x27;;</span><br><span class="line">import Adapter from &#x27;enzyme-adapter-react-16&#x27;;</span><br><span class="line">configure(&#123; adapter: new Adapter() &#125;);</span><br></pre></td></tr></table></figure>

<p>如果不想每个测试用例都去定义一遍，可以将上述内容保存至 <code>src/setupTests.js</code> 文件中，并自定义 Jest 配置中的 <code>setupFilesAfterEnv</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// jest.config.js</span><br><span class="line">module.exports = &#123;  setupFilesAfterEnv: [&#x27;&lt;rootDir&gt;/src/setupTests.js&#x27;],&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Mount-Shallow-Render"><a href="#Mount-Shallow-Render" class="headerlink" title="Mount, Shallow, Render"></a>Mount, Shallow, Render</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mount, shallow, render &#125; from ‘enzyme&#x27;;</span><br></pre></td></tr></table></figure>

<p>为了具有要测试的组件，必须使用上述之一，如上面的示例所示。</p>
<p><a href="http://airbnb.io/enzyme/docs/api/mount.html">mount（常用）</a></p>
<ul>
<li>完整的DOM渲染，包括子组件</li>
<li>当您具有可能与DOM API交互的组件或使用React生命周期方法以完全测试组件的用例时，它是理想的选择</li>
<li>由于它实际上是将组件安装在DOM中，因此应在每次测试后调用unmount（），以停止相互影响的测试</li>
<li>允许访问直接传递到根组件中的props（包括默认props）和传递到子组件中的props</li>
</ul>
<p><a href="http://airbnb.io/enzyme/docs/api/shallow.html">Shallow（常用）</a></p>
<ul>
<li>仅渲染单个组件，<strong>不包括其子组件</strong>。 这对于隔离组件进行纯单元测试很有用。 它可以防止子组件中的更改影响测试输出。</li>
<li>默认情况下，浅层组件可以访问生命周期方法</li>
<li>无法访问传递到根组件的props （因此也不是默认props ），但是可以访问传递到子组件的props ，并且可以测试传递到根组件的props 的效果。</li>
</ul>
<p><a href="http://airbnb.io/enzyme/docs/api/render.html">Render</a></p>
<ul>
<li>渲染为静态HTML，包括子级</li>
<li>没有访问React生命周期方法的权限</li>
<li>比mount简单，但功能较少</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>react测试利器enzyme有三种渲染方式：shallow, mount, render。</p>
<p>shallow渲染叫浅渲染，仅仅对当前jsx结构内的顶级组件进行渲染，而不对这些组件的内部子组件进行渲染，因此，它的性能上最快的，大部分情况下，如果不深入组件内部测试，那么可以使用shallow渲染。Shallow Rendering （浅渲染）指的是，将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快。它不需要DOM环境，因为根本没有加载进DOM。</p>
<p>mount则会进行完整渲染，而且完全依赖DOM API，也就是说mount渲染的结果和浏览器渲染结果说一样的，结合jsdom这个工具，可以对上面提到的有内部子组件实现复杂交互功能的组件进行测试。</p>
<p>render也会进行完整渲染，但不依赖DOM API，而是渲染成HTML结构，并利用cheerio实现html节点的选择，它相当于只调用了组件的render方法，得到jsx并转码为html，所以组件的生命周期方法内的逻辑都测试不到，所以render常常只用来测试一些数据（结构）一致性对比的场景。</p>
<p>在<a href="https://github.com/airbnb/enzyme/issues/465">这里</a>还提到，shallow实际上也测试不到componentDidMount&#x2F;componentDidUpdate这两个方法内的逻辑。</p>
<p>shallow和mount对组件的渲染结果不是html的dom树，而是react树，如果你chrome装了react devtool插件，<br>他的渲染结果就是react devtool tab下查看的组件结构，而render函数的结果是element tab下查看的结果。</p>
<p><strong>render</strong>: render采用的是第三方库<code>Cheerio</code>的渲染，渲染结果是普通的html结构，对于snapshot使用render比较合适。</p>
<p>这些只是渲染结果上的差别，更大的差别是shallow和mount的结果是个被封装的 <code>ReactWrapper</code>，<br>可以进行多种操作，譬如find()、parents()、children()等选择器进行元素查找；<br>state()、props()进行数据查找，setState()、setprops()操作数据；<br>simulate()模拟事件触发。</p>
</blockquote>
<h4 id="常用方法示例"><a href="#常用方法示例" class="headerlink" title="常用方法示例"></a>常用方法示例</h4><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li>simulate(event, mock)：用来模拟事件触发，event为事件名称，mock为一个event object；</li>
<li>instance()：返回测试组件的实例；</li>
<li>find(selector)：根据选择器查找节点，selector可以是CSS中的选择器，也可以是组件的构造函数，以及组件的display name等；</li>
<li>at(index)：返回一个渲染过的对象；</li>
<li>get(index)：返回一个react node，要测试它，需要重新渲染；</li>
<li>contains(nodeOrNodes)：当前对象是否包含参数重点 node，参数类型为react对象或对象数组；</li>
<li>text()：返回当前组件的文本内容；</li>
<li>html()： 返回当前组件的HTML代码形式；</li>
<li>props()：返回根组件的所有属性；</li>
<li>prop(key)：返回根组件的指定属性；</li>
<li>state()：返回根组件的状态；</li>
<li>setState(nextState)：设置根组件的状态；</li>
<li>setProps(nextProps)：设置根组件的属性；</li>
</ul>
<h5 id="find-selector-x3D-gt-ShallowWrapper"><a href="#find-selector-x3D-gt-ShallowWrapper" class="headerlink" title=".find(selector) &#x3D;&gt; ShallowWrapper"></a>.find(selector) &#x3D;&gt; ShallowWrapper</h5><p><a href="https://enzymejs.github.io/enzyme/docs/api/selector.html">selector</a>选择器</p>
<blockquote>
<p>从渲染树中查找与提供的选择器匹配的每个节点。</p>
<p><strong>Arguments</strong></p>
<ol>
<li><code>selector</code> (<a href="https://enzymejs.github.io/enzyme/docs/api/selector.html"><code>EnzymeSelector</code></a>): The selector to match.</li>
</ol>
<p><strong>Examples</strong></p>
<p>CSS Selectors:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="title function_">shallow</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>);</span><br><span class="line"><span class="title function_">expect</span>(wrapper.<span class="title function_">find</span>(<span class="string">&#x27;.foo&#x27;</span>)).<span class="title function_">toHaveLength</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">expect</span>(wrapper.<span class="title function_">find</span>(<span class="string">&#x27;.bar&#x27;</span>)).<span class="title function_">toHaveLength</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compound selector</span></span><br><span class="line"><span class="title function_">expect</span>(wrapper.<span class="title function_">find</span>(<span class="string">&#x27;div.some-class&#x27;</span>)).<span class="title function_">toHaveLength</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSS id selector</span></span><br><span class="line"><span class="title function_">expect</span>(wrapper.<span class="title function_">find</span>(<span class="string">&#x27;#foo&#x27;</span>)).<span class="title function_">toHaveLength</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="simulate-event-mock"><a href="#simulate-event-mock" class="headerlink" title="simulate(event[, mock])"></a>simulate(event[, mock])</h5><blockquote>
<p>在对应的元素节点上模拟事件。 </p>
<p><strong>Arguments</strong></p>
<ol>
<li><code>event</code> (<code>String</code>): 事件名称</li>
<li><code>mock</code> (<code>Object</code> [optional]): 模拟事件对象，它将与传递给处理程序的事件对象合并</li>
</ol>
<p><strong>Returns</strong></p>
<p><code>ReactWrapper</code>: Returns itself.</p>
</blockquote>
<h6 id="Example-class-component"><a href="#Example-class-component" class="headerlink" title="Example class component"></a>Example <code>class component</code></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; count: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; count &#125; = this.state;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=&#123;`clicks-$&#123;count&#125;`&#125;&gt;</span><br><span class="line">          &#123;count&#125; clicks</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;a href=&quot;url&quot; onClick=&#123;() =&gt; &#123; this.setState(&#123; count: count + 1 &#125;); &#125;&#125;&gt;</span><br><span class="line">          Increment</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapper = shallow(&lt;Foo /&gt;);</span><br><span class="line"></span><br><span class="line">expect(wrapper.find(&#x27;.clicks-0&#x27;).length).to.equal(1);</span><br><span class="line">wrapper.find(&#x27;a&#x27;).simulate(&#x27;click&#x27;);</span><br><span class="line">expect(wrapper.find(&#x27;.clicks-1&#x27;).length).to.equal(1);</span><br></pre></td></tr></table></figure>

<h6 id="Example-functional-component"><a href="#Example-functional-component" class="headerlink" title="Example functional component"></a>Example <code>functional component</code></h6><p>component</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line">import &#123; Form, Input, Select, Button &#125; from &quot;@alifd/next&quot;;</span><br><span class="line"></span><br><span class="line">const FormItem = Form.Item;</span><br><span class="line"></span><br><span class="line">const formItemLayout = &#123;</span><br><span class="line">  labelCol: &#123;</span><br><span class="line">    span: 6,</span><br><span class="line">  &#125;,</span><br><span class="line">  wrapperCol: &#123;</span><br><span class="line">    span: 14,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">const SearchInput = (&#123; placeholder, onSearch &#125;) =&gt; &#123;</span><br><span class="line">  const submitHandle = (values) =&gt; &#123;</span><br><span class="line">    if (Object.keys(values).length === 0) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    onSearch(values.search);</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        marginBottom: &quot;10px&quot;,</span><br><span class="line">        marginTop: &quot;5px&quot;,</span><br><span class="line">        marginLeft: &quot;5px&quot;,</span><br><span class="line">        width: &quot;420px&quot;,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Form inline&gt;</span><br><span class="line">        &lt;Form.Item</span><br><span class="line">          label=&quot;策略名称:&quot;</span><br><span class="line">          key=&quot;search&quot;</span><br><span class="line">          required</span><br><span class="line">          requiredTrigger=&quot;onBlur&quot;</span><br><span class="line">          hasFeedback</span><br><span class="line">          requiredMessage=&quot;请输入&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;Input placeholder=&#123;placeholder&#125; name=&quot;search&quot; /&gt;</span><br><span class="line">        &lt;/Form.Item&gt;</span><br><span class="line">        &lt;FormItem wrapperCol=&#123;&#123; offset: 5 &#125;&#125;&gt;</span><br><span class="line">          &lt;Form.Submit</span><br><span class="line">            validate</span><br><span class="line">            type=&quot;primary&quot;</span><br><span class="line">            onClick=&#123;submitHandle&#125;</span><br><span class="line">            style=&#123;&#123; marginRight: 10 &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            搜索</span><br><span class="line">          &lt;/Form.Submit&gt;</span><br><span class="line">        &lt;/FormItem&gt;</span><br><span class="line">      &lt;/Form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">SearchInput.propTypes = &#123;</span><br><span class="line">  onChange: PropTypes.func,</span><br><span class="line">  onClick: PropTypes.func,</span><br><span class="line">&#125;;</span><br><span class="line">export default SearchInput;</span><br></pre></td></tr></table></figure>

<p><strong>测试用例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import SearchInput from &#x27;../index&#x27;</span><br><span class="line">import &#123; mount &#125; from &#x27;enzyme&#x27;</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">//describe相当于一个块，可以将测试用例放在一个块中</span><br><span class="line">describe(&#x27;SearchInput unit test&#x27;, () =&gt; &#123;</span><br><span class="line">	// case1 标签选择器+修改props</span><br><span class="line">	test(&#x27;SearchInput tag selector&#x27;, () =&gt; &#123;</span><br><span class="line">		const wrapper = mount(&lt;SearchInput placeholder=&quot;please input&quot; /&gt;)</span><br><span class="line">		expect(wrapper.find(&#x27;input&#x27;).at(0).prop(&#x27;placeholder&#x27;)).toEqual(&#x27;please input&#x27;)</span><br><span class="line">		//设置属性</span><br><span class="line">		wrapper.setProps(&#123; placeholder: &#x27;请输入&#x27; &#125;)</span><br><span class="line">		expect(wrapper.find(&#x27;input&#x27;).at(0).prop(&#x27;placeholder&#x27;)).toEqual(&#x27;请输入&#x27;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	// case2属性选择器+修改props</span><br><span class="line">	test(&#x27;SearchInput props&#x27;, () =&gt; &#123;</span><br><span class="line">		const wrapper = mount(&lt;SearchInput placeholder=&quot;&quot; /&gt;)</span><br><span class="line">		// 判断是否存在输入框</span><br><span class="line">		expect(wrapper.exists(&#x27;input[name=&quot;search&quot;]&#x27;)).toBeTruthy</span><br><span class="line">		expect(wrapper.find(&#x27;input[name=&quot;search&quot;]&#x27;)).toHaveLength(1)</span><br><span class="line">		//设置属性</span><br><span class="line">		wrapper.setProps(&#123; placeholder: &#x27;serach&#x27; &#125;)</span><br><span class="line">		expect(wrapper.find(&#x27;input#search&#x27;).prop(&#x27;placeholder&#x27;)).toBe(&#x27;serach&#x27;)</span><br><span class="line">	&#125;)</span><br><span class="line">	//修改state</span><br><span class="line">	test(&#x27;SearchInput state&#x27;, () =&gt; &#123;</span><br><span class="line">		const wrapper = mount(&lt;SearchInput placeholder=&quot;&quot; /&gt;)</span><br><span class="line">		// 判断是否存在输入框</span><br><span class="line">		expect(wrapper.exists(&#x27;input[name=&quot;search&quot;]&#x27;)).toBeTruthy</span><br><span class="line">		expect(wrapper.find(&#x27;input[name=&quot;search&quot;]&#x27;)).toHaveLength(1)</span><br><span class="line">		//设置state，只有class components才可以使用</span><br><span class="line">		// wrapper.setState(&#123; loading: true &#125;)</span><br><span class="line">		// expect(wrapper.find(&#x27;.next-btn next-medium next-btn-primary next-btn-loading&#x27;)).toHaveLength(1)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="看前面的一堆代码可能削微有点绕啊"><a href="#看前面的一堆代码可能削微有点绕啊" class="headerlink" title="看前面的一堆代码可能削微有点绕啊"></a>看前面的一堆代码可能削微有点绕啊</h4><p><strong>简单总结一下：</strong></p>
<p><code>expect</code>是Jest提供的断言，所以当你需要该判断结果是否正确的时候去Jest查expect的<a href="https://jestjs.io/docs/en/expect">文档</a>就行。</p>
<p><code>wrapper</code>可看做是enzyme提供了一套类似Jquery的API。所以Jquery做的她都能做，如：查找元素、获取元素及其属性、触发元素行为等。对应的也直接去enzyme查<a href="https://enzymejs.github.io/enzyme/docs/api/">文档</a>就行</p>
<h3 id="测试报告解读"><a href="#测试报告解读" class="headerlink" title="测试报告解读"></a>测试报告解读</h3><img src="/2020/07/20/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/4.png" class="">

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>File</td>
<td>测试用例文件</td>
</tr>
<tr>
<td>% Stmts</td>
<td>是语句覆盖率（statement coverage）：是否每个语句都执行了</td>
</tr>
<tr>
<td>% Branch</td>
<td>分支覆盖率（branch coverage）：是否每个分支代码块都执行了（if,||,?:)</td>
</tr>
<tr>
<td>% Funcs</td>
<td>函数覆盖率（function coverage）：是否每个函数都调用了</td>
</tr>
<tr>
<td>% Lines</td>
<td>行覆盖率（line coverage）：覆盖的行</td>
</tr>
<tr>
<td>% Uncovered Line #s</td>
<td>行覆盖率（line coverage）：是否每一行都执行了</td>
</tr>
<tr>
<td>Test Suites</td>
<td>测试用例文件个数</td>
</tr>
<tr>
<td>Tests</td>
<td>测试用例个数</td>
</tr>
<tr>
<td>Snapshots</td>
<td>UI快照个数</td>
</tr>
</tbody></table>
<p><code>本文引用的图片，如有侵权请联系我删除。</code></p>
<h3 id="测试外传"><a href="#测试外传" class="headerlink" title="测试外传"></a>测试外传</h3><p>测试框架有很多基于不同的需求不同的语言选择不同，比如Puppeteer、@testing-library库等等，有机会咱也试一试。</p>
<p>现阶段在团队里落地的案例：核心的方法(覆盖率100%)、核心的组件(覆盖率&gt;80%)</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><blockquote><footer><strong>softwaretestinghelp</strong><cite><a href="https://www.softwaretestinghelp.com/tdd-vs-bdd/">TDD Vs BDD – Analyze The Differences With Examples</a></cite></footer></blockquote>

<blockquote><footer><strong>code秘密花园</strong><cite><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247486072&idx=2&sn=43e99a7a755b47c93500d02ebbfed557&chksm=ce6eced4f91947c2b2df99ad48b8508f53ffb4d02ddf9799d6d15b6b86c1be50df3748d301ba&mpshare=1&scene=1&srcid=0720CJXc51rAx9qFl6kPH0ZW&sharer_sharetime=1595207922217&sharer_shareid=77df2eafd0a472623696abf038541666&version=3.0.25.2103&platform=win&rd2werd=1#wechat_redirect">前端自动化测试探索和实践</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端深似海</title>
    <url>/2021/04/29/%E5%89%8D%E7%AB%AF%E6%B7%B1%E4%BC%BC%E6%B5%B7/</url>
    <content><![CDATA[<p>把我知乎回答的一篇文章拿过来。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>人到30总想多做点什么，不然怕被干趴下了，毕竟不能被干趴下，所以就写写说说，万一走上一条不归路呢，那多刺激。</p>
<p>第一篇知乎文章啊 就给了前端，可见爱的多么<strong>深沉</strong>。</p>
<p>前几年除了迷茫时期浪的其他行业，都是在做后端，最近这两年由于公司当时的业务需要赶鸭子上架写起了前端代码，对于当时只会一点js和html以及削微一点点css的我来说，那是酸爽的一比啊。</p>
<p>一入前端<strong>深</strong>似海啊<strong>深</strong>似海。</p>
<p>因为我属于半路出家，所以没有系统性的学习，我只能在这儿随便抒发我的游击路线。</p>
<h3 id="如果你着急"><a href="#如果你着急" class="headerlink" title="如果你着急"></a>如果你着急</h3><p>先找个视频根据自己的需要搭建好本地环境。</p>
<p>这个时候就别再想着拿本恁厚的犀牛书或者JavaScript高级程序设计等等书来啃了，因为来不及，我的建议是<strong>边做边学</strong>，先让自己动起来。</p>
<ul>
<li>找学习内容</li>
</ul>
<p>网上一大堆学习网站和博客，所以其实这个时候你会发现你最需要的是掌握搜索技巧。首先尽量别用百度搜索，体验太差，可以用必应或者最近比较火的夸克之类的。</p>
<p>我的建议是如果不能访问外网，就尽量到垂直领域类的网站去搜索，比如<strong>github、开源中国、博客园</strong>等，以及一些视频网站比如<strong>网易公开课，</strong>这里特别要注意<strong>github，</strong>它可是个宝藏啊，啥都有。</p>
<p>如果实在找不到质量好的课程最简单的方法就是花钱，现在网上各种课程一大堆，首先能确定一点能开课且还收钱的肯定有两把刷子最起码比你强，那你花点钱不冤枉。这个时候尽量挑实操性强的有针对性的课程，讲原理、扩展类的就先别接触了。</p>
<ul>
<li>学习方式</li>
</ul>
<p>边学边跟着练。<strong>要多练不停的练</strong>，想不明白甚至照着敲几遍都行。</p>
<p>如果有必要可以边学边写工作代码，不要怕先干起来。当然前提有几点：</p>
<ol>
<li>首先你可以放心一点：除非你们的系统是PPT或者KPI系统，不然是没人敢放你写代码的，所以人给了机会你就得先迈一步，没事走两步。</li>
<li>团队有code review，找大牛给你code review，你会成长得很快。这个时候就别要脸了。你根本没脸，不要问我咋知道得。</li>
<li>不要一开始就写核心业务代码，当然也几乎不可能让你上。</li>
<li>做好对当前代码会不断重构的心理准备。</li>
</ol>
<p>这个时候还有个东西很重要，那就是工具，提效的工具。</p>
<p><strong>代码规范</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/366160434">Gamehu：Lint工具zhuanlan.zhihu.com<img src="https://pic1.zhimg.com/v2-cd154d8027ddabe339d7a403e1dc9df8_180x120.jpg" alt="图标"></a><a href="https://link.zhihu.com/?target=http://gamehu.run/2019/09/03/Lint%E7%AC%94%E8%AE%B0/">Lint笔记-ESLintgamehu.run<img src="https://pic1.zhimg.com/v2-38dd71c105bb6673f07c002fd637a79c_180x120.jpg" alt="图标"></a></p>
<p><strong>代码调试</strong></p>
<p><a href="https://link.zhihu.com/?target=http://gamehu.run/2019/09/20/Chrome%20Tools-Sources/">Chrome Tools-Sourcesgamehu.run<img src="https://pic3.zhimg.com/v2-adf419c2a4e483b9d2c7fa03e2e11c6e_ipico.jpg" alt="图标"></a></p>
<h3 id="如果你不着急"><a href="#如果你不着急" class="headerlink" title="如果你不着急"></a>如果你不着急</h3><p>可以先看看这个</p>
<p><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Learn/Front-end_web_developer">Front-end web developerdeveloper.mozilla.org</a></p>
<p><strong>目标</strong></p>
<p>整个系统性的学习框架出来，如果自己搞出来有难度，很简单随便上网用关键字搜一下，比如搜面试指南、前端技术雷达、前端知识框架、前端技术思维导图等然后把你搜索到的内容对比一下，基本上就能知道你需要在不同阶段掌握哪些内容了。</p>
<p>总之先整个可量化的内容以及明确的目标出来。</p>
<p><em>目标要阶段性且有挑战性且可给与你反馈的。</em></p>
<p><strong>然后可能需要这么干：</strong></p>
<ul>
<li>从基础类内容开始学起。比如HTML、CSS、ES6等</li>
</ul>
<blockquote>
<p>可能很多时候当人开始准备做前端的时候，就有一种冲动选择像React、Bootstrap、AntD等流行的库或者框架，并开始投入大量时间到基于它们构建的内容中。<br>这是不明智的，你要控zhi你自己。 如果不了解基础知识，就永远无法使用这些主流框架更高级的特效以及创建更高级的项目。 要记住不积硅步无以至千里啊，盆友们。</p>
</blockquote>
<ul>
<li>应用</li>
</ul>
<blockquote>
<p>注意，学习和<strong>应用</strong>之间存在巨大差异。<br>从0开始，使用HTML &#x2F; CSS &#x2F; JavaScript创建一个小型但有效的项目。 然后，不断的一个又一个的创建练习的项目。<br>在此过程中，不断增加项目的复杂性和期望值，直到达到你设定的目标。</p>
<p>这个时候你再考虑拿一些主流的库和框架来联手了，深刻理解“造轮子”这个词。</p>
</blockquote>
<ul>
<li>看书</li>
</ul>
<p>书那就太多了，这个时候你应该大体对前端有一定的认知，这个时候你就可以选书看看了，我不太爱看书啊，一看书就打瞌睡，所以看书慢且比较少，所以看个人了，下面是我看的部分书。有机会后续会把书单完整列一个。另外如果喜欢电子书可以买个阅读器，市面上茫茫多，我自己是几年前买了个Kindle上面的书比我纸质书多。</p>
<p>[《Web开发经典丛书：HTML &amp; CSS 设计与构建网站》(<a href="https://link.zhihu.com/?target=https://item.jd.com/12377543.html">美]Jon Duckett)【摘要 书评 试读】- 京东图书item.jd.com<img src="https://pic4.zhimg.com/v2-60c5ffb65fa46d9816b13fd8f6d8f0b3_ipico.jpg" alt="图标"></a>[《JavaScript高级程序设计 第4版(图灵出品）》(<a href="https://link.zhihu.com/?target=https://item.jd.com/12958580.html">美]马特·弗里斯比（Matt,Frisbie）)【摘要 书评 试读】- 京东图书item.jd.com<img src="https://pic1.zhimg.com/v2-253ce779a5753f86cdb21a5e043afe68_ipico.jpg" alt="图标"></a></p>
<p><img src="https://pic2.zhimg.com/80/v2-86df45545f372387a151be266e44e0a1_720w.jpg" alt="img">我的一部分…</p>
<ul>
<li>看源码</li>
</ul>
<p>先别直接上来就看React等源码，相信我你可能会自闭的。</p>
<p>找一些基础的库比如lodash等看看源码，你会印证和学到很多。</p>
<p>循序渐进，弄清楚一些主流的框架为什么要这么做。有时候，直接使用某些框架可能并不是最好的选择，但是在大多数情况下，了解它们是没错的。</p>
<ul>
<li>了解工具</li>
</ul>
<p>在开始前端开发的过程中，了解不同的工具选项是很重要的。 出色的工具应用将让你的更加的得心应手。</p>
<blockquote>
<p>Chrome Tools、git、npm、webpack、node、postman、nginx等，其中chrome tools、git、nginx我个人认为熟练掌握很重要。</p>
</blockquote>
<ul>
<li>用户体验</li>
</ul>
<p>这其实属于软技能了，需要一种思维的转变。</p>
<p><strong>做一个好用的产品。</strong></p>
<blockquote>
<p>作为前端开发人员，需要意识到自己处于某种中间人角色。 作为中间人，与QA人员，产品，UCD以及其他开发人员都会有交集。你将需要考虑不同的观点。在这个过程中你会发现你可能会做了一些产品、UCD等角色的工作。<br><em>始终保持良好的用户体验不仅是从用户的角度，还是从其他开发人员的角度。</em></p>
</blockquote>
<ul>
<li>参加开源项目</li>
</ul>
<p>这块好处那就多了，成就感、能力提升、献出自己的一份力、结交新朋友等等</p>
<p>这个是我一直的痛，个人能力有限吧，或者说没找到入门的方式或者说懒，我迟迟没有跨出这一个步…我也要加油了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>暂时写这么多吧，感觉如果还不收手的话，写一个星期的写不完，因为其实里面的很小一个点估计也能写好多文字，前端为什么深似海就是因为轮子太多，技术栈更新快，前端地位愈发重要等等。</p>
<p>我跟你们放一张图你们就明白深似海，我为何感慨了。</p>
<p>这张图就是现在我主要下手的内容，这只是前端工程化部分的内容，已经够够够学好久了。。。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7bce2496d24399521206754778fb6e35_720w.jpg" alt="img"></p>
<p>​							很抱歉我确实忘记是从哪儿看到的的图了，如果有侵权请联系我删除，由此给您带来的困扰我十分抱歉。</p>
<p>另外说一下如果要报课程，我建议大家还是慎重，毕竟现在市面上各类培训或者课程太多，别挑花眼的同事把自己整的太浮躁，一口吃不成胖子。我还是提倡实操为主，直接找公司实习，不要钱都行。</p>
<p>如果非要报，报个系统性的线上或者线下课程，最好是选择学习时能直接产生交互或者反馈的那类课程，最好不要录播的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控</title>
    <url>/2020/06/05/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>其实老早就想做监控，之前整理的<a href="/2020/04/28/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9(%E4%B8%80)/" title="前端埋点(一)">前端埋点(一)</a>里头有说一些相关的内容。</p>
<p>不痛就不慌，所以说说我们痛的地方：</p>
<ol>
<li>因为我们的产品都是部署在客户内网的，所以对于debug及其不友好，客户现场问题排查前端几乎没有任何输入，难弄。</li>
<li>产品迭代了多个版本，但是没有任何客户现场的用户行为等数据，产品优化少了一些输入。</li>
</ol>
<p>本来计划是自研，但是由于业务压力突然来袭，所以就搁置了，不过我犹不放弃，觉得自研既然短期不现实，那可以站在巨人肩膀上搞一搞。</p>
<p>找了两个工具Sentry+rrweb，基于两个工具做一些定制化，手里不就有东西了吗。</p>
<h3 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h3><p>Sentry的应用程序监视平台可为每位开发人员提供帮助诊断，修复和优化其代码的性能。</p>
<p><a href="https://docs.sentry.io/platforms/native/configuration/options/">config</a></p>
<p><a href="https://docs.sentry.io/platforms/javascript/">config for JavaScript</a></p>
<p><a href="https://sentry.io/features/">React</a></p>
<p><a href="https://blog.sentry.io/2019/03/06/new-features-greater-visibility/">features</a></p>
<h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>@sentry&#x2F;tracing 性能监控</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using npm</span></span><br><span class="line">$ npm install --save @sentry/react @sentry/tracing</span><br></pre></td></tr></table></figure>



<h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&#x27;http://cb4e9b434f004c53a51af8ab45346635@172.17.162.101:9100/2&#x27;</span>,</span><br><span class="line">  <span class="attr">integrations</span>: [<span class="keyword">new</span> <span class="title class_">Integrations</span>.<span class="title class_">BrowserTracing</span>()],<span class="comment">//性能监控配置</span></span><br><span class="line">  <span class="comment">// beforeSend (event, hint) &#123;</span></span><br><span class="line">  <span class="comment">//   // Check if it is an exception, and if so, show the report dialog 错误弹窗</span></span><br><span class="line">  <span class="comment">//   if (event.exception) &#123;</span></span><br><span class="line">  <span class="comment">//     Sentry.showReportDialog(&#123; eventId: event.event_id &#125;);</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   return event;</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">debug</span>: <span class="literal">false</span>,<span class="comment">// 调试模式</span></span><br><span class="line">  <span class="attr">attachStacktrace</span>: <span class="literal">false</span>,<span class="comment">//附上堆栈信息</span></span><br><span class="line">  <span class="attr">tracesSampleRate</span>: <span class="number">1</span>,<span class="comment">// Be sure to lower this in production</span></span><br><span class="line">  <span class="attr">environment</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="comment">// logLevel: 2,</span></span><br><span class="line">  <span class="attr">release</span>: <span class="string">&#x27;sentryTest-0.1.0&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 全局scope ，可以理解为上报数据的附加信息</span></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">configureScope</span>(<span class="function">(<span class="params">scope</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//标签，可用于筛选</span></span><br><span class="line"> scope.<span class="title function_">setTag</span>(<span class="string">&quot;first-tag&quot;</span>, <span class="string">&quot;Guide&quot;</span>);</span><br><span class="line"> <span class="comment">//绑定用户信息</span></span><br><span class="line"> scope.<span class="title function_">setUser</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;gamehu&quot;</span>,</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&quot;gamehu@yeah.net&quot;</span>,</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部：自定义上下文，补充信息</span></span><br><span class="line">    <span class="title class_">Sentry</span>.<span class="title function_">setContext</span>(<span class="string">&quot;zhangsan&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">      <span class="attr">attack_type</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建一个零时到 scope ，配置到 context 上面</span></span><br><span class="line">    <span class="keyword">const</span> scope = <span class="keyword">new</span> <span class="title class_">Sentry</span>.<span class="title class_">Scope</span>();</span><br><span class="line">    scope.<span class="title function_">setTag</span>(<span class="string">&quot;section&quot;</span>, <span class="string">&quot;articles&quot;</span>);</span><br><span class="line">    scope.<span class="title function_">setUser</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">      <span class="attr">email</span>: <span class="string">&quot;zhangsan@yeah.net&quot;</span>,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h4><p>sentry-cli releases -o 组织 -p 项目 files <a href="mailto:&#x73;&#116;&#97;&#103;&#105;&#110;&#x67;&#64;&#49;&#x2e;&#48;&#46;&#x31;">&#x73;&#116;&#97;&#103;&#105;&#110;&#x67;&#64;&#49;&#x2e;&#48;&#46;&#x31;</a> upload-sourcemaps js文件所在目录 –url-prefix 线上资源URI</p>
<p>sentry-cli releases files sentryTest-0.1.0 upload-sourcemaps –url-<strong>prefix</strong> ‘<a href="http://172.17.162.101:9100/organizations/sentry/issues/61/?project=2&amp;query=is:unresolved&#39;">http://172.17.162.101:9100/organizations/sentry/issues/61/?project=2&amp;query=is%3Aunresolved&#39;</a> ‘.&#x2F;dist&#x2F;<strong>static</strong>&#x2F;js’</p>
<h4 id="添加一个-EventProcessor-对全局生效"><a href="#添加一个-EventProcessor-对全局生效" class="headerlink" title="添加一个 EventProcessor 对全局生效"></a>添加一个 EventProcessor 对全局生效</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">attachmentUrlFromDsn</span> = (<span class="params">dsn, eventId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; host, path, projectId, port, protocol, user &#125; = dsn;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;protocol&#125;</span>://<span class="subst">$&#123;host&#125;</span><span class="subst">$&#123;port !== <span class="string">&#x27;&#x27;</span> ? <span class="string">`:<span class="subst">$&#123;port&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span><span class="subst">$&#123;path !== <span class="string">&#x27;&#x27;</span> ? <span class="string">`/<span class="subst">$&#123;path&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">    &#125;</span>/api/<span class="subst">$&#123;projectId&#125;</span>/events/<span class="subst">$&#123;eventId&#125;</span>/attachments/?sentry_key=<span class="subst">$&#123;user&#125;</span>&amp;sentry_version=7&amp;sentry_client=custom-javascript`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个 EventProcessor 对全局生效</span></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">addGlobalEventProcessor</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title class_">Sentry</span>.<span class="title function_">getCurrentHub</span>().<span class="title function_">getClient</span>();</span><br><span class="line">    <span class="keyword">const</span> endpoint = <span class="title function_">attachmentUrlFromDsn</span>(</span><br><span class="line">      client.<span class="title function_">getDsn</span>(),</span><br><span class="line">      event.<span class="property">event_id</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">logEntries</span>: [<span class="string">&quot;sentryTest&quot;</span>], <span class="attr">message</span>: event.<span class="property">message</span>, <span class="attr">logger</span>: event.<span class="property">logger</span> &#125;);</span><br><span class="line">    formData.<span class="title function_">append</span>(</span><br><span class="line">      <span class="string">&#x27;my-attachment&#x27;</span>,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Blob</span>([data], &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      event.<span class="property">event_id</span> + <span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="title function_">fetch</span>(endpoint, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">body</span>: formData,</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">ex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// we have to catch this otherwise it throws an infinite loop in Sentry</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(ex);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="RRWEB-x2F-TimeCat"><a href="#RRWEB-x2F-TimeCat" class="headerlink" title="RRWEB&#x2F;TimeCat"></a>RRWEB&#x2F;TimeCat</h4><p>录制回放工具，可单独使用也可搭配Sentry使用，可对用户操作录屏，针对一些现场问题可作为排查问题得输入.</p>
<p><a href="https://github.com/rrweb-io/rrweb/blob/master/guide.zh_CN.md">rrweb使用指南</a></p>
<p><img src="https://picb.zhimg.com/v2-8e7849c3630d23eb2d5f8586b8d388aa_r.jpg" alt="preview"></p>
<h3 id="监控理论的记录"><a href="#监控理论的记录" class="headerlink" title="监控理论的记录"></a>监控理论的记录</h3><p>要做监控先做设计，根据产品、研发、测试等的输入，整理出监控数据类别：</p>
<ul>
<li><strong>JS</strong> 的异常错误；</li>
<li>资源测速；</li>
<li>接口的成功率、失败率；</li>
<li>性能。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/XIibZ0YbvibkWRcKibvw8Iic9FeJvR9mU8FuJuPBAvRsOvYl00ZoNtPYbolvxxSzGSsNgBGn573TfjTfkjm00ZoichQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/XIibZ0YbvibkWRcKibvw8Iic9FeJvR9mU8FubycbpicgLSjnEiamlGm14Hoq4ayriaZibDDNqHRMTMa4hYAic0DJt1wE7dA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/XIibZ0YbvibkWRcKibvw8Iic9FeJvR9mU8FuGtyE0qJ1E6Y3VuXjMPy82ciamb0ud6RyjtUgPlq7XlnX84YCDAbBoGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><footer><strong>FEX-zhangjunah</strong><cite><a href="http://fex.baidu.com/blog/2014/05/front_end-data/">前端数据之美 -- 基础篇</a></cite></footer></blockquote>

<blockquote><footer><strong>FEX-zhangtao</strong><cite><a href="https://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/">7 天打造前端性能监控系统</a></cite></footer></blockquote>

<blockquote><footer><strong>何方舟-前端之巅</strong><cite><a href="https://mp.weixin.qq.com/s/aqO55IyVCZzh9yhKuOKSCQ">前端越管越宽，腾讯Now直播如何把监控体系做到极致？</a></cite></footer></blockquote>

<blockquote><footer><strong>LDP</strong><cite><a href="https://tldp.org/LDP/abs/html/exitcodes.html">Advanced Bash-Scripting Guide</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>前端编码规范</title>
    <url>/2019/04/30/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>通过几个迭代后，前端代码变得越来越臃肿越来越乱。所以编码规范就排上日程。</p>
<p>结合这段时间我们的经验加上从网上搜集到的实用的编码规范，做一个简单整理。</p>
<h1 id="前端编码规范意见稿"><a href="#前端编码规范意见稿" class="headerlink" title="前端编码规范意见稿"></a>前端编码规范意见稿</h1><ul>
<li>统一ESLint文件<ul>
<li>比如用Airbnb，随着积累可以在其基础上进行扩展。</li>
</ul>
</li>
<li>React组件<ul>
<li>如果组件需要维护自己的state或者使用其生命周期方法则用class，除此以外都用function。</li>
</ul>
</li>
<li>Redux<ul>
<li>除了纯渲染组件（没有复杂的交互、逻辑），其余都用redux<blockquote>
<pre><code>        redux使代码结构更加清晰，可读性较强便于维护（倒逼组件或者模块拆的更加合理）。
        redux可当成全局内存库来用，当没有更新state时，无论何时何地都能到一样的数据，便于通用组件的开发
        redux可以减少数据的传递，不用依次往下传，随用随取，特别是针对组件层级比较深的情况
</code></pre>
</blockquote>
</li>
</ul>
</li>
<li>统一格式化插件（如果要用格式化插件）<ul>
<li>比如VSCode的prettier或者beauty，千万避免多人用多套格式化插件的情况</li>
</ul>
</li>
</ul>
<h2 id="JS开发规范"><a href="#JS开发规范" class="headerlink" title="JS开发规范"></a>JS开发规范</h2><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>不要使用关键字作为key或者属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var user = &#123;</span><br><span class="line">  private: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var user = &#123;</span><br><span class="line">  hidden: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>如果你不知道数组的长度，使用push</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var userArr = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">userArr[index] = &#x27;gamehu&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">userArr.push(&#x27;gamehu&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当你需要拷贝数组时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var len = users.length,</span><br><span class="line">    usersCopy = [],</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">  usersCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">usersCopy = users.slice();</span><br><span class="line"></span><br><span class="line">//good ES6</span><br><span class="line"></span><br><span class="line">usersCopy = [...users];</span><br><span class="line"></span><br><span class="line">usersCopy=Array.from(users);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将类数组的对象转成数组.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let args = [].slice.apply(users);</span><br><span class="line"> </span><br><span class="line">// ES6</span><br><span class="line">let args=Array.from(users);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>对字符串使用单引号 ‘’<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var name = &quot;Gamehu&quot;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var name = &#x27;Gamehu&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var fullName = &quot;Gamehu &quot; + this.lastName;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var fullName = &#x27;Gamehu &#x27; + this.lastName;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>绝对不要把参数命名为 arguments, 将覆盖作用域内传过来的 arguments 对象.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function nope(name, options, arguments) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function yup(name, options, args) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当函数的参数特别多的时候用对象封装起来再传递.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//bad</span><br><span class="line"></span><br><span class="line">export const resourceStoreDynamicFormForEdit = (group, data, index, form, editableIndex, sortItems, formItemLayout, validatorMap, dataMap, ciType, selectedCiEditable, showAlarmSlowStrategy) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"></span><br><span class="line">const params=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">params=&#123;</span><br><span class="line">	group:group, xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const resourceStoreDynamicFormForEdit=(params) =&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>函数应该只在一个抽象层次上做一件事.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function getUserRouteHandler (req, res) &#123;</span><br><span class="line">  const &#123; userId &#125; = req.params</span><br><span class="line">  // inline SQL query</span><br><span class="line">  knex(&#x27;user&#x27;)</span><br><span class="line">    .where(&#123; id: userId &#125;)</span><br><span class="line">    .first()</span><br><span class="line">    .then((user) =&gt; res.json(user))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">// User model (eg. models/user.js)</span><br><span class="line">const tableName = &#x27;user&#x27;</span><br><span class="line">const User = &#123;</span><br><span class="line">  getOne (userId) &#123;</span><br><span class="line">    return knex(tableName)</span><br><span class="line">      .where(&#123; id: userId &#125;)</span><br><span class="line">      .first()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// route handler (eg. server/routes/user/get.js)</span><br><span class="line">function getUserRouteHandler (req, res) &#123;</span><br><span class="line">  const &#123; userId &#125; = req.params</span><br><span class="line">  User.getOne(userId)</span><br><span class="line">    .then((user) =&gt; res.json(user))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>更高层次的函数在低层次函数的前面，便于阅读.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">// &quot;I need the full name for something...&quot;</span><br><span class="line">function getFullName (user) &#123;</span><br><span class="line">  return `$&#123;user.firstName&#125; $&#123;user.lastName&#125;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderEmailTemplate (user) &#123;</span><br><span class="line">  // &quot;oh, here&quot;</span><br><span class="line">  const fullName = getFullName(user)</span><br><span class="line">  return `Dear $&#123;fullName&#125;, ...`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function renderEmailTemplate (user) &#123;</span><br><span class="line">  // &quot;I need the full name of the user&quot;</span><br><span class="line">  const fullName = getFullName(user)</span><br><span class="line">  return `Dear $&#123;fullName&#125;, ...`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &quot;I use this for the email template rendering&quot;</span><br><span class="line">function getFullName (user) &#123;</span><br><span class="line">  return `$&#123;user.firstName&#125; $&#123;user.lastName&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明函数时最好设置默认值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//es6</span><br><span class="line">function (a=1, b=1) &#123; // function code &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想避免var变量造成的命名冲突，不存在特殊场景时可考虑使用立即执行函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，</span><br><span class="line">就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</span><br><span class="line">(function() &#123;</span><br><span class="line">     // 代码</span><br><span class="line">     // ...</span><br><span class="line">&#125;)();</span><br><span class="line">function()&#123;…&#125;是一个匿名函数，包围它的一对括号将其转换为一个表达式，</span><br><span class="line">紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。</span><br><span class="line">立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>当有场景需要使用私有属性时，使用闭包定义私有变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Product() &#123;</span><br><span class="line"></span><br><span class="line">	var name;</span><br><span class="line"></span><br><span class="line">    this.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Product();</span><br><span class="line">p.setName(&quot;Fundebug&quot;);</span><br><span class="line"></span><br><span class="line">console.log(p.name); // 输出undefined</span><br><span class="line">console.log(p.getName()); // 输出Fundebug</span><br><span class="line">代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>总是使用 let、const、var来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">superPower = new SuperPower();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var superPower = new SuperPower();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用一个 let 以及新行声明多个变量，缩进4个空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let items = getItems();</span><br><span class="line">let goSportsTeam = true;</span><br><span class="line">let dragonball = &#x27;z&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">let items = getItems(),</span><br><span class="line">    goSportsTeam = true,</span><br><span class="line">    dragonball = &#x27;z&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后再声明未赋值的变量，当你想引用之前已赋值变量的时候很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var i, len,hidden = true,</span><br><span class="line">    items = getItems();</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var i, items = getItems(),</span><br><span class="line">    hidden = true,</span><br><span class="line">    len;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var items = getItems(),</span><br><span class="line">    hidden = true,</span><br><span class="line">    length,</span><br><span class="line">    i;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function() &#123;</span><br><span class="line">  test();</span><br><span class="line">  console.log(&#x27;doing stuff..&#x27;);</span><br><span class="line"></span><br><span class="line">  //..other stuff..</span><br><span class="line"></span><br><span class="line">  var name = getName();</span><br><span class="line"></span><br><span class="line">  if (name === &#x27;test&#x27;) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function() &#123;</span><br><span class="line">  var name = getName();</span><br><span class="line"></span><br><span class="line">  test();</span><br><span class="line">  console.log(&#x27;doing stuff..&#x27;);</span><br><span class="line"></span><br><span class="line">  //..other stuff..</span><br><span class="line"></span><br><span class="line">  if (name === &#x27;test&#x27;) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function() &#123;</span><br><span class="line">  var name = getName();</span><br><span class="line"></span><br><span class="line">  if (!arguments.length) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function() &#123;</span><br><span class="line">  if (!arguments.length) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var name = getName();</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在声明变量时初始化变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var firstName = &quot;&quot;,</span><br><span class="line">lastName = &quot;&quot;,</span><br><span class="line">price = 0,</span><br><span class="line">discount = 0,</span><br><span class="line">fullPrice = 0,</span><br><span class="line">myArray = [],</span><br><span class="line">myObject = &#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在声明变量时别用对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Use &#123;&#125; instead of new Object()</span><br><span class="line">Use &quot;&quot; instead of new String()</span><br><span class="line">Use 0 instead of new Number()</span><br><span class="line">Use false instead of new Boolean()</span><br><span class="line">Use [] instead of new Array()</span><br><span class="line">Use /()/ instead of new RegExp()</span><br><span class="line">Use function ()&#123;&#125; instead of new Function()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>用&#x3D;&#x3D;&#x3D;代替&#x3D;&#x3D;，因为&#x3D;&#x3D;会在比较之前进行类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 == &quot;&quot;;        // true</span><br><span class="line">1 == &quot;1&quot;;       // true</span><br><span class="line">1 == true;      // true</span><br><span class="line"></span><br><span class="line">0 === &quot;&quot;;       // false</span><br><span class="line">1 === &quot;1&quot;;      // false</span><br><span class="line">1 === true;     // false</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>注意数字和字符串之间的转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 5 + 7;       // x.valueOf() is 12,  typeof x is a number</span><br><span class="line">var x = 5 + &quot;7&quot;;     // x.valueOf() is 57,  typeof x is a string</span><br><span class="line">var x = &quot;5&quot; + 7;     // x.valueOf() is 57,  typeof x is a string</span><br><span class="line">var x = 5 - 7;       // x.valueOf() is -2,  typeof x is a number</span><br><span class="line">var x = 5 - &quot;7&quot;;     // x.valueOf() is -2,  typeof x is a number</span><br><span class="line">var x = &quot;5&quot; - 7;     // x.valueOf() is -2,  typeof x is a number</span><br><span class="line">var x = 5 - &quot;x&quot;;     // x.valueOf() is NaN, typeof x is a number</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在for循环的每次迭代中都不要让JavaScript读取数组的长度。 将长度值存储在另一个变量中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bad</span><br><span class="line">var names = [&#x27;George&#x27;,</span><br><span class="line">&#x27;Ringo&#x27;,</span><br><span class="line">&#x27;Paul&#x27;,</span><br><span class="line">&#x27;John&#x27;];</span><br><span class="line">for(var i=0;i&lt;names.length;i++)&#123;</span><br><span class="line">   doSomethingWith(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">var names = [&#x27;George&#x27;,</span><br><span class="line">&#x27;Ringo&#x27;,</span><br><span class="line">&#x27;Paul&#x27;,</span><br><span class="line">&#x27;John&#x27;];</span><br><span class="line">for(var i=0,j=names.length;i&lt;j;i++)&#123;</span><br><span class="line">   doSomethingWith(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条件表达式和等号"><a href="#条件表达式和等号" class="headerlink" title="条件表达式和等号"></a>条件表达式和等号</h2><ul>
<li><p>合理使用 &#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D; 以及 &#x3D;&#x3D; 和 !&#x3D;.</p>
</li>
<li><p>合理使用表达式逻辑操作运算</p>
</li>
<li><p>条件表达式的强制类型转换遵循以下规则：</p>
</li>
<li><p>switch时一定要用default结束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: 对象 被计算为 true</span><br><span class="line">2: Undefined 被计算为 false</span><br><span class="line">3: Null 被计算为 false</span><br><span class="line">4: 布尔值 被计算为 布尔的值</span><br><span class="line">5: 数字 如果是 +0, -0, or NaN 被计算为 false , 否则为 true</span><br><span class="line">6: 字符串 如果是空字符串 &#x27;&#x27; 则被计算为 false, 否则为 true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用快捷方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (name !== &#x27;&#x27;) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (name) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if (collection.length &gt; 0) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (collection.length) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//bad</span><br><span class="line">if(v)&#123;</span><br><span class="line">   var x = v;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   var x =10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">var x = v || 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//bad</span><br><span class="line">var direction;</span><br><span class="line">if(x &gt; 100)&#123;</span><br><span class="line">   direction = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   direction = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">var direction = (x &gt; 100) ? 1 : -1;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><ul>
<li>给所有多行的块使用大括号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (test)</span><br><span class="line">  return false;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (test) return false;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (test) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function() &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function() &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><p>使用 &#x2F;** … *&#x2F; 进行多行注释，包括描述，指定类型以及参数值和返回值</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // bad</span><br><span class="line">// make() returns a new element</span><br><span class="line">// based on the passed in tag name</span><br><span class="line">//</span><br><span class="line">// @param &lt;String&gt; tag</span><br><span class="line">// @return &lt;Element&gt; element</span><br><span class="line">function make(tag) &#123;</span><br><span class="line"></span><br><span class="line">  // ...stuff...</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">/**</span><br><span class="line"> * make() returns a new element</span><br><span class="line"> * based on the passed in tag name</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;String&gt; tag</span><br><span class="line"> * @return &lt;Element&gt; element</span><br><span class="line"> */</span><br><span class="line">function make(tag) &#123;</span><br><span class="line"></span><br><span class="line">  // ...stuff...</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 &#x2F;&#x2F; 进行单行注释，在评论对象的上面进行单行注释，注释前放一个空行.</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // bad</span><br><span class="line">var active = true;  // is current tab</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">// is current tab</span><br><span class="line">var active = true;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function getType() &#123;</span><br><span class="line">  console.log(&#x27;fetching type...&#x27;);</span><br><span class="line">  // set the default type to &#x27;no type&#x27;</span><br><span class="line">  var type = this._type || &#x27;no type&#x27;;</span><br><span class="line"></span><br><span class="line">  return type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function getType() &#123;</span><br><span class="line">  console.log(&#x27;fetching type...&#x27;);</span><br><span class="line"></span><br><span class="line">  // set the default type to &#x27;no type&#x27;</span><br><span class="line">  var type = this._type || &#x27;no type&#x27;;</span><br><span class="line"></span><br><span class="line">  return type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果你有一个问题需要重新来看一下或如果你建议一个需要被实现的解决方法的话需要在你的注释前面加上 FIXME 或 TODO 帮助其他人迅速理解</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Calculator() &#123;</span><br><span class="line"></span><br><span class="line">  // FIXME: shouldn&#x27;t use a global here</span><br><span class="line">  total = 0;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Calculator() &#123;</span><br><span class="line"></span><br><span class="line">  // TODO: total should be configurable by an options param</span><br><span class="line">  this.total = 0;</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ul>
<li><p>缩进、格式化能帮助团队更快得定位修复代码BUG.</p>
</li>
<li><p>将tab设为4个空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function() &#123;</span><br><span class="line">∙∙var name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function() &#123;</span><br><span class="line">∙var name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function() &#123;</span><br><span class="line">∙∙∙∙var name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大括号前放一个空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // bad</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(&#x27;test&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function test() &#123;</span><br><span class="line">  console.log(&#x27;test&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">dog.set(&#x27;attr&#x27;,&#123;</span><br><span class="line">  age: &#x27;1 year&#x27;,</span><br><span class="line">  breed: &#x27;Bernese Mountain Dog&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">dog.set(&#x27;attr&#x27;, &#123;</span><br><span class="line">  age: &#x27;1 year&#x27;,</span><br><span class="line">  breed: &#x27;Bernese Mountain Dog&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在做长方法链时使用缩进.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(&#x27;#items&#x27;).find(&#x27;.selected&#x27;).highlight().end().find(&#x27;.open&#x27;).updateCount();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$(&#x27;#items&#x27;)</span><br><span class="line">  .find(&#x27;.selected&#x27;)</span><br><span class="line">    .highlight()</span><br><span class="line">    .end()</span><br><span class="line">  .find(&#x27;.open&#x27;)</span><br><span class="line">    .updateCount();</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var leds = stage.selectAll(&#x27;.led&#x27;).data(data).enter().append(&#x27;svg:svg&#x27;).class(&#x27;led&#x27;, true)</span><br><span class="line">    .attr(&#x27;width&#x27;,  (radius + margin) * 2).append(&#x27;svg:g&#x27;)</span><br><span class="line">    .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (radius + margin) + &#x27;,&#x27; + (radius + margin) + &#x27;)&#x27;)</span><br><span class="line">    .call(tron.led);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var leds = stage.selectAll(&#x27;.led&#x27;)</span><br><span class="line">    .data(data)</span><br><span class="line">  .enter().append(&#x27;svg:svg&#x27;)</span><br><span class="line">    .class(&#x27;led&#x27;, true)</span><br><span class="line">    .attr(&#x27;width&#x27;,  (radius + margin) * 2)</span><br><span class="line">  .append(&#x27;svg:g&#x27;)</span><br><span class="line">    .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (radius + margin) + &#x27;,&#x27; + (radius + margin) + &#x27;)&#x27;)</span><br><span class="line">    .call(tron.led);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul>
<li><p>不要将逗号放前面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var once</span><br><span class="line">  , upon</span><br><span class="line">  , aTime;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var once,</span><br><span class="line">    upon,</span><br><span class="line">    aTime;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var hero = &#123;</span><br><span class="line">    firstName: &#x27;Bob&#x27;</span><br><span class="line">  , lastName: &#x27;Parr&#x27;</span><br><span class="line">  , heroName: &#x27;Mr. Incredible&#x27;</span><br><span class="line">  , superPower: &#x27;strength&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var hero = &#123;</span><br><span class="line">  firstName: &#x27;Bob&#x27;,</span><br><span class="line">  lastName: &#x27;Parr&#x27;,</span><br><span class="line">  heroName: &#x27;Mr. Incredible&#x27;,</span><br><span class="line">  superPower: &#x27;strength&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要加多余的逗号，这可能会在IE下引起错误，同时如果多一个逗号某些ES3的实现会计算多数组的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var hero = &#123;</span><br><span class="line">  firstName: &#x27;Kevin&#x27;,</span><br><span class="line">  lastName: &#x27;Flynn&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var heroes = [</span><br><span class="line">  &#x27;Batman&#x27;,</span><br><span class="line">  &#x27;Superman&#x27;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var hero = &#123;</span><br><span class="line">  firstName: &#x27;Kevin&#x27;,</span><br><span class="line">  lastName: &#x27;Flynn&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var heroes = [</span><br><span class="line">  &#x27;Batman&#x27;,</span><br><span class="line">  &#x27;Superman&#x27;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ul>
<li>语句结束一定要加分号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">(function() &#123;</span><br><span class="line">  var name = &#x27;Skywalker&#x27;</span><br><span class="line">  return name</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">(function() &#123;</span><br><span class="line">  var name = &#x27;Skywalker&#x27;;</span><br><span class="line">  return name;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">;(function() &#123;</span><br><span class="line">  var name = &#x27;Skywalker&#x27;;</span><br><span class="line">  return name;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><p>在语句的开始执行类型转换.</p>
</li>
<li><p>字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  =&gt; this.reviewScore = 9;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var totalScore = this.reviewScore + &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var totalScore = &#x27;&#x27; + this.reviewScore;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var totalScore = &#x27;&#x27; + this.reviewScore + &#x27; total score&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var totalScore = this.reviewScore + &#x27; total score&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对数字使用 parseInt 并且总是带上类型转换的基数.，如parseInt(value, 10)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var inputValue = &#x27;4&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var val = new Number(inputValue);</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var val = +inputValue;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var val = inputValue &gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var val = parseInt(inputValue);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var val = Number(inputValue);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var val = parseInt(inputValue, 10);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">/**</span><br><span class="line"> * parseInt was the reason my code was slow.</span><br><span class="line"> * Bitshifting the String to coerce it to a</span><br><span class="line"> * Number made it a lot faster.</span><br><span class="line"> */</span><br><span class="line">var val = inputValue &gt;&gt; 0;</span><br></pre></td></tr></table></figure></li>
<li><p>布尔值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var age = 0;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">var hasAge = new Boolean(age);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var hasAge = Boolean(age);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var hasAge = !!age;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ul>
<li><p>避免单个字符名，让你的变量名有描述意义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function q() &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function query() &#123;</span><br><span class="line">  // ..stuff..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当命名对象、函数和实例时使用驼峰命名规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var OBJEcttsssss = &#123;&#125;;</span><br><span class="line">var this_is_my_object = &#123;&#125;;</span><br><span class="line">var this-is-my-object = &#123;&#125;;</span><br><span class="line">function c() &#123;&#125;;</span><br><span class="line">var u = new user(&#123;</span><br><span class="line">  name: &#x27;Bob Parr&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var thisIsMyObject = &#123;&#125;;</span><br><span class="line">function thisIsMyFunction() &#123;&#125;;</span><br><span class="line">var user = new User(&#123;</span><br><span class="line">  name: &#x27;Bob Parr&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当命名构造函数或类时使用驼峰式大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function user(options) &#123;</span><br><span class="line">  this.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bad = new user(&#123;</span><br><span class="line">  name: &#x27;nope&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function User(options) &#123;</span><br><span class="line">  this.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var good = new User(&#123;</span><br><span class="line">  name: &#x27;yup&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名私有属性时前面加个下划线 _</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">this.__firstName__ = &#x27;Panda&#x27;;</span><br><span class="line">this.firstName_ = &#x27;Panda&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">this._firstName = &#x27;Panda&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块开发的常量定义必须包含“完整的模块名称“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">export const GET_ASSET_LIST = &#x27;GET_ASSET_LIST&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">export const GET_ASSET_LIST = &#x27;ALARM_GET_ASSET_LIST&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>望名知意，建议驼峰命名（函数也适用）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// bad</span><br><span class="line">let fItem;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">let formItem;</span><br><span class="line"></span><br><span class="line">//bad</span><br><span class="line">let yUnit = unitObj.unit;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">let yAxisUnit = unitObj.unit;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><ul>
<li>属性的存取器函数不是必需的</li>
<li>如果你确实有存取器函数的话使用getVal() 和 setVal(‘hello’),java getter、setter风格或者jQuery风格</li>
<li>如果属性是布尔值，使用isVal() 或 hasVal()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (!dragon.age()) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (!dragon.hasAge()) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以创建get()和set()函数，但是要保持一致<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Jedi(options) &#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  var lightsaber = options.lightsaber || &#x27;blue&#x27;;</span><br><span class="line">  this.set(&#x27;lightsaber&#x27;, lightsaber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.set = function(key, val) &#123;</span><br><span class="line">  this[key] = val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.get = function(key) &#123;</span><br><span class="line">  return this[key];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul>
<li><p>给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Jedi() &#123;</span><br><span class="line">  console.log(&#x27;new jedi&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">Jedi.prototype = &#123;</span><br><span class="line">  fight: function fight() &#123;</span><br><span class="line">    console.log(&#x27;fighting&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  block: function block() &#123;</span><br><span class="line">    console.log(&#x27;blocking&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">Jedi.prototype.fight = function fight() &#123;</span><br><span class="line">  console.log(&#x27;fighting&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.block = function block() &#123;</span><br><span class="line">  console.log(&#x27;blocking&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>方法可以返回 this 帮助方法可链。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">Jedi.prototype.jump = function() &#123;</span><br><span class="line">  this.jumping = true;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = function(height) &#123;</span><br><span class="line">  this.height = height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var luke = new Jedi();</span><br><span class="line">luke.jump(); // =&gt; true</span><br><span class="line">luke.setHeight(20) // =&gt; undefined</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">Jedi.prototype.jump = function() &#123;</span><br><span class="line">  this.jumping = true;</span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = function(height) &#123;</span><br><span class="line">  this.height = height;</span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var luke = new Jedi();</span><br><span class="line"></span><br><span class="line">luke.jump()</span><br><span class="line">  .setHeight(20);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Jedi(options) &#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  this.name = options.name || &#x27;no name&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.getName = function getName() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.toString = function toString() &#123;</span><br><span class="line">  return &#x27;Jedi - &#x27; + this.getName();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面维护时加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(this).trigger(&#x27;listingUpdated&#x27;, listing.id);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$(this).on(&#x27;listingUpdated&#x27;, function(e, listingId) &#123;</span><br><span class="line">  // do something with listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>更好:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line">$(this).trigger(&#x27;listingUpdated&#x27;, &#123; listingId : listing.id &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$(this).on(&#x27;listingUpdated&#x27;, function(e, data) &#123;</span><br><span class="line">  // do something with data.listingId</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li>文件应该以驼峰命名，并在同名文件夹下，同时导出的时候名字一致</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><footer><strong>András Tóth (@tthndrs)</strong><cite><a href="https://blog.risingstack.com/javascript-clean-coding-best-practices-node-js-at-scale/">JavaScript Clean Coding Best Practices</a></cite></footer></blockquote>


<blockquote><footer><strong>w3schools</strong><cite><a href="https://www.w3schools.com/js/js_mistakes.asp">JavaScript Common Mistakess</a></cite></footer></blockquote>

<blockquote><footer><strong>thinkful</strong><cite><a href="https://www.thinkful.com/learn/javascript-best-practices-1/Summary">javascript-best-practices</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>加班与效率</title>
    <url>/2022/08/20/%E5%8A%A0%E7%8F%AD%E4%B8%8E%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>又是一篇陈皓老师的文章<a href="https://coolshell.cn/articles/10217.html">https://coolshell.cn/articles/10217.html</a></p>
<p>还是那句不要脸的话，真的是深有同感，特别是里面关于效率和产品那块的表达，真是我经常在心里想的和同事们聊的，不过也仅限于聊聊。再往上就会触发各种不满了。</p>
<h3 id="摘一些"><a href="#摘一些" class="headerlink" title="摘一些"></a>摘一些</h3><p>认为加班是公司的核心竞争力，或是超越对手的手段，是一种相当 Ridiculous 的想法。</p>
<p>产品的发展不是短跑，而是长跑，甚至更像是登山，登山比的不是快，而比的是策略，比的是意志，目的是登顶。</p>
<p>工作狂往往不得要领。他们花大把大把的时间去解决问题，他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案</p>
<p>很多人不知道什么叫效率，他们以为效率就是：单位时间单位人数下干更多的活。这是错的！效率不是比谁干的活多，而是比谁干得活有更大的价值。效率的物理公式是：有用功&#x2F;总功。换句话说，效率就是：单位时间和人数产生的价值。</p>
<p>有用功的来源不是拼命做需求，而是砍需求。</p>
<p>效率不是每个团队各自的效率，而是整个团队对整个产品负责的共同使命，这样才会现整体的效率。没有整体的效率，只有个体的效率，最终也等于没有效率。</p>
<p>T-Shirt Size Estimation</p>
<h3 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h3><p>很多时候说是产品其实还是按照项目在做，就会有个人认为特别大的问题，一定要追求大而全，蛮力堆功能，宁可错杀一千不能放过一百。不然就拿不下某块领域的客户，但是真的只能这么做吗？肯定不是的，因为这么做肯定是活不长的，咱们干技术的就知道，啥都要就是一种幻想，现实往往是啥都不精，然后自己把自己给捆紧了，啥也不敢做也不能做了。</p>
<p>最后只有两条路：<br> 1.就这么一直不停的缝缝补补、纠纠缠缠根本没时间和精力与时俱进。<br> 2.挣脱出来重新来一遍。但是又有多少资源和时间能重来呢？</p>
]]></content>
  </entry>
  <entry>
    <title>努力就能成功？</title>
    <url>/2022/08/17/%E5%8A%AA%E5%8A%9B%E5%B0%B1%E8%83%BD%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<p>最近有疑惑，又在开始看陈皓老师的文章。看到了这篇努力就能成功[1]。做个转载。</p>
<p>摘了其中一段文字，详细请点击原文。</p>
<p>你喜欢这句话吗？<br>“努力就会成功”，“加班就会有成就”，“勤劳就会致富”……是这样吗？</p>
<p>仔细思考一下，这些话存在严重的逻辑问题，我们在高中的时候学过“充分条件”，“必要条件”和“充要条件”！</p>
<p>“努力就会成功”这句话，把“努力”说成了“成功”的充要条件，这不就是错的吗？努力只是成功的必要条件之一。你在错误的方向或是格局很小的方向上努力，能有用么？你努力地要饭，你努力地当搬运工，你努力地打骚扰电话销卖保险…… 在错误和小格局的方向上努力，你还觉得努力还有用吗？</p>
<h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>虽然一直知道努力就能成功不过是一句鸡汤，但是看了这篇文章还是有醍醐灌顶的感觉，work smart和work hard有着本质的区别，一个是通过技能挣钱一个是通过劳动力挣钱。所以应该是通过不断的学习和迎接挑战来提升自己的技能，而不是找个简单的，然后想着用蛮力堆出成功，过程中还把自己感动的一塌糊涂。</p>
<p>References<br>[1] 努力就能成功: <a href="https://coolshell.cn/articles/19271.html">https://coolshell.cn/articles/19271.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<p>这段时间区块链很火，虽然我没用什么兴趣去做区块链，因为愚笨的我现在还没太看懂区块链到底能进入哪些行业？就像之前看红杉资本的一位VC的访谈，她的成功秘诀之一就是，自己没看懂的行业是肯定不会投的不管它多么火。</p>
<p>但是虽然这么说，我还是得了解一下到底是个什么玩意？虽然网上到处是文章但是都是东拼西凑得，不太体系。所以当我听说caoz大佬要开个区块链的扫盲视频，所以马上付费了解了下同时也看了下MacTalk大佬写的文章….。以下是这段时间对于区块链的一些笔记。</p>
<img src="/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/licheng.png" class="" title="图摘自趣链">

<p>从图中可以看出，现目前区块链的应用主要有两种场景，<strong>公有链</strong>和<strong>联盟链</strong>，其实还有<strong>私有链</strong></p>
<p>所以首先要了解比特币不是区块链，区块链是一种技术集合的统称，比特币等是区块链的一种应用。</p>
<p>区块链的核心概念：</p>
<ul>
<li><p>去中心化</p>
<blockquote>
<p>我理解就是P2P，没有集权，数据分布式存储，交易变得平等、透明、公开。这是美好的理想。</p>
</blockquote>
</li>
<li><p>共识机制（公共账本）</p>
<blockquote>
<p>就是解决信任问题，区块链要求每个联结点在共同的账本上对每一笔交易进行分布式记账。所以每个节点都对账本负责。</p>
</blockquote>
</li>
<li><p>加密</p>
<blockquote>
<p>通常是非对称加密，用于个人的账户交易。</p>
</blockquote>
</li>
<li><p>算法</p>
<blockquote>
<p>各种算法，比如分布式一致性算法，加密算法等，作为交易的支撑</p>
</blockquote>
</li>
<li><p>激励机制（针对发币的场景）</p>
<blockquote>
<p>发币，也可通过挖矿来挣币，没有甜头谁帮你干活，本质就是P2P</p>
</blockquote>
</li>
</ul>
<p>其实说白了 感觉就是一堆人在维护一个账本，这个账本每人都有一份，而且还都一模一样。</p>
<p>当然现在很多企业应用区块链，也就是联盟链，很多时候还是利用区块链的理念，在一些环节做到公开透明从而减少成本，提升效率。联盟链是指一些愿意彼此实现共信的机构和组织共同组建的，为各自机构提供共识信用和价值传递的平台，这样只要联盟不存在一家独大的情况，还是可以实现共识基础。</p>
<p>区块链我觉得应该还是一个风口，虽然不如人工智能大风大浪，但是有风有浪是肯定，抓紧时间补补吧。总比啥都不知道要强,另外我始终觉得去中心化，共识机制等强调的公平、透明只是美好的愿望。决定权始终是掌握在部分人手里的，不然为毛这么多人买矿机其实不就是增加自己的权重么。还可能存在算法劫持。所以只是美好的。所以不懂又想乘机赚一笔的就别上了，只能成为韭菜。</p>
<p><strong>名词解释：</strong></p>
<p><strong>POW</strong></p>
<ul>
<li>共识算法其实分很多种，目前最常提到的，比特币和以太坊所用到的，是叫做POW的共识算法，基于工作量证明的一种信息保障的算法。</li>
</ul>
<blockquote>
<p>区块链怎么工作的，pow为例。首先，每条交易，记账信息，是一条记录，每条记录都会发布到各个不同的节点，节点将检查最新的记录打包到一个新的区块上，然后通过算力证明，将区块发布到网络。但这里的算力证明其实是有极大的偶然性随机性，也就是有非常多的矿机，现状可能是几十万台同时打包和发布数据，但只有一个幸运的矿机，获得了证明，生成了新的区块，并获得了区块的奖励。</p>
</blockquote>
<blockquote>
<p>当这个区块发布后，其他的节点会很快得到这个信息，然后放弃掉当前已经打完包的数据，开始接受新的数据，进行下一步数据打包，并试图证明算力获得发布权力和区块奖励。所以你会发现其中的空耗是很严重的这就不难解释为什么有那么多矿机但是获得比特币还是特别难特别少。但也正是因为所有节点的概率一致，保证了任意节点被入侵，被篡改，其数据信息，不会被其他节点接受，也就是保障了主链的安全性。</p>
</blockquote>
<blockquote>
<p>POW目前的局限是出块速度被限定了，比特币差不多10分钟出一个区块，所有交易均需要记录在区块内，所以这样也就限制了交易频率，由于一个区块只有1M，可以承载的交易信息是有限的，所以目前比特币的交易频次被限定在非常低的量级上，差不多一秒才可以支撑不到10个交易。</p>
</blockquote>
<p><strong>POS</strong></p>
<blockquote>
<p>POS共识算法，也就是基于拥有的数量和时间获得证明的算法。简单解读类似于存本取息，你在系统中存的钱越多，存的时间越长，你所获得的收益就越多，这样算力竞争的意义被弱化，而拥有的意义被强化。</p>
</blockquote>
<p><strong>DPOS</strong></p>
<blockquote>
<p>在POS之上又有人提出了DPOS，在基于拥有数量的基础上，投票选举工作节点的模式，由投票委任的节点负责运算打包，一旦出现坏区块或者故障，会有一套机制保障自动切换到其他节点，实现平滑过渡</p>
</blockquote>
<p><strong>智能合约</strong></p>
<img src="/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/zhinengheyue.png" class="" title="图摘自曹政易灵微课">

<blockquote>
<p>来源于以太坊。智能合约，也就是说，在区块中传递的合约，或者说传递的字符串，不是单纯的字符串和信息，而是一段可执行的脚本，比如说，有触发条件，有交互能力。</p>
</blockquote>
<p><strong>图灵完备</strong></p>
<blockquote>
<p>图灵完备，什么是图灵完备，就是说不考虑硬件限制的情况下，这个脚本的支持性可以满足所有图灵机的功能诉求，图灵机也可以简单理解为全功能计算机。</p>
</blockquote>
<p><strong>以太坊</strong></p>
<blockquote>
<p>以太坊是一种虚拟货币，这个定义是错的，以太坊是一个平台，上面跑了几千种虚拟货币，其中之一是以太坊自身的代币。而这个平台不但可以发布货币，还可以发布应用，智能合约的应用，这个想象力是蛮大的。</p>
</blockquote>
<p><strong>硬分叉</strong></p>
<blockquote>
<p>说一下硬分叉，刚才也提到了比特币的第一次硬分叉，所谓硬分叉，是分叉方约定，在某个区块节点开始，启用新的系统架构继续前进，不再和主链保持一致，但同时也继承了该节点之前的所有区块。在这个节点之后，双方各自挖各自的矿，各自爆各自的块，各自走各自的路。</p>
</blockquote>
<p><strong>ICO</strong></p>
<blockquote>
<p>ICO 是一种基于区块链进行资金筹集的方式，目前市场上的ICO主要分两种类型，一种是股权众筹，一种是代币发行。</p>
<p>从股权众筹来说，ICO虽然通过代码来保障发行规模和你所拥有的比例，也就是说这个你所拥有的部分是不会被篡改，不会被恶意侵吞的，听上去很合理是不是？但问题在于，没有任何一个国家的法规和政策，规定或约束了企业股权与虚拟代币之间的关联，你说你不相信政府，你要去中心化，那么太多人没有意识到，去中心化同时也意味着失去权力机构的保护和制约。发行的代码是算法约束的，但与企业的发展关系，是靠人性约束的，算法是约束不了人性的。</p>
</blockquote>
<p><strong>代币模式</strong></p>
<blockquote>
<p>另一种代币模式，就是发行的是某个应用场景或平台中的代币，而不是股权，这个代币可以在这个平台中使用，并通过区块链技术保证这个代币的发行是可控的，可信任的。</p>
</blockquote>
<p>区块链的商业生态，ICO是非常大的一块，目前也是势头最火的一块，但我个人认为目前问题很大，过于挑战人性，我是非常拒绝现在那些ICO行为的。此外硬分叉，虽然最开始我们说硬分叉有其技术争论的原因；但后来就变味了，借用硬分叉的名义薅韭菜，这里信息不对称因素太大，很多人入场的人根本不知道分叉币的流通盘有多低，不知道一旦大交易所或钱包系统派糖后价格会雪崩下跌。</p>
<p>参考：<blockquote><footer><strong>MacTalk</strong><cite><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650714344&idx=1&sn=e9ec572a0917ffca5fb15cf4c1fbd859&chksm=bec07ebb89b7f7adf31f088cfd67743300425e4853469c758fa3e0cf129c5c2081209ff4e931&mpshare=1&scene=23&srcid=0629FLXTeLgrc81S3xpifNMQ#rd">技术人为什么追逐区块链？</a></cite></footer></blockquote></p>
<p>参考：<blockquote><footer><strong>曹政</strong><cite><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxd767009104b89c74&redirect_uri=https%3A%2F%2Fyike.fm%2Fcallback%2Fweixin%2Fmp-login%3FcallbackURI%3D%252Fweixin-enrolled&response_type=code&scope=snsapi_userinfo&state=1#wechat_redirect">正本清源区块链</a></cite></footer></blockquote></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>吃力不讨好</title>
    <url>/2019/08/19/%E5%90%83%E5%8A%9B%E4%B8%8D%E8%AE%A8%E5%A5%BD/</url>
    <content><![CDATA[<p>话说2018.07.31的x安公司的谢XX和李XX，在摄像头下两人进行了比较随心所欲的肢体接触，网传是因为产品经理要求程序员实现APP主题根据手机壳变颜色的需求，程序员忍无可忍从而释放自我的过程。当然这是网传版本，据说完全不是那么回事。</p>
<p>但是为什么这个事件就那么红呢。我觉得有两方面的原因：</p>
<ol>
<li>程序员一向是被整个社会调侃最多的职业之一（之一比较谦虚），热点够大。</li>
<li>网传的需求太他么奇葩，迎合了大多的吃瓜群众。</li>
</ol>
<p>作为程序员其实我们为什么也觉得有趣，是因为产品和程序员多多少少都会有不对付（矛盾）的情况发生。这件事刚好映射了此情况。我个人觉得该矛盾的核心点还是在于同理心这一点上，双方好像都很难理解对方。其实主要就是很少站在对方的角度和位置上，客观的理解对象所说的事情。</p>
<img src="/2019/08/19/%E5%90%83%E5%8A%9B%E4%B8%8D%E8%AE%A8%E5%A5%BD/tom-gainor-ABjAtsf3XDA-unsplash.jpg" class="" title="来源于https:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;ABjAtsf3XDA">

<p>讲的有点多了，为什么想说”吃力不讨好”，是因为本周周会复盘时，刚好遇到了一个同事出现了此情况，当事人肯定很难受也比较委屈,这位同事暂时起名小波，方便叙述。</p>
<p>当然这篇文章主要是站在技术人员的角度写的，其它职位的待我深入了解后再有资格叨叨。</p>
<p>为什么需要复盘一下呢，明面上的原因是小波任务delay了进而导致周目标delay了，在PO验收时结果有些不太理想。所以SM就拉着大家做了一下复盘，<br>流程是：</p>
<ul>
<li>首先小波先说明一下整个delay的原因</li>
<li>分析根因</li>
<li>大家发表一下看法和建议</li>
<li>形成改进项或者规约之类的东西</li>
<li>团队是否认同</li>
<li>改进项的责任人进行跟进</li>
</ul>
<p>大体的原因是在于，小波在研发时，鉴于程序员的伟大使命感，总想着抽象进而方便后人，但是在研发前期准备时不管是<strong>关键路径</strong>还是<strong>详设</strong>，都没能体现这块内容，关键是这块内容占用的时间还比较长，所以最终导致整个计划delay。这本身不是个问题，因为想法时好的，问题在于这是个”吃力不讨好”的事，因为这是过程产物，PO等人是看不到的，更大的问题是小波没有和任何人进行同步，一个人吭哧吭哧干了半天，那就大家都不知情，所以导致他很被动。</p>
<p>所以我给的建议是：</p>
<ol>
<li>吃力不讨好的事一定得让干系人知道，好事不留名大多数情况下是扯淡的说法。</li>
<li>自己得有一定得心理准备或者做一定的心里建设，因为既然是吃力不讨好的事，那就不能指望所有人能念你的好。</li>
</ol>
<p><strong>当然最终团队形成了一些改进项</strong></p>
<ol>
<li>尽量提前在”关键路径“阶段列出所有研发内容，功能性的和非功能性的，使后面的工程计划能更加准确。</li>
<li>定义承载过程产物的文档格式以及标准，目的是为了体现研发过程。</li>
<li>周目标的check标准更加细化，能提升更早暴露风险的时间。</li>
<li>当在研发中遇到此类问题时，一定要马上同步到相关的人，评估计划方案之后再动手。</li>
</ol>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title>合代码de内心独白</title>
    <url>/2019/02/25/%E5%90%88%E4%BB%A3%E7%A0%81de%E5%86%85%E5%BF%83%E7%8B%AC%E7%99%BD/</url>
    <content><![CDATA[<p>上周五产线领导派了一个活，合并前端和后端rest服务的代码，release合到develop。其实是一个很简单很日常的工作，但是因为种种原因，现在的版本周期过长，导致新增和修改的代码很多（特别是前端一堆的css、less、jsx、js….）。所以你知道我心中有多少只草泥马了。</p>
<img src="/2019/02/25/%E5%90%88%E4%BB%A3%E7%A0%81de%E5%86%85%E5%BF%83%E7%8B%AC%E7%99%BD/frontend.png" class="" title="前端">

<img src="/2019/02/25/%E5%90%88%E4%BB%A3%E7%A0%81de%E5%86%85%E5%BF%83%E7%8B%AC%E7%99%BD/backend.png" class="" title="rest后端">

<p>这个时候需要的是冷静，蛋定。找个本子合一支笔，列清楚怎么做这件事情，一定要花时间考虑清楚再下手。</p>
<h2 id="行动清单"><a href="#行动清单" class="headerlink" title="行动清单"></a>行动清单</h2><ol>
<li><p>摸清楚分支情况，看看改动到底有多大，根据摸排的情况，判断是否需要上升到领导，因为如果动作太大势必会对团队的一些代码方面的操作有影响，需要领导提供协助，让团队配合合理解。</p>
</li>
<li><p>把涉及到修改人都和其确认一下，代码改动的分支以及模块，看是否与自己的理解存在误差，及时修正误差。 </p>
</li>
<li><p>借助命令（git log、git diff、git show…）以及工具（meld）对代码进行比对合并，设计面广最好不要直接往develop上合，先拉一个本地分支往上合，合完之后，验证通过再往develop合并。</p>
</li>
<li><p>合并之前，明确通知合并开始的时间点，并告知团队此时间段内不要再往分支上提交代码。</p>
</li>
<li><p>合并代码的时候手别抖，心别慌，扎稳马步，看清楚再合并，其实也不怕，因为你是单独拉的分支，哪怕整坏了也无所谓。所以就跟开车一样，胆大心细。 </p>
</li>
<li><p>合并完之后，本地测试是否功能有问题，一定要测。</p>
</li>
</ol>
<hr>
<p>合并代码有个坑，在于自动合并，它往往会给人错觉表示这块代码或者这几个文件时没问题的，但是很多时候往往是有问题，因为git并不知道这几个文件是否存在因果联系，这样就往往容易漏掉。我就遇到了这个问题，合并代码之后哪儿都ok就是一直提示license有问题，几个人轮番查了几波，排除了可能的原因，最终就落到了代码合并上，猜测是代码合并造成的，所以就查代码，最后发现确实是权限过滤的url那儿没有添加上license相关的url，导致license的url每次都被拦截了。</p>
<p><strong>小结</strong></p>
<p>干越复杂越麻烦的事，越不能心慌，理清思路，列出行动项，一个个啃掉。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>同理心</title>
    <url>/2018/08/19/%E5%90%8C%E7%90%86%E5%BF%83/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>闲扯</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>向上</title>
    <url>/2022/03/20/%E5%90%91%E4%B8%8A/</url>
    <content><![CDATA[<img src="/2022/03/20/%E5%90%91%E4%B8%8A/grow.jpg" class="" title="Photo by Sandra Grünewald on Unsplash">
<p>这几个月，赶项目周末都没得，好不容易休个双休，继续之前曹政老师星球福利课《向上生长》，有想听完整版的课加入星球的可以扫描下方二维码。</p>
<img src="/2022/03/20/%E5%90%91%E4%B8%8A/caoz.jpg" class="" title="caoz的小蜜圈">

<p>我只是随便记录一下某部分印象深的内容。</p>
<h3 id="为什么要向上增长"><a href="#为什么要向上增长" class="headerlink" title="为什么要向上增长"></a>为什么要向上增长</h3><p>更好的认识世界，更好的认识自己。</p>
<blockquote>
<p>见众生，见天地，见自我。清楚这个世界并行的多重规则。</p>
</blockquote>
<h4 id="更好的被世界善待。"><a href="#更好的被世界善待。" class="headerlink" title="更好的被世界善待。"></a>更好的被世界善待。</h4><blockquote>
<p>所谓的体面和尊严，是需要一定的社会地位和财务基础为保障的。</p>
</blockquote>
<h3 id="什么制约了我们的向上生长"><a href="#什么制约了我们的向上生长" class="headerlink" title="什么制约了我们的向上生长"></a>什么制约了我们的向上生长</h3><p>嫉妒和自卑</p>
<p>caoz的梦呓有篇文章：<a href="">自信和自卑，别傻傻分不清楚</a>。</p>
<blockquote>
<p>这点事我需要注意的，做的不够好：不愿看别人优点，不敢看自己的缺点<br>真诚的表达对别人优点的称赞，以及真诚的感谢别人对你的帮助<br>对一些别人背后对自己的不利一轮，如果不是特别严重的，可以适当装傻，所谓难得糊涂，就是这样。</p>
</blockquote>
<h3 id="向上的机会从哪儿来"><a href="#向上的机会从哪儿来" class="headerlink" title="向上的机会从哪儿来"></a>向上的机会从哪儿来</h3><h4 id="你能做，别人做不来。"><a href="#你能做，别人做不来。" class="headerlink" title="你能做，别人做不来。"></a>你能做，别人做不来。</h4><p>这点其实比较难，大多情况下你能做的别人也能做，要有这点认知。</p>
<h4 id="你肯做，别人不肯做。"><a href="#你肯做，别人不肯做。" class="headerlink" title="你肯做，别人不肯做。"></a>你肯做，别人不肯做。</h4><p>很多时候，当有个事情抛出来的时候，只要我觉得是我力所能及的时候，不管是否符合自己的切身利益我都会先顶上去，因为我觉得如果leader或者老板抛出来一个事情没人应声，会很尴尬，没错我主要是不想那么尴尬。当然也想着多练练自己。老板也能看见没啥亏不亏的，甚至会有赚。</p>
<h4 id="你看到了，别人看不到。"><a href="#你看到了，别人看不到。" class="headerlink" title="你看到了，别人看不到。"></a>你看到了，别人看不到。</h4><p>这点对我就比较玄了，认知、视野都不太够，要着力提升。</p>
<blockquote>
<p>针对平时自身面对各种情况作出的决策，事后需要不断反思自己的判断，是不是存在误判的情况，然后复盘寻求认知上的升级。<br>学一些经济学，学些博弈常识，一切皆交易、一切皆博弈，这样可以解释很多事情，另外共情力、人性洞察，不通价值观的理解都是信息过滤规则库需要填充的重要内容。</p>
</blockquote>
<p><strong>重视升级自己的信息过滤和判断规则</strong></p>
<h4 id="你敢做，别人不敢做。"><a href="#你敢做，别人不敢做。" class="headerlink" title="你敢做，别人不敢做。"></a>你敢做，别人不敢做。</h4><p>这点要注意，别脑子卡壳误入歧途。对我来说，听过就算。</p>
<h4 id="你熬下来了，别人没熬下来。"><a href="#你熬下来了，别人没熬下来。" class="headerlink" title="你熬下来了，别人没熬下来。"></a>你熬下来了，别人没熬下来。</h4><p>有时候机会来自于坚持。</p>
<blockquote>
<p>这里要注意，坚持要区别与死扛，比如明知道某件事情做下去就是不会有结果就是个死，那….。</p>
</blockquote>
<blockquote>
<p>令一点要注意，你觉得你的坚持是对的，这个时候面对诱惑时的处理。</p>
</blockquote>
<h3 id="如何留下优秀的印象"><a href="#如何留下优秀的印象" class="headerlink" title="如何留下优秀的印象"></a>如何留下优秀的印象</h3><h4 id="履约能力"><a href="#履约能力" class="headerlink" title="履约能力"></a>履约能力</h4><p>这点可能是我个人比较拿得出手的职场素质：承落就得兑现。</p>
<p>建立信任是很难的，但是一旦建立必然受益无穷。</p>
<blockquote>
<p>靠谱的承诺（课里提到的预期控制，不要过度承诺，不要轻易答应），别啥都承诺，我们团队就有这样的人，很容易人设崩塌。<br>有效的反馈<br>如果过程中确实发现完不成，要尽快尽早同步，并寻求补救措施。</p>
</blockquote>
<h4 id="积极态度"><a href="#积极态度" class="headerlink" title="积极态度"></a>积极态度</h4><p>别抱怨，不散播不积累负能量，遇问题乐观、主动一些。</p>
<h4 id="体现诚意"><a href="#体现诚意" class="headerlink" title="体现诚意"></a>体现诚意</h4><p>诚意主要体现在，提前准备，做足功课，以及尽可能的超额交互。</p>
<p>注意：可能有些时候就是发自内心真诚的体现就是诚意，不一定非得怎么做。</p>
<h4 id="真诚的称赞和感谢别人"><a href="#真诚的称赞和感谢别人" class="headerlink" title="真诚的称赞和感谢别人"></a>真诚的称赞和感谢别人</h4><h4 id="寻求恰当的反馈与帮助"><a href="#寻求恰当的反馈与帮助" class="headerlink" title="寻求恰当的反馈与帮助"></a>寻求恰当的反馈与帮助</h4><blockquote>
<p>恰当的寻求反馈和帮助，是巩固社交关系，建立持续友好关系的重要手段。</p>
<p>1.提出高质量有价值的问题。</p>
<p>2.对方的成本是可控的，心里要有数，别装大哥。</p>
<p>3.对别人的价值和回报在哪里，心里也要有数。</p>
</blockquote>
<p>曹大说的这句话我觉得很重要：<strong>社交关系追求互利，不能奢求等价。</strong></p>
<h3 id="制定成长路线"><a href="#制定成长路线" class="headerlink" title="制定成长路线"></a>制定成长路线</h3><h4 id="合理目标"><a href="#合理目标" class="headerlink" title="合理目标"></a>合理目标</h4><blockquote>
<p>坚持前进比追求速度更重要</p>
</blockquote>
<h4 id="自我激励"><a href="#自我激励" class="headerlink" title="自我激励"></a>自我激励</h4><p><strong>得给自己一点甜头。</strong></p>
<blockquote>
<p>比如我干了一本书就会奖励自己一个星期不看书，加了几天班，就会奖励自己出去消费一把。从我的自我激励来看很明显是过度激励了，得控制。</p>
</blockquote>
<h4 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h4><p>遇到困难和挫折，多想想自己的问题哪儿。比如在作为程序员的我，做好容错也是一种自我反思的结果，很多时候看上去是不是自己的问题，但是如果你做好容错呢？是不是一种优势。</p>
<blockquote>
<p>平庸的人找理由，优秀的人找原因。</p>
</blockquote>
<h4 id="自律和戒断"><a href="#自律和戒断" class="headerlink" title="自律和戒断"></a>自律和戒断</h4><p>这个对我来说最难，我现在就是花挺多时间在娱乐上，在学习上的时间太少。</p>
<p>慢慢来，一个个小目标开始，比如从一天学习1小时变为1个半小时，同时把自我激励拿进来。这样可能对我来说是有效的。</p>
<blockquote>
<p>学习是需要有一定的投入，一定的深度思考。自律，自驱，延迟满足。</p>
</blockquote>
<h4 id="聚焦，抓大放小，学会减法"><a href="#聚焦，抓大放小，学会减法" class="headerlink" title="聚焦，抓大放小，学会减法"></a>聚焦，抓大放小，学会减法</h4><p>做事分主次，抓重点，不需要把每件事都做好，但是要把关键的事做漂亮。</p>
<p><strong>避免一上来就陷入细节，先掌握整体的架构。</strong></p>
<blockquote>
<p>做减法，相对立的就是追求完美，工作中我遇到一些个同事就是不太会做减法，总想啥都要啥都行，最终往往拿不到好的结果。做减法个人认为难在，首先你得对你面对的事情有个优先级的认知，比如有些事情看上去很关键但是不紧急，其次得学会抓关键，保底关键内容拿到好的结果，得到正反馈。</p>
</blockquote>
<h3 id="学会合作"><a href="#学会合作" class="headerlink" title="学会合作"></a>学会合作</h3><h4 id="关于合作的几个建议"><a href="#关于合作的几个建议" class="headerlink" title="关于合作的几个建议"></a>关于合作的几个建议</h4><ol>
<li>先立规矩，再谈感情。</li>
<li>撤出机制要讲清。</li>
<li>合作不是抱大腿，每个人都应该贡献合理的价值。</li>
<li>做大蛋糕最重要。</li>
<li>永远都要有信用成本的概念。</li>
</ol>
<h3 id="正确的花钱"><a href="#正确的花钱" class="headerlink" title="正确的花钱"></a>正确的花钱</h3><h4 id="花钱买时间"><a href="#花钱买时间" class="headerlink" title="花钱买时间"></a>花钱买时间</h4><p>比如对我来说，打车就是比坐公交好，因为公交通常要花时间找公交站，然后得等公交，然后得挤公交，这些精力和时间，我打车省下来哪怕是多玩会儿也好啊。</p>
<blockquote>
<p>时间成本和省钱往往要留意。</p>
</blockquote>
<h4 id="花钱买能力"><a href="#花钱买能力" class="headerlink" title="花钱买能力"></a>花钱买能力</h4><blockquote>
<p>尊重专业的能力，尊重专业服务，关键的地方别省钱。</p>
</blockquote>
<h4 id="花钱买信息和知识"><a href="#花钱买信息和知识" class="headerlink" title="花钱买信息和知识"></a>花钱买信息和知识</h4><p>比如知识付费。注意贪多嚼不烂，不买就焦虑的想法。我就是前期哐哐哐一顿买，结果看不过来。</p>
<blockquote>
<p>买的知识要对你有意义比如能辅助你的决策影响你的工作或者思考方式</p>
</blockquote>
<h4 id="花钱买诚意"><a href="#花钱买诚意" class="headerlink" title="花钱买诚意"></a>花钱买诚意</h4><p>花费也是表达诚意的一种方式。</p>
<h4 id="花钱买忠诚"><a href="#花钱买忠诚" class="headerlink" title="花钱买忠诚"></a>花钱买忠诚</h4><p>个人觉得华为就有这个特质。</p>
<h4 id="花钱买效率"><a href="#花钱买效率" class="headerlink" title="花钱买效率"></a>花钱买效率</h4><p>自己做要一个月，给其他人做只要一天，选一下。</p>
<h3 id="莫忘初心"><a href="#莫忘初心" class="headerlink" title="莫忘初心"></a>莫忘初心</h3><p>在少数的几次和老板的谈话多，印象最深刻的几句话之一：无论环境如何（公司、同事），希望你能一直保持自己的<strong>本色</strong>。</p>
<blockquote>
<p>在成长中肯定会因为各种各样的因素，比如环境、利益等，从而改变自己的一些想法和做事方式，但是切忌要心中一直给最开始的初心、原则留一块地方，这块地方能调整但是不能失去，不然说不定啥时候就变成了你平时最厌烦的那种人。</p>
</blockquote>
<p>听友推荐的经济学书籍：</p>
<p>张维迎《博弈与社会》、张捷《霸权博弈》《资源角逐》《定价权》</p>
]]></content>
  </entry>
  <entry>
    <title>啥时候用Redux</title>
    <url>/2019/04/22/%E5%95%A5%E6%97%B6%E5%80%99%E7%94%A8Redux/</url>
    <content><![CDATA[<img src="/2019/04/22/%E5%95%A5%E6%97%B6%E5%80%99%E7%94%A8Redux/001.png" class="">

<p>一个小迭代结束之后，我们前端做了一个几次code revew，其中有个问题就是什么时候应该redux，因为redux其实有些重，但是某些场景其实很简单当让组件也很简单，有观点觉得没有必要上redux。</p>
<p>这个问题需要有个解法。</p>
<p><strong>我觉得需要根据现有的环境来几个方面来考虑。</strong></p>
<ol>
<li>现在我们产品前端组件类别：基础组件、业务通用组件、定制化组件。</li>
<li>产品的体量，我们产品是ToB产品，功能比较多，代码量比较大。</li>
<li>业务场景的复杂度，因为是ToB，所以场景覆盖比较全，同时定制化需求稍微比较多，所以复杂度比较高。</li>
</ol>
<p><strong>好，接着我们再看看Redux，要讨论是否需要用它或者什么时候用它我们得搞清楚它的作用是什么。</strong></p>
<p>首先咱们得确定一点React本身其实就是一个UI(View)层它不是一个前端框架， 如果是个复杂的产品，前端光负责View很显然是不够的，所以这几年出现了很多前端架构，比如MVVM架构下的Angular就是一套前端框架.</p>
<p>正因为这样，所以FaceBook提出了Flux的架构，就是为了能推出以React为基础的一套前端框架，让React不再孤单.</p>
<p>至于什么是Flux，阮老师说的很清楚： <a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" title="Flux 架构入门教程">http://www.ruanyifeng.com/blog/2016/01/flux.html</a></p>
<p><strong>看完之后你会发现，redux其实就是Flux的一种实现，主要解决两个问题：</strong></p>
<ol>
<li>清晰的代码层次结构，让复杂的前端变得更加健壮和易维护（action、dispatch、reducer等）.</li>
<li>让React组件之间通信变得更有效率和更方便（通过store能在任何组件访问想要的数据，不管是横向的还是纵向的层级，而不用依次传递经过根本不需要该数据的组件，真正做到按需使用）</li>
</ol>
<p><strong>所以说到这儿我们可以简单列一下使用Redux的好处</strong></p>
<ul>
<li>大多数情况下可以用reducer友好的把state从组件里分离出来，使组件更加的轻量化也增加了代码可读性.</li>
<li>Redux的store可以当成缓存使用，并且是全局的，你可以在任何地方使用它，只要不更新state，无论何时何地获取的数据都是一样的，使数据共享变得容易.</li>
<li>Redux友好的把state统一放到了store里，通过action、dispatch、reducer，让state的变化变得可预测，让数据流变得清晰明朗，易于维护.</li>
<li>Redux的store让数据的传递变得更有效率，无需依次进行数据传递（哪怕该组件根本不需要这个数据），可以满足需要的时候再获取.</li>
<li>Redux更有利于公共组件的开发，公共组件无论在哪儿使用，可以通过dispatch触发其行为.</li>
</ul>
<h3 id="试着回答一下"><a href="#试着回答一下" class="headerlink" title="试着回答一下"></a>试着回答一下</h3><p>我觉得除非已经明确的定义某个组件只是一个纯UI类组件，不会存在其它业务逻辑或者行为，那我觉得没有必要用Redux，比如我们产品中的一些展示组件，这些组件一个最大的特点就是，只需要给它数据，它渲染就完事了不会有额外的一些操作,那完全就一个jsx就搞定了.<strong>除此以外都建议用Redux，虽然它复杂了些，但是你会慢慢发现他的好.</strong></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title>如何做职业规划</title>
    <url>/2019/08/27/%E5%A6%82%E4%BD%95%E5%81%9A%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="冰山模型"><a href="#冰山模型" class="headerlink" title="冰山模型"></a>冰山模型</h3><p>这玩意能比较通透的了解自己有几斤几两。</p>
<img src="/2019/08/27/%E5%A6%82%E4%BD%95%E5%81%9A%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/ice.jpg" class="">



<ol>
<li>认知迷茫<ul>
<li>危机感的缺失<ul>
<li>物质需求基本满足，过于安逸</li>
</ul>
</li>
<li>经验传承的断层<ul>
<li>父辈那一代的经验和技能不能很好的借鉴</li>
</ul>
</li>
<li>失败的自我认知教育</li>
<li>文化信仰的缺失</li>
</ul>
</li>
</ol>
<p>最终的表现就是，同样的起点，同样的终点，迷茫的人会走很多很多弯路。</p>
<h3 id="如何做职业规划"><a href="#如何做职业规划" class="headerlink" title="如何做职业规划"></a>如何做职业规划</h3><ol start="2">
<li><p>找到人生目标</p>
<ul>
<li>马斯洛需求理论 </li>
<li>从欲望的角度</li>
</ul>
</li>
<li><p>拆解人生目标</p>
<ul>
<li>逻辑树</li>
</ul>
</li>
<li><p>选择职业目标</p>
<ul>
<li>工具<ul>
<li>逻辑树，拆解自己的选择标准</li>
<li>决策矩阵<ul>
<li>简化的矩阵，选择维度&#x3D;2时</li>
</ul>
</li>
</ul>
</li>
<li>标准<ul>
<li>感性因素（随心所欲）、理性因素（扬长避短、顺势而为）</li>
</ul>
</li>
</ul>
</li>
<li><p>梳理职业路径</p>
<ul>
<li>职业路径图，搞清楚所在职业整个的路径是什么。</li>
<li>对标管理，每个小目标都可以选择一个最佳实践<ul>
<li>对标的目标的评估标准（CQ、RQ、IQ），找到自己与对标对象之间的差距，补足</li>
</ul>
</li>
</ul>
</li>
<li><p>制定发展计划</p>
<ul>
<li>甘特图，小目标转化为计划</li>
</ul>
</li>
<li><p>总结：工具包</p>
<img src="/2019/08/27/%E5%A6%82%E4%BD%95%E5%81%9A%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/0.jpg" class="">
</li>
<li><p>延伸问题</p>
<ul>
<li>如果第一步就卡住了怎么办<br> 不着急，但是无论无何要把它搞出来。 </li>
<li>为什么我的目标不够坚定<br> 有红利期，就有人扑上去，那我扑不扑。</li>
</ul>
</li>
</ol>
<p>可能的解法</p>
<img src="/2019/08/27/%E5%A6%82%E4%BD%95%E5%81%9A%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/a.png" class="">

<h4 id="感谢："><a href="#感谢：" class="headerlink" title="感谢："></a>感谢：</h4><blockquote><footer><strong>用麦肯锡思维做职业规划</strong><cite><a href="https://m.qlchat.com/topic/details?topicId=2000005041181222&kfAppId=wx831c57337f22d123&kfOpenId=oCbyZ0S8wRNxulWNSM2fKNeI2xB4">圈外同学-很帅的投资客</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>始于愤怒必终于羞愧</title>
    <url>/2019/07/18/%E5%A7%8B%E4%BA%8E%E6%84%A4%E6%80%92%E5%BF%85%E7%BB%88%E4%BA%8E%E7%BE%9E%E6%84%A7/</url>
    <content><![CDATA[<p><strong>圆桌派</strong>第四季中有一期《情绪：你心情好吗？心能管理吗？》中，窦文涛先生讲了一句话<strong>始于愤怒必终于羞愧。</strong></p>
<p>真的建议大家挤出一些时间看看<strong>圆桌派</strong>，四剑客在一起时是最好看的，聊的东西真的挺有收获。</p>
<p>这一期我印象最深的就是这句话：<strong>始于愤怒必终于羞愧</strong>。</p>
<p>因为我一回想当自己愤怒时候的样子和做的事说的话，大多数情况下等平静之后都会有一股愧疚感，会感到很羞愧。而你要知道这样的伤害特别是对他人可能是永久的，很多时候你根本找补不回来。</p>
<p>所以当你愤怒的时候，或者你觉得你情绪有问题的时候用下面的语录来一遍，可能这事就过去了。</p>
<h3 id="语录："><a href="#语录：" class="headerlink" title="语录："></a>语录：</h3><ol>
<li>有时候事情的沉重程度只是源于自己当时的情绪，当情绪改变了，对同一件事情的看法也就发生了改变。</li>
<li>出身不太好的人往往在人际交往中有很强的自我觉察，对自己的观点不够自信。</li>
<li>有些不良情绪在同相应的对象进行了表达之后会降低（对别人的嫉妒，说出来之后就会变好）。</li>
<li>王阳明心学：吾性自足。需要心胸足够开阔，装下自己，也要装下别人。</li>
<li>不快乐的原因是太过关注自己的情绪，所以快乐的方式是注意力向外，多关注生活，同时这也是将整个世界放到自己的心胸里，让自己变得开阔。</li>
<li>如果在情绪激动的时候，可以分离出一个自觉，能够看到自己正在愤怒中，就不会失控。</li>
<li>温度计测量温度的高低，但其本身没有温度的变化，所以才能测量温度。人的情绪也需要这样一个不会变化的量尺。</li>
<li>环境影响人对事情的接受程度</li>
<li>内在与外在的二元对立关系需要达到平衡。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> 共勉吧，愤怒通常是瞬间发生的，先强制断一下节奏，不让愤怒和接下来的言行无缝衔接，不管用什么方式有意的断一下节奏之后，就算依然愤怒依然付诸言行也会合理很多。</p>
<p>我就是这样做的，大多数情况下…</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>XSS、SQL注入</title>
    <url>/2019/09/27/%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<img src="/2019/09/27/%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F/shield.jpg" class="" title="Image by marian anbu juwan from Pixabay">

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于某些客户现场以及我们公司自身的要求，产品上线之前都会有一轮的安全扫描，用AppScan等这类工具扫一扫，最近就处理了几个安全扫描的问题，虽说处理的比较原始但是还是需要记录一下，你晓得哇，因为比较折磨人。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>什么交XSS、SQL注入网上一大堆我就不出丑了哈，要解决这块问题那就先得搞清楚AppScan这类软件的工作原理。</p>
<p>AppScan 工作原理小结如下：</p>
<ul>
<li>通过爬行配置的整个 Web 应用，了解其结构找到接口等信息</li>
<li>根据分析的结果，发送修改后的Request 进行攻击尝试（扫描规则库模拟XSS、SQL注入等操作）</li>
<li>最后分析 Respone ，验证是否符合预期是否存在安全漏洞</li>
</ul>
<p>所以由此看出处理XSS、SQL注入等问题只能在第二个和第三个环节出手。</p>
<h3 id="处理姿势"><a href="#处理姿势" class="headerlink" title="处理姿势"></a>处理姿势</h3><p>处理这类问题我所知道的通常就3种姿势：</p>
<ol>
<li><p>拦截</p>
<p>触发了这类校验直接拦截掉并提示不让其做任何操作，简单粗暴但是不人性化。经常让人很懵逼。</p>
</li>
<li><p>替换</p>
<p>把可触发这类校验的关键字全部替换为其它字符或者转换为字符串等。这种容易破坏原有的表达。</p>
</li>
<li><p>加密</p>
<p>这是种欺骗扫描软件的方式，直接前后端约定加密方式，对所有的输入进行统一加密，后端再统一解密，这样扫描软件识别不了任何关键字。我同事就这样干过，虽然说性能上会有一点问题但是好在不用动任何代码。嗯，这种只能说骚操作。</p>
</li>
</ol>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>最后和架构师定的方式是通过filter+正则这种最原始最简单的方式来做，我们这是toB的运维系统所以让大家失望了没上高大上的安全策略。</p>
<img src="/2019/09/27/%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F/1.png" class="">

<h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>需要先搞清楚为什么需要处理输入流，因为 reqeust.getInputStream 方法只能读取一次。我们可以大概捋一下是咋回事。</p>
<p>我们需要输入流所以需要调用reqest.getInputStream()，getInputStream返回值为ServletInputStream，所以我们先看看ServletInputStream。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ServletInputStream extends InputStream &#123;</span><br><span class="line">    protected ServletInputStream() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int readLine(byte[] b, int off, int len) throws IOException &#123;</span><br><span class="line">        if (len &lt;= 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line"></span><br><span class="line">            int c;</span><br><span class="line">            while((c = this.read()) != -1) &#123;</span><br><span class="line">                b[off++] = (byte)c;</span><br><span class="line">                ++count;</span><br><span class="line">                if (c == 10 || count == len) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return count &gt; 0 ? count : -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract boolean isFinished();</span><br><span class="line"></span><br><span class="line">    public abstract boolean isReady();</span><br><span class="line"></span><br><span class="line">    public abstract void setReadListener(ReadListener var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后知道是继承自InputStream，所以我们先看InputStream，注意read和reset方法。</p>
<p>read方法告诉我们会从输入流一直读取下一个字节、如果以达到末尾侧返回-1。</p>
<p>reset告诉我们可以<strong>重置</strong>读取的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class InputStream implements Closeable &#123;</span><br><span class="line"></span><br><span class="line">    // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to</span><br><span class="line">    // use when skipping.</span><br><span class="line">    private static final int MAX_SKIP_BUFFER_SIZE = 2048;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reads the next byte of data from the input stream. The value byte is</span><br><span class="line">     * returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to</span><br><span class="line">     * &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the stream</span><br><span class="line">     * has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. This method</span><br><span class="line">     * blocks until input data is available, the end of the stream is detected,</span><br><span class="line">     * or an exception is thrown.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; A subclass must provide an implementation of this method.</span><br><span class="line">     *</span><br><span class="line">     * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span><br><span class="line">     *             stream is reached.</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     */</span><br><span class="line">    public abstract int read() throws IOException;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Repositions this stream to the position at the time the</span><br><span class="line">     * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; The general contract of &lt;code&gt;reset&lt;/code&gt; is:</span><br><span class="line">     *</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns</span><br><span class="line">     * &lt;code&gt;true&lt;/code&gt;, then:</span><br><span class="line">     *</span><br><span class="line">     *     &lt;ul&gt;&lt;li&gt; If the method &lt;code&gt;mark&lt;/code&gt; has not been called since</span><br><span class="line">     *     the stream was created, or the number of bytes read from the stream</span><br><span class="line">     *     since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument</span><br><span class="line">     *     to &lt;code&gt;mark&lt;/code&gt; at that last call, then an</span><br><span class="line">     *     &lt;code&gt;IOException&lt;/code&gt; might be thrown.</span><br><span class="line">     *</span><br><span class="line">     *     &lt;li&gt; If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the</span><br><span class="line">     *     stream is reset to a state such that all the bytes read since the</span><br><span class="line">     *     most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the</span><br><span class="line">     *     file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied</span><br><span class="line">     *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by</span><br><span class="line">     *     any bytes that otherwise would have been the next input data as of</span><br><span class="line">     *     the time of the call to &lt;code&gt;reset&lt;/code&gt;. &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns</span><br><span class="line">     * &lt;code&gt;false&lt;/code&gt;, then:</span><br><span class="line">     *</span><br><span class="line">     *     &lt;ul&gt;&lt;li&gt; The call to &lt;code&gt;reset&lt;/code&gt; may throw an</span><br><span class="line">     *     &lt;code&gt;IOException&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     *     &lt;li&gt; If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream</span><br><span class="line">     *     is reset to a fixed state that depends on the particular type of the</span><br><span class="line">     *     input stream and how it was created. The bytes that will be supplied</span><br><span class="line">     *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the</span><br><span class="line">     *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt;</span><br><span class="line">     * does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @exception  IOException  if this stream has not been marked or if the</span><br><span class="line">     *               mark has been invalidated.</span><br><span class="line">     * @see     java.io.InputStream#mark(int)</span><br><span class="line">     * @see     java.io.IOException</span><br><span class="line">     */</span><br><span class="line">    public synchronized void reset() throws IOException &#123;</span><br><span class="line">        throw new IOException(&quot;mark/reset not supported&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以从上面可以得知ServletInputStream是没有重写r关键的reset方法，所以行为是与InputStream保持一致的即输入流读取一遍之后就没了后续就一直返回-1。</p>
<p>所以解决办法就是找到重写reset的方法的类，即就找到我们常用的ByteArrayInputStream也是继承自InputStream，但是其重写了reset等方法。</p>
<p>我们看下源码：</p>
<p>注意read里面的<strong>pos</strong>变量，它是标识现在读取的流的位置，所以如果我们想多次读取输入流，需要调用上面说的reset方法重置pos为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">class ByteArrayInputStream extends InputStream &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The currently marked position in the stream.</span><br><span class="line">     * ByteArrayInputStream objects are marked at position zero by</span><br><span class="line">     * default when constructed.  They may be marked at another</span><br><span class="line">     * position within the buffer by the &lt;code&gt;mark()&lt;/code&gt; method.</span><br><span class="line">     * The current buffer position is set to this point by the</span><br><span class="line">     * &lt;code&gt;reset()&lt;/code&gt; method.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * If no mark has been set, then the value of mark is the offset</span><br><span class="line">     * passed to the constructor (or 0 if the offset was not supplied).</span><br><span class="line">     *</span><br><span class="line">     * @since   JDK1.1</span><br><span class="line">     */</span><br><span class="line">    protected int mark = 0;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * The index of the next character to read from the input stream buffer.</span><br><span class="line">     * This value should always be nonnegative</span><br><span class="line">     * and not larger than the value of &lt;code&gt;count&lt;/code&gt;.</span><br><span class="line">     * The next byte to be read from the input stream buffer</span><br><span class="line">     * will be &lt;code&gt;buf[pos]&lt;/code&gt;.</span><br><span class="line">     */</span><br><span class="line">    protected int pos;</span><br><span class="line">    /**</span><br><span class="line">     * Reads the next byte of data from this input stream. The value</span><br><span class="line">     * byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range</span><br><span class="line">     * &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available</span><br><span class="line">     * because the end of the stream has been reached, the value</span><br><span class="line">     * &lt;code&gt;-1&lt;/code&gt; is returned.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This &lt;code&gt;read&lt;/code&gt; method</span><br><span class="line">     * cannot block.</span><br><span class="line">     *</span><br><span class="line">     * @return  the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span><br><span class="line">     *          stream has been reached.</span><br><span class="line">     */</span><br><span class="line">    public synchronized int read() &#123;</span><br><span class="line">        return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">     * Resets the buffer to the marked position.  The marked position</span><br><span class="line">     * is 0 unless another position was marked or an offset was specified</span><br><span class="line">     * in the constructor.</span><br><span class="line">     */</span><br><span class="line">    public synchronized void reset() &#123;</span><br><span class="line">        pos = mark;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>这些搞清楚之后就是看怎么能在到咱们的filter的时候得到的request是可以读取多次同时又不影响其它地方的读取（比如controller），刚好severlet.api提供了一个叫HttpServletRequestWrapper的东西，刚好提供一种包装（专业名词：装饰器模式）的手法让我们可以包装request请求对象使其可扩展其它能力。包装高富帅哪里都吃得开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Gamehu</span><br><span class="line"> * @date 2019/5/9 18:32</span><br><span class="line"> * @description sql注入问题，前置处理输入流，避免输入流获取一次以后失效导致系统异常</span><br><span class="line"> */</span><br><span class="line">public class xxxHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(SqlInjectHttpServletRequestWrapper.class);</span><br><span class="line">    /**</span><br><span class="line">     * 存储请求输入流</span><br><span class="line">     */</span><br><span class="line">    private byte[] body;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public SqlInjectHttpServletRequestWrapper(HttpServletRequest request) &#123;</span><br><span class="line">        super(request);</span><br><span class="line">        try &#123;</span><br><span class="line">            body = inputStreamToByte(request.getInputStream());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw RiilExceptionUtils.bizException(e, BaseWebErrorCode.SecurityConstant.ERROR, BaseWebErrorMsg.SecurityConstant.ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 流转 字节数组</span><br><span class="line">     *</span><br><span class="line">     * @param is</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    private byte[] inputStreamToByte(InputStream is) throws IOException &#123;</span><br><span class="line">        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        int ch;</span><br><span class="line">        while ((ch = is.read(buffer)) != -1) &#123;</span><br><span class="line">            byteStream.write(buffer, 0, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] data = byteStream.toByteArray();</span><br><span class="line">        byteStream.close();</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedReader getReader() &#123;</span><br><span class="line">        return new BufferedReader(new InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写方法用于多次获取流，防止读取用于校验过后，后面服务无法获取参数的情况</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() &#123;</span><br><span class="line">        final ByteArrayInputStream bais = new ByteArrayInputStream(body);</span><br><span class="line">        return new ServletInputStream() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isFinished() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span><br><span class="line">                LOGGER.info(&quot;setReadListener&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int read() &#123;</span><br><span class="line">                return bais.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>OK，到这儿输入流总算搞定了，nice，然后开始Filter上场了。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Gamehu</span><br><span class="line"> * @date 2018/12/20 15:18</span><br><span class="line"> * @description  XSS、SQL注入校验</span><br><span class="line"> */</span><br><span class="line">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;xxFilter&quot;)</span><br><span class="line">public class xxFilter implements Filter &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        ...</span><br><span class="line">        //安全扫描问题（sql注入、xss）处理，对参数进行校验</span><br><span class="line">        securityScanParamsValidate(filterChain, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 安全扫描问题（sql注入、xss）处理，对参数进行校验</span><br><span class="line">     *</span><br><span class="line">     * @param filterChain</span><br><span class="line">     * @param response</span><br><span class="line">     * @param request</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     */</span><br><span class="line">    private void securityScanParamsValidate(final FilterChain filterChain, final HttpServletResponse response, final HttpServletRequest request) throws IOException, ServletException &#123;</span><br><span class="line">        final  String paramsAndValues = SecurityScanUtil.extractPostRequestBody(request);</span><br><span class="line">        if (StringUtils.isEmpty(paramsAndValues)) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据参数是否能转换为json，执行不同的校验</span><br><span class="line">            parseParamAndValidate(filterChain, response, request, paramsAndValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void parseParamAndValidate(final FilterChain filterChain, final HttpServletResponse response, final HttpServletRequest request, final String paramsAndValues) throws IOException, ServletException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final JSONObject paramsObj = JSONObject.parseObject(paramsAndValues);</span><br><span class="line">            if (paramsObj.size() == 0) &#123;</span><br><span class="line">                filterChain.doFilter(request, response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //对参数进行拆分校验，只校验每个参数值</span><br><span class="line">                jsonParamValidate(filterChain, response, request, paramsAndValues);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (JSONException ex) &#123;</span><br><span class="line">            LOGGER.error(&quot;isJSONValid，不是有效的JSON字符串,&#123;&#125;&quot;, ex.getMessage());</span><br><span class="line">            //参数不是合法地json格式则进行整句校验（不进行任何拆分）</span><br><span class="line">            notJsonParamValidate(filterChain, response, request, paramsAndValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 非json格式参数安全问题校验</span><br><span class="line">     *</span><br><span class="line">     * @param filterChain</span><br><span class="line">     * @param response</span><br><span class="line">     * @param request</span><br><span class="line">     * @param paramsAndValues</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     */</span><br><span class="line">    private void notJsonParamValidate(final FilterChain filterChain, final HttpServletResponse response, final HttpServletRequest request, final String paramsAndValues) throws IOException, ServletException &#123;</span><br><span class="line">        final String uri = request.getRequestURI();</span><br><span class="line">        // sql注入校验</span><br><span class="line">        if (SecurityScanUtil.execSqlInjectValidate(uri, NO_KEY, paramsAndValues)) &#123;</span><br><span class="line">            response.sendRedirect(SQL_INJECT_ERROR);</span><br><span class="line">        &#125; else if (XssUtil.xssMatcher(uri, NO_KEY, paramsAndValues)) &#123;</span><br><span class="line">            //xss校验</span><br><span class="line">            response.sendRedirect(XSS_ERROR);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * json格式参数安全问题校验（sql注入、xss）</span><br><span class="line">     *</span><br><span class="line">     * @param filterChain</span><br><span class="line">     * @param response</span><br><span class="line">     * @param request</span><br><span class="line">     * @param paramsAndValues</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     */</span><br><span class="line">    private void jsonParamValidate(final FilterChain filterChain, final HttpServletResponse response, final HttpServletRequest request, final String paramsAndValues) throws IOException, ServletException &#123;</span><br><span class="line">        //防sql注入校验</span><br><span class="line">        if (SecurityScanUtil.sqlInjectValidate(request.getRequestURI(), paramsAndValues)) &#123;</span><br><span class="line">            response.sendRedirect(SQL_INJECT_ERROR);</span><br><span class="line">        &#125; else if (SecurityScanUtil.xssValidate(request.getRequestURI(), paramsAndValues)) &#123;</span><br><span class="line">            //xss校验</span><br><span class="line">            response.sendRedirect(XSS_ERROR);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        LOGGER.info(&quot;destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @author Gamehu</span><br><span class="line"> * @description  Xss和Sql注入检查 工具类 </span><br><span class="line"> * @date 2019/5/10 9:54</span><br><span class="line"> */</span><br><span class="line">public class SecurityScanUtil &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(SecurityScanUtil.class);</span><br><span class="line">    private static final String GRAPHQL = &quot;graphql&quot;;</span><br><span class="line"></span><br><span class="line">    private SecurityScanUtil() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 单个参数的sql注入校验</span><br><span class="line">     *</span><br><span class="line">     * @param paramName</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String sqlInjectionValidate(final HttpServletRequest request, final String paramName, final String value) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 防sql注入，如果存在抛出校验异常</span><br><span class="line">         */</span><br><span class="line">        if (SqlInjectUtil.haveSqlInject(request.getRequestURI(), paramName, value)) &#123;</span><br><span class="line">            return &quot;sqlError&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取输入流中参数</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static String extractPostRequestBody(final HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        final Scanner s;</span><br><span class="line">        try &#123;</span><br><span class="line">            s = new Scanner(request.getInputStream(), &quot;UTF-8&quot;).useDelimiter(&quot;\\A&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw RiilExceptionUtils.bizException(e, BaseWebErrorCode.SecurityConstant.INPUTSTREAM_ERROR, BaseWebErrorMsg.SecurityConstant.INPUTSTREAM_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        return s.hasNext() ? s.next() : &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 效验sql注入问题</span><br><span class="line">     * &lt;h3&gt;SQL注入的几种方式：&lt;/h3&gt;</span><br><span class="line">     * &lt;pre&gt;</span><br><span class="line">     * 1) 使用 &#x27; or 语句，将查询条件扩大，实现破坏性查询（操作）</span><br><span class="line">     * 2) 使用 ; 将SQL分成两部分，在后面一部分实现破坏性操作</span><br><span class="line">     * 3) 使用注释，将后面的条件取消掉，将查询条件扩大，注意MySQL有三种注释的方法，都需要处理</span><br><span class="line">     *</span><br><span class="line">     * 为了简化处理，这里只考虑字符串类型参数注入情况（整型等其它类型在应用内部类型转换会失败，所以基本可以忽略）</span><br><span class="line">     * &lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static boolean sqlInjectValidate(final String uri, final String paramsAndValues) &#123;</span><br><span class="line">        //获取参数列表以及参数值</span><br><span class="line">        final JSONObject paramsObj = JSONObject.parseObject(paramsAndValues);</span><br><span class="line">        final Set&lt;String&gt; keys = paramsObj.keySet();</span><br><span class="line">        return keys.stream().anyMatch(key -&gt; haveSqlInjectCondition(uri, paramsObj, key));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 判断是否存在sql注入的表达式</span><br><span class="line">     *</span><br><span class="line">     * @param uri</span><br><span class="line">     * @param paramsObj</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static Boolean haveSqlInjectCondition(final String uri, final JSONObject paramsObj, final String key) &#123;</span><br><span class="line">        //graphql 不进行校验</span><br><span class="line">        if (key.equalsIgnoreCase(GRAPHQL)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        final String value = convertParamToString(paramsObj, key);</span><br><span class="line">        return SqlInjectUtil.haveSqlInject(uri, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 效验XSS问题</span><br><span class="line">     *</span><br><span class="line">     * @param uri</span><br><span class="line">     * @param paramsAndValues</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean xssValidate(final String uri, final String paramsAndValues) &#123;</span><br><span class="line">        //获取参数列表以及参数值</span><br><span class="line">        final JSONObject paramsObj = JSONObject.parseObject(paramsAndValues);</span><br><span class="line">        final Set&lt;String&gt; keys = paramsObj.keySet();</span><br><span class="line">        return keys.stream().anyMatch(key -&gt; haveXssCondition(uri, paramsObj, key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否存在xss的表达式</span><br><span class="line">     *</span><br><span class="line">     * @param uri</span><br><span class="line">     * @param paramsObj</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static boolean haveXssCondition(final String uri, final JSONObject paramsObj, final String key) &#123;</span><br><span class="line">        final String value = convertParamToString(paramsObj, key);</span><br><span class="line">        //判断是否存在xss攻击问题</span><br><span class="line">        return XssUtil.haveXss(value, key, uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理参数为字符串</span><br><span class="line">     *</span><br><span class="line">     * @param paramsObj</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static String convertParamToString(final JSONObject paramsObj, final String key) &#123;</span><br><span class="line">        final Object obj = paramsObj.get(key);</span><br><span class="line"></span><br><span class="line">        String value = null;</span><br><span class="line"></span><br><span class="line">        if (obj instanceof JSONObject) &#123;</span><br><span class="line">            value = ((JSONObject) obj).toJSONString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (obj instanceof JSONArray) &#123;</span><br><span class="line">            value = ((JSONArray) obj).toJSONString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (obj instanceof String) &#123;</span><br><span class="line">            value = (String) obj;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Gamehu</span><br><span class="line"> * @date 2019/9/26 12:12</span><br><span class="line"> * @description XSS校验的工具类</span><br><span class="line"> */</span><br><span class="line">public class XssUtil &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(XssUtil.class);</span><br><span class="line">    private static final String GRAPHQL = &quot;graphql&quot;;</span><br><span class="line">    private static Pattern[] patterns = new Pattern[]&#123;</span><br><span class="line">            // Script fragments</span><br><span class="line">            Pattern.compile(&quot;&lt;script&gt;(.*?)&lt;/script&gt;&quot;, Pattern.CASE_INSENSITIVE),</span><br><span class="line">            // src=&#x27;...&#x27;</span><br><span class="line">            Pattern.compile(&quot;src[\r\n]*=[\r\n]*\\\&#x27;(.*?)\\\&#x27;&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),</span><br><span class="line">            Pattern.compile(&quot;src[\r\n]*=[\r\n]*\\\&quot;(.*?)\\\&quot;&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),</span><br><span class="line">            // lonely script tags</span><br><span class="line">            Pattern.compile(&quot;&lt;/script&gt;&quot;, Pattern.CASE_INSENSITIVE),</span><br><span class="line">            Pattern.compile(&quot;&lt;script(.*?)&gt;&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),</span><br><span class="line">            // eval(...)</span><br><span class="line">            Pattern.compile(&quot;eval\\((.*?)\\)&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),</span><br><span class="line">            // expression(...)</span><br><span class="line">            Pattern.compile(&quot;expression\\((.*?)\\)&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),</span><br><span class="line">            // javascript:...</span><br><span class="line">            Pattern.compile(&quot;javascript:&quot;, Pattern.CASE_INSENSITIVE),</span><br><span class="line">            // vbscript:...</span><br><span class="line">            Pattern.compile(&quot;vbscript:&quot;, Pattern.CASE_INSENSITIVE),</span><br><span class="line">            // onload(...)=...</span><br><span class="line">            Pattern.compile(&quot;onload(.*?)=&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否存在xss攻击</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     * @param key</span><br><span class="line">     * @param uri</span><br><span class="line">     * @return true表示存在，false表示不存在</span><br><span class="line">     */</span><br><span class="line">    public static Boolean haveXss(final String value, final String key, final String uri) &#123;</span><br><span class="line">        if (key.equalsIgnoreCase(GRAPHQL)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return xssMatcher(value, key, uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean xssMatcher(final String value, final String key, final String uri) &#123;</span><br><span class="line">        if (StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">            Matcher matcher;</span><br><span class="line">            for (Pattern pattern : patterns) &#123;</span><br><span class="line">                matcher = pattern.matcher(value);</span><br><span class="line">                // 匹配</span><br><span class="line">                if (matcher.find()) &#123;</span><br><span class="line">                    LOGGER.error(&quot;存在xss风险,URI：&#123;&#125;，参数：&#123;&#125;,参数值：&#123;&#125;&quot;, uri, key, value);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Gamehu</span><br><span class="line"> * @date 2019/9/26 12:12</span><br><span class="line"> * @description SQL注入校验的工具类</span><br><span class="line"> */</span><br><span class="line">public class SqlInjectUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * SQL语法检查正则：只检查一个关键字可能存在误判情况，这里要求必须符合两个关键字（有先后顺序）才算匹配</span><br><span class="line">     * 第一组关键字</span><br><span class="line">     */</span><br><span class="line">    final static String sqlInjectGroup = &quot;select|update|and|or|delete|insert|trancate|char|into|substr|ascii|declare|exec|count|master|drop|execute&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造SQL语法检查正则</span><br><span class="line">     * (?i)忽略字母的大小写，\s.*空白+字符</span><br><span class="line">     */</span><br><span class="line">    final static Pattern sqlSyntaxPattern = Pattern.compile(&quot;(?i)(.*)\\b(&quot; + sqlInjectGroup + &quot; )\\b\\s.*&quot;, Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取输入流中参数</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static String extractPostRequestBody(final HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        final Scanner s;</span><br><span class="line">        try &#123;</span><br><span class="line">            s = new Scanner(request.getInputStream(), &quot;UTF-8&quot;).useDelimiter(&quot;\\A&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw RiilExceptionUtils.bizException(e, BaseWebErrorCode.SecurityConstant.INPUTSTREAM_ERROR, BaseWebErrorMsg.SecurityConstant.INPUTSTREAM_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        return s.hasNext() ? s.next() : &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行SQL注入校验</span><br><span class="line">     *</span><br><span class="line">     * @param uri</span><br><span class="line">     * @param key</span><br><span class="line">     * @param oldValue</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean haveSqlInject(final String uri, final String key, final String oldValue) &#123;</span><br><span class="line">        if (StringUtils.isNotBlank(oldValue)) &#123;</span><br><span class="line">            //统一转为小写</span><br><span class="line">            final String newValue = oldValue.toLowerCase();</span><br><span class="line">            final String logStr = &quot;存在sql注入风险,URL：&#123;&#125;，参数：&#123;&#125;,参数值：&#123;&#125;&quot;;</span><br><span class="line">            // 检查是否包含SQL注入敏感字符</span><br><span class="line">            if (sqlSyntaxPattern.matcher(newValue).find()) &#123;</span><br><span class="line">                LOGGER.error(logStr, uri, key, newValue);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 因为我们用了graphql，有些地方还用了dsl，所以正则是魔鬼，我写崩溃了差点，当然如果有更好的方法请告诉我，万分感谢。</p>
<p>长出一口气…..</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>安全扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2019/09/06/%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><strong>当你不够牛逼时，那就善用工具</strong></p>
<p>我简单整理了一下我最近比较常用的工具，也会摘一些做一些分析，多偏向于前端，因为最近前端写得多。</p>
<img src="/2019/09/06/%E5%B7%A5%E5%85%B7/tool.png" class="">

<p><a href="https://developer.chrome.com/docs/devtools/evaluate-performance/">chrome devtools</a></p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>工程师文化</title>
    <url>/2022/08/19/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96/</url>
    <content><![CDATA[<p>读陈皓老师的<a href="https://coolshell.cn/articles/17497.html%E6%9C%89%E6%84%9F%E3%80%82">https://coolshell.cn/articles/17497.html有感。</a></p>
<p><a href="https://brendansterne.com/2013/07/11/do-the-right-thing-wait-to-get-fired/">https://brendansterne.com/2013/07/11/do-the-right-thing-wait-to-get-fired/</a></p>
<p><a href="https://news.ycombinator.com/item?id=6029823">https://news.ycombinator.com/item?id=6029823</a></p>
<h3 id="有段话印象很深刻："><a href="#有段话印象很深刻：" class="headerlink" title="有段话印象很深刻："></a>有段话印象很深刻：</h3><h4 id="计划就是瞎猜"><a href="#计划就是瞎猜" class="headerlink" title="计划就是瞎猜"></a>计划就是瞎猜</h4><blockquote>
<p>除非你是算命先生，长期的商业计划是种幻想。有太多的事实证明那是超出你的掌控的：市场环境、对手、顾客、经济等等。做计划让你觉得一切尽在掌握但实际上你没有。<br>当你把计划变成猜测时，就等于进入一个危险的境地。做计划就是在用过去推导未来，等于给你戴上了眼罩。</p>
</blockquote>
<blockquote>
<p>感想：你有职业规划吗？如果你有的话，那么你就一定就错了。职业规划是一件很扯淡的事情。我和一些高手都交流过，其实这些人在当初都并不有什么职业规划的，要说有的话，也就是想把技术搞透搞精。这些人在一开始从来没有想过要当个什么经理或是什么架构师之类的东西，这些人就是对技术有非常大的热情，把身边的那些看得见够得着的事情做到好好地，并且保持不持续强大的好奇心努力地学习自己不懂的东西。一个坚定不移的决定和意志力会比任何的计划和职业规划都重要。你问问自己，想不想当程序员，能不能一辈子都当一个程序员，能不能写程序写一辈子？（关于做一辈子程序员这个事，大家可以看看我的新浪微博 ——没哪个行业能像计算机行业这么活跃、刺激和有趣了。不仅是新兴工业革命的主力，又渗入到所有的行业中，干一辈子值了。&#x2F;&#x2F;@_你亲爱的偏执狂: 程序员首先是工程师，Professional，就跟律师，医生一样，给大家解决问题；但是另一面呢，又是艺术家，创造新奇好玩的东西。这样的职业做一辈子有什么问题？）</p>
</blockquote>
<p><a href="http://www.effectiveengineer.com/blog/what-makes-a-good-engineering-culture">http://www.effectiveengineer.com/blog/what-makes-a-good-engineering-culture</a><br><a href="https://www.quora.com/Software-Engineering/What-makes-a-good-engineering-culture/answer/Edmond-Lau?share=1">https://www.quora.com/Software-Engineering/What-makes-a-good-engineering-culture/answer/Edmond-Lau?share=1</a></p>
<h3 id="1-优化迭代速度。"><a href="#1-优化迭代速度。" class="headerlink" title="1.优化迭代速度。"></a>1.优化迭代速度。</h3><ol>
<li>快速的迭代速度增加了工作动力和兴奋度</li>
<li>在基础设施方面，优化迭代速度意味着构建持续部署以支持快速验证、高测试覆盖率以减少构建和站点损坏、快速单元测试以鼓励人们运行它们，以及快速增量编译和重新加载以减少开发时间。</li>
<li>团队方面，快速的迭代速度意味着拥有一组强大的领导者来帮助协调和推动团队工作。</li>
</ol>
<h3 id="2-不懈地推动自动化。"><a href="#2-不懈地推动自动化。" class="headerlink" title="2. 不懈地推动自动化。"></a>2. 不懈地推动自动化。</h3><ol>
<li>自动化解决方案和编写重复性任务脚本很重要，因为它们可以让工程团队腾出时间来处理实际产品。自动化必须由数据和监控驱动。</li>
</ol>
<h3 id="3-构建正确的软件抽象。"><a href="#3-构建正确的软件抽象。" class="headerlink" title="3. 构建正确的软件抽象。"></a>3. 构建正确的软件抽象。</h3><ol>
<li>保持核心抽象的简单和通用可以减少对自定义解决方案的需求，并提高团队对通用抽象的熟悉度和专业知识。将团队的注意力集中在少数核心抽象上，这意味着通用库变得更加健壮，监控变得更加智能，性能特征得到更好的理解，测试变得更加全面。所有这些都有助于简化系统并减少操作负担。</li>
</ol>
<h3 id="4-通过代码审查来关注高代码质量。"><a href="#4-通过代码审查来关注高代码质量。" class="headerlink" title="4. 通过代码审查来关注高代码质量。"></a>4. 通过代码审查来关注高代码质量。</h3><pre><code>维护高质量的代码库可以提高整个工程团队的生产力。更简洁的代码更容易推理、更快地开发、更易于更改并且更不容易受到错误的影响。一个健康的代码审查过程使这成为可能。

建立一个及时的代码审查流程，无论是提交前还是提交后，都可以在几个方面提高代码质量。首先，知道有人会审查你的代码并且提交写得不好的代码可能会让你的队友失望的同行压力是对骇客、不可维护或未经测试的代码的强大威慑。其次，代码审查为代码审查者和作者提供了相互学习以编写更好的代码的机会。

如果工程团队的其他成员可以轻松访问代码审查，那么审查还带来以下好处：a）增加及时审查代码的责任，b）允许团队成员 - 特别是新成员 - 进行建模其他人的良好代码审查，以及 c) 加速传播最佳编码实践。

敏捷团队没有时间花在代码审查上的反驳忽略了很容易从编写不佳的代码中积累的技术债务。Ooyala 在其早期的启动阶段，用于优化以尽可能多地推出功能，而无需进行代码审查；结果是，虽然最初的产品可能更快地推向市场，但最终的代码修改起来很痛苦，我们花了一年多的时间重写脆弱的代码以消除技术债务。

就其规模而言，Google 会对所有代码进行预先提交的代码审查，但较小的团队不需要如此全面或严格，并且并非所有代码都需要以同样严格的方式审查。Ooyala 后来在我在那里时通过电子邮件对核心或有风险的更改进行了提交后审查。在 Quora，我们在Phabricator中进行了所有代码审查，主要是提交后，并对模型或控制器代码和视图代码应用不同的标准；对于敏感代码或新工程师的代码，我们要么进行预提交审查，要么尝试在提交代码后的几个小时内对其进行审查。
</code></pre>
<h3 id="5-保持互相尊重的工作环境。"><a href="#5-保持互相尊重的工作环境。" class="headerlink" title="5. 保持互相尊重的工作环境。"></a>5. 保持互相尊重的工作环境。</h3><p>   同行之间的尊重构成了任何类型的开放式沟通的基础。一个人们乐于挑战彼此想法的地方是一个通过辩论形成合理想法的地方。人们容易被冒犯的地方是关键反馈被隐瞒的地方。</p>
<h3 id="6-建立代码的共享所有权。"><a href="#6-建立代码的共享所有权。" class="headerlink" title="6. 建立代码的共享所有权。"></a>6. 建立代码的共享所有权。</h3><pre><code>    虽然个人精通代码库或基础设施的各个部分是很自然的，但没有人应该觉得他们拥有或是任何一个部分的唯一维护者。 

    在组织上，共享代码所有权提供了三个好处。首先，保持总线因子大于 1 可以减轻维护者的压力，并降低团队在维护者离开时的风险。这也使那个人很难无忧无虑地休假。

    其次，共享所有权使在特定领域不深入的工程师能够提供新的见解。它使工程师摆脱了他们被困在某些项目上的感觉，并鼓励他们从事各种项目，这有助于保持工作的趣味性并促进员工的学习和积极性。从长远来看，它降低了一些工程师感到停滞不前并决定离开的组织风险。

    第三，共享所有权还为在需要更快地完成战略目标时让多个团队成员蜂拥而至（来自敏捷开发的一种技术）共同解决高优先级问题奠定了基础。对于孤立的所有权，负担通常落在一两个人身上。
</code></pre>
<h3 id="7-投资自动化测试。"><a href="#7-投资自动化测试。" class="headerlink" title="7. 投资自动化测试。"></a>7. 投资自动化测试。</h3><p>  单元测试覆盖率和某种程度的集成测试覆盖率是管理一大群人的大型代码库而不不断破坏构建或产品的唯一可扩展方式。自动化测试为提高代码质量所需的大规模重构提供了信心和有意义的保护。在缺乏严格的自动化测试的情况下，工程团队或外包测试团队进行手动测试所需的时间很容易变得令人望而却步，并且很容易陷入一种害怕改进一段代码的文化，因为它可能会破坏。</p>
<p>  强大自动化测试将验证责任转移到原作者身上，减少不熟悉的人的投入。</p>
<h3 id="8-分配-20-的时间。"><a href="#8-分配-20-的时间。" class="headerlink" title="8. 分配 20% 的时间。"></a>8. 分配 20% 的时间。</h3><h3 id="9-建立学习和持续改进的文化。"><a href="#9-建立学习和持续改进的文化。" class="headerlink" title="9. 建立学习和持续改进的文化。"></a>9. 建立学习和持续改进的文化。</h3><h3 id="10-雇佣最好的。"><a href="#10-雇佣最好的。" class="headerlink" title="10. 雇佣最好的。"></a>10. 雇佣最好的。</h3><p>如果没有足够的工程经验，很难识别出要构建的正确抽象。如果没有其他聪明人来挑战你的想法并推动你走向简单，很容易陷入构建复杂事物的陷阱。</p>
<p>硅谷有句谚语，由史蒂夫·乔布斯（Steve Jobs）创造，“A 球员雇佣 A 球员。B 玩家雇佣 C 玩家。” 专注于招聘和聘用合适的人是困难的，但对于有效发展工程组织至关重要<br>因为低质量代码和团队中较弱的工程师带来的技术债务最终会伤害团队和产品。</p>
]]></content>
  </entry>
  <entry>
    <title>常用工具-windows版</title>
    <url>/2018/07/09/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-windows%E7%89%88/</url>
    <content><![CDATA[<p>为什么是windows版，能别问么。穷啊。这几款是我自己在用的。</p>
<p><strong>Everything</strong></p>
<img src="/2018/07/09/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-windows%E7%89%88/everything.png" class="" title="http:&#x2F;&#x2F;www.voidtools.com&#x2F;">

<p>文件搜索工具</p>
<blockquote><footer><strong>everything</strong><cite><a href="http://www.voidtools.com/">www.voidtools.com</a></cite></footer></blockquote>

<p><strong>Wox</strong></p>
<img src="/2018/07/09/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-windows%E7%89%88/Wox.png" class="">

<p>集合各种功能的搜索工具，强大的令人发指那种。</p>
<p><strong>Seer</strong></p>
<p>预览工具，敲空格就能预览各种文件，也是超好用。</p>
<p><strong>Listary</strong></p>
<img src="/2018/07/09/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-windows%E7%89%88/Listary.png" class="">

<p>定位，查找文件等功能。</p>
<p><strong>Snipaste</strong></p>
<p>截图工具轻巧好用。</p>
<p><strong>Mobaxterm</strong></p>
<p>免费的远程网络工具，功能非常多，几乎提供了所有重要的远程网络工具（如SSH、X11、RDP、VNC、FTP、MOSH等），以及Windows 桌面上的Unix命令（bash、ls、cat、sed、grep、awk、rsync等）。</p>
<p>Photo by <a href="https://unsplash.com/@joannakosinska?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Joanna Kosinska</a> on <a href="https://unsplash.com/s/photos/work?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p>
<p><strong>OBS-Studio</strong></p>
<p>录屏工具。</p>
<p><strong>Typora</strong></p>
<p>MD文档工具。</p>
<p><strong>Google 扩展</strong></p>
<p>Kami、Pocket、Fatkun、沙拉查词、Adblock、OneTab、Scroll To Top、Grammarly</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
<hr>
<p><strong>源引-冯大推荐的少数派：</strong></p>
<blockquote><footer><strong>windows系列</strong><cite><a href="https://sspai.com/">少数派</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>底层系统</title>
    <url>/2019/09/18/%E5%BA%95%E5%B1%82%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>今天看到一篇文章，是以我媳妇儿的男神马云老师为引得文章。</p>
<p>所有为了能更完美的适配我媳妇儿的诉求，当然我就毫不犹豫的要点进去的看看。</p>
<p>我心甚慰啊，是这两天引发我思考最多的文章，特此记录一下。</p>
<p>文章指出底层系统定义：那些驱动你的核心动力。</p>
<p><strong>体现在两个方面：大局观和是非观。</strong></p>
<p>是非观决定你能走多久。什么事能做什么事不能做，自己心里衡量。有界限。</p>
<p>大局观决定你能走多远。你想进步你的格局就要大于你的现状。</p>
<p>所以前者指引方向，后者决定边界。</p>
<p>所以当你想做什么的时候，先自省一下，自己的底层系统，看有没有bug。</p>
<p>其中<strong>大局观</strong>是我感慨最多也是我认为自己最需要严肃对待的。</p>
<p>虽然我这两年都在有意识的往这方面努力，但是还远远不够。</p>
<h3 id="记录下我粗糙的认识"><a href="#记录下我粗糙的认识" class="headerlink" title="记录下我粗糙的认识"></a>记录下我粗糙的认识</h3><p>我认为的大局观，首先需要对抗的就是，老守着自己的一亩三分地，事不关己高高挂起，满足于现状的状态（这也是我在正在经历的阶段），需要跳脱出来，换角度，纵向、横向的看自己看周围看世界。</p>
<p>说起来有点虚，我一开始看别人动不动用跳脱、升华、灵魂这类词语我就特别不屑，总觉得的是吹牛x。但是亲测真的有效，很多时候做某件事的时候我就强迫自己，重新审视一下要做的事。</p>
<p>那怎么才能重新审视呢，那就涉及到要需要换角色换角度了，那怎么才能换角色换角度呢，这个时候就会突然在头脑中会出现，自己扮演产品经理、研发总监（公司副总）、总经理的角色，另外还会出现一个专门发出质疑的“自己”。这时候你就会萌发很多很多想法，这时候你会发现你考虑事项的方式以及处理事项的方式往往会和你一开始你想的有出入（当然这里肯定有一个边界，那就是你得从你的现状出发），这种出入不见得一定优于之前的想法，但是它肯定会带来附加效果，这种附加效果有可能会来的快也可能来得晚，有可能好有可能坏，但是正因为这样我们才能不断修正自己，我想这种修正应该会让我向大局观进一步。</p>
<p>最近在看一本书《系统之美》，看起来有些艰涩，但是真的很受用，我觉得其中有句话就很符合我对大局观的理解</p>
<blockquote>
<p>重塑系统，发现更大的世界</p>
</blockquote>
<p>对于怎么才叫有大局观，我其实也没摸到精确的定义，但是这不妨碍我想得到她。人神奇的地方不就是能不断的折腾吗。能捏碎也能重塑。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我觉得作为程序员，别顽固（坚守哪个语言第一、接受不了改变…）、别看谁都不顺眼（你看那说话的SB、你看那写代码的SB、你看那群里发图的SB….）、别老想着对抗（产品、ucd、测试、运维….，感觉他么的一个公司全是你的敌人），我们应该多想想如果我保持现状到底跟自己的职业生涯、跟同事、跟领导、跟公司能带来什么。</p>
<p>我们是不是得抽时间找找自己？</p>
<img src="/2019/09/18/%E5%BA%95%E5%B1%82%E7%B3%BB%E7%BB%9F/lost-1605501_1920.jpg" class="" title="Image by Jan Alexander from Pixabay">



<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>度量DevOps四个关键指标</title>
    <url>/2021/03/01/%E5%BA%A6%E9%87%8FDevOps%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<img src="/2021/03/01/%E5%BA%A6%E9%87%8FDevOps%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87/a.jpg" class="">

<h3 id="交代"><a href="#交代" class="headerlink" title="交代"></a>交代</h3><p>最近看了篇Google出的关于DevOps的文章<a href="https://cloud.google.com/blog/products/devops-sre/using-the-four-keys-to-measure-your-devops-performance">《度量DevOps四个关键指标》</a>，在这儿做个记录。google翻译+蹩脚的自我理解，莫吐槽，将就看。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>通过六年的研究，<a href="https://cloud.google.com/blog/products/devops-sre/the-2019-accelerate-state-of-devops-elite-performance-productivity-and-scaling">DevOps研究与评估（DORA）</a>团队确定了四个关键指标，这些指标指示了软件开发团队的绩效： </p>
<ul>
<li><strong>部署频率</strong> - 成功发布产品的频率。</li>
<li><strong>变更前置时间</strong> - 变更从提交到发布所需要的时间</li>
<li><strong>变更失败率</strong> - 发布失败次数在部署中的占比</li>
<li><strong>恢复服务的时间</strong> - 从生产故障中恢复需要多长时间</li>
</ul>
<p>变更的部署频率和变更前置时间可以衡量速度，变更失败率和恢复服务的时间可以衡量稳定性。通过衡量这些价值，并不断进行迭代来改进它们，团队可以取得更好的业务成果。</p>
<p>然后说了一下google cloud的做法。后面跟google cloud提供的服务有关的就不翻译文字了。</p>
<img src="/2021/03/01/%E5%BA%A6%E9%87%8FDevOps%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87/q.png" class="" title="by 我">



<h3 id="指标计算"><a href="#指标计算" class="headerlink" title="指标计算"></a>指标计算</h3><p>本节讨论如何将DORA度量标准转换为系统级计算。DORA团队所做的原始研究是对真实的人进行调查，而不是收集系统数据并将指标存储到性能级别中，如下所示：</p>
<img src="/2021/03/01/%E5%BA%A6%E9%87%8FDevOps%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87/12.jpg" class="" title="by cloud.google.com&#x2F;devops">



<h3 id="部署频率"><a href="#部署频率" class="headerlink" title="部署频率"></a>部署频率</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个组织成功地部署到生产环境的百分比。</span><br></pre></td></tr></table></figure>

<p>部署频率是最容易收集的指标，因为它只需要一个表。但是，频率存储也是要计算的棘手元素之一。显示每日部署数量或每周获取平均部署数量将很简单明了，但指标是部署频率，而不是数量。</p>
<p>在“Four Keys”脚本中，当每周至少进行一次成功部署的中位数天数等于或大于三时，“部署频率”将落入“每日”时段。简而言之，要想部署频率值为“每日一次”，则必须在大多数工作日进行部署。同样，如果大多数部署都是一星期一次，则将是每周一次，然后是每月一次，依此类推。</p>
<p>接下来，则需要考虑是基于哪些原因及资源构成了成功的生产部署。您是否包括仅占5％流量的部署？80％？默认情况下，仪表板包括任何成功部署到任何级别的流量。  </p>
<h3 id="变更前置时间"><a href="#变更前置时间" class="headerlink" title="变更前置时间"></a>变更前置时间</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一次提交进入生产环境所花费的时间。</span><br></pre></td></tr></table></figure>

<p>“变更前置时间”度量标准需要两个重要的数据：何时发生提交和何时进行部署。这意味着对于每个部署，需要维护对应的更改的列表。使用部署表中的更改列表，每次数据的重新加入时同时获取相应的时间戳，用于计算中位数。 </p>
<h3 id="变更失败率"><a href="#变更失败率" class="headerlink" title="变更失败率"></a>变更失败率</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于生产环境部署失败的百分比</span><br></pre></td></tr></table></figure>

<p>变更失败率取决于两件事：尝试了多少次部署，多少次导致生产部署失败？</p>
<h3 id="恢复服务的时间"><a href="#恢复服务的时间" class="headerlink" title="恢复服务的时间"></a>恢复服务的时间</h3><p>“组织从生产<strong>故障</strong>中<strong>恢复</strong>需要多<strong>长时间</strong>”</p>
<p>要测量恢复服务的时间，您需要知道事件的创建时间和解决时间。还需要知道何时发生故障以及何时部署解决了该故障。与上一个指标类似，此数据可以来自任何故障管理系统。 </p>
<h3 id="仪表板"><a href="#仪表板" class="headerlink" title="仪表板"></a>仪表板</h3><p>这个就不多说了。</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>延宕</title>
    <url>/2019/10/31/%E5%BB%B6%E5%AE%95/</url>
    <content><![CDATA[<p><strong>延宕</strong>其实直白的说就是拖延的意思，有人就感觉了，装逼非要搞个不常见的，就是因为不常见所以你才会好奇啊，才会去查一下这个词时代表什么意思。良苦用心在于为了加深印象撒。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>此篇内容源起最近要准备进行一次分享，筛选分享主题时，想到了<strong>拖延</strong>，首先我自身就有这个问题，然后我敞开怀抱感受了一下，身边很多人都或多或少存在<strong>拖延</strong>的问题。</p>
<p><strong>目录</strong></p>
<ul>
<li>拖延原因分析</li>
<li>拖延的特征</li>
<li>造成的危害</li>
<li>怎么破</li>
</ul>
<p>首先这篇不是一个从心理学角度写的东西，当然咱也没这个段位。这是一个不严谨但具有严重个人色彩的分享，只在于刨析自己从而能给朋友们提供一些思考和建议。</p>
<h4 id="拖延原因分析"><a href="#拖延原因分析" class="headerlink" title="拖延原因分析"></a>拖延原因分析</h4><p>白话点说可能有下面四个原因：</p>
<ol>
<li>对成功所需的能力缺乏自信</li>
<li>对要去完成某个任务有反感心理：认定做事的过程中会遭遇很多困难，结局也会很惨</li>
<li><strong>目标和回报太遥远，感受不到对我有什么意义</strong></li>
<li><strong>无法自我约束，例如容易冲动和分心</strong></li>
</ol>
<p>加粗部分是我认为对我影响最突出的部分。</p>
<p>首先咱们得说导致拖延的因素有很多，具体你是哪一类，你可以买本《拖延心理学》对号入座。我暂时认为自己时拖延早期患者，所以列出的主要是自己审视有的。</p>
<h5 id="目标和回报太遥远，感受不到对我有什么意义"><a href="#目标和回报太遥远，感受不到对我有什么意义" class="headerlink" title="目标和回报太遥远，感受不到对我有什么意义"></a>目标和回报太遥远，感受不到对我有什么意义</h5><p>先分析一下，<strong>目标和回报太遥远，感受不到对我有什么意义</strong>，这个点其实很有意思，你回过头看一下自己列的目标也好还是flag之类的…，大多数都会有一个比较共通的点，那就是列的太大太虚，然后也没有反馈的环节。</p>
<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/a.png" class="" title="我的目标">

<p>上图所示就是以前我列的目标，注意看打勾的标识完成的，红圈的表示未达成的。我来自我检讨一下啊，首先打圈的一看就不符合smart原则，当然也没法用PDCA那套。第二个原因是这几个都没有进行反馈设定，这就让你总感觉这个目标好像老离我挺远，慢慢的就觉得没意思了，也没用积极性了。</p>
<p>但是相反打勾的我都完成了，主要有两方面的原因。</p>
<ol>
<li>这几个都是有明显的反馈环节的，比如团队分享，首先意义对我和对同事而言都是正向的。分享完之后也能收到同事给与的一些讨论和评价，这也是一个反馈的环节。这就让这件事变得有结束有结果有意义了，当然就有积极性。</li>
<li>这件事很具体，也比较小，跨越的周期不长，比较符合smart原则，事情就变得可达。</li>
</ol>
<h5 id="无法自我约束，例如容易冲动和分心"><a href="#无法自我约束，例如容易冲动和分心" class="headerlink" title="无法自我约束，例如容易冲动和分心"></a>无法自我约束，例如容易冲动和分心</h5><p>先根据 Tim Urban在TED的演讲，刨析一下拖延时的大脑活动情况，我觉得真是讲到我心里去了，具体大家可以搜一下演讲的名字叫&lt;<a href="http://open.163.com/newview/movie/free?pid=MBHQSM52F&mid=MBI15O7QE">你有拖延症吗</a>&gt;。</p>
<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/procrastination_brain.png" class="" title="wait but way">

<p>如上图在有拖延症的大脑里会有一只Monkey（分心&#x2F;诱惑），它经常会跳出来，告诉你其实你的时间还有很多，要不我们逛逛YouTobe、BiliBIli…，它会不断的骚扰你，最终你会沦陷让其掌握大脑。其实就是抵御不了诱惑，容易分心。那什么时候我们会突然警醒呢，就是有一个东西出现的时候，如下图，这个东西叫<strong>恐慌</strong>。它一来Monkey就被吓跑了，但是往往这个时候，已经来不及了，被动了。</p>


<h4 id="拖延特征"><a href="#拖延特征" class="headerlink" title="拖延特征"></a>拖延特征</h4><p>我们说说怎么辨别，你是否存在拖延这个问题。</p>
<ol>
<li><p><strong>看它是不是让你烦恼不已</strong></p>
<p>内在结果：必须承受某些内在情绪的折磨，从恼怒、后悔到强烈的自我谴责和绝望  </p>
<p>外在结果：影响家庭、工作、社交….</p>
</li>
<li><p><strong>在一开始，你往往信心满满</strong> </p>
<p>在完成目标的一开始，往往信心满满  ，但是最后其实都不能很好的的完成或者说完成不了，往往整个过程如下图。</p>
<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/b.png" class="" title="拖延心理学">
</li>
<li><p><strong>自我</strong></p>
<p>自我价值感 &#x3D;能力（具有独立性，反对受控制） &#x3D;表现（通过拖延，“我”说了算）,不愿意遵守那些不是我们自己所制定的规则并顺应别人的需要 。</p>
</li>
<li><p><strong>追求完美</strong></p>
<p>咋一看还挺牛x，原来拖延还有这么美丽的特征，但是注意我们这儿说的是<strong>适应不良型的完美主义</strong>，“完美主义”者往往对自己期待过高，不够现实，当无法实现这样的要求是，就不知所措。失望之余，通过拖延让自己从中退却。适应不良型的完美主义，对自己的要求跟对自己的表现的期待之间存在一种矛盾。</p>
</li>
</ol>
<h4 id="拖延的伤害"><a href="#拖延的伤害" class="headerlink" title="拖延的伤害"></a>拖延的伤害</h4><img src="/2019/10/31/%E5%BB%B6%E5%AE%95/huaiyi.jpg" class="" title="怀疑自己">

<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/wushen.jpg" class="" title="精神萎靡">

<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/ziwo.png" class="" title="变得自我">

<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/sikao.jpg" class="" title="无法实现自己的想法">

<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/xinli.jpg" class="" title="心理疾病">



<h4 id="怎么破"><a href="#怎么破" class="headerlink" title="怎么破"></a>怎么破</h4><p>说了那么多，最终咱们得找到解法，当然前提是你有拖延困扰并且你愿意付诸行动改变这个毛病。</p>
<p>以下是我亲身实践且认为效果良好的方子，现在我也还在这么做，这是个持久战别想着10天半个月就有多大的改变，也别相信什么21天就能养成xx习惯，普通人就踏踏实实干就行了。</p>
<h5 id="破法1：你得接受"><a href="#破法1：你得接受" class="headerlink" title="破法1：你得接受"></a><strong>破法1：你得接受</strong></h5><ul>
<li>​    接受自己能力有限这个事实得人不太会为此过于烦恼 。</li>
<li>​    接受遵守那些不是我们自己所制定的规则并顺应别人的需要。</li>
</ul>
<h5 id="破法2：和原因对上号"><a href="#破法2：和原因对上号" class="headerlink" title="破法2：和原因对上号"></a><strong>破法2：和原因对上号</strong></h5><ul>
<li>看看这方面的书以及专业的一些心理视频或者找心理方面的人士咨询，找到自身造成的拖延的原因，才能对症下药，人是个体，个体就有差异千万别总去套别人那套方法论，要找到适合自己的。</li>
</ul>
<h5 id="破法3：明确的目标与可行性的计划"><a href="#破法3：明确的目标与可行性的计划" class="headerlink" title="破法3：明确的目标与可行性的计划"></a><strong>破法3：明确的目标与可行性的计划</strong></h5><p>找到一个目标，然后将它分解成几个小的步骤，跨出小小的第一步，学习怎样记录时间，以及如何优化周围环境使之向有利于成功的方向推进。</p>
<img src="/2019/10/31/%E5%BB%B6%E5%AE%95/target.png" class="">

<ul>
<li><p>目标smart且够小，可达。既非常小，又可以给你带来进步感和成就感。</p>
</li>
<li><p>执行过程中引入监督、奖惩机制  </p>
</li>
<li><p>整个执行目标的过程按照PDCA不断循环</p>
</li>
<li><p><strong>训练强大的执行力</strong>  </p>
<blockquote>
<p>执行能力的基本要素：注意力控制、 认知弹性、 目标设定、 信息处理  </p>
<p>1.启动任务（起始，产生行动的想法）。</p>
<p>2.维持注意力（持续跟进，专注于一个事项）。 </p>
<p>3.抑制冲动（在行动前有所思考，而不是马上反应）。 </p>
<p>4.转换注意力（从一个事项到另一个事项，转变关注的焦点，有弹性地加以回应）。 </p>
<p>5.流程记忆（记得计划、指令和以前学到的知识，在学习新知识和应对新环境的时候可以记起和运用到旧的知识）。</p>
<p>6.情绪控制（调整和管理情绪）。 </p>
<p>7.组织材料（获取所需的材料，并依序编排）。</p>
<p>8.自我监测（具备自我评价的相应语言能力，在必要的时候能够通过自我交谈闯过难关）。 </p>
<p>9.时间管理（时间意识，以及对待时间的务实态度）。 </p>
<p>10.计划（按优先次序考虑问题，找出达成目标的各个步骤，提前为以后的需要和相关进程做好准备）</p>
</blockquote>
</li>
</ul>
<h5 id="破法4：学会怎样判断时间"><a href="#破法4：学会怎样判断时间" class="headerlink" title="破法4：学会怎样判断时间**"></a><strong>破法</strong>4：学会怎样判断时间**</h5><blockquote>
<p>时间四象限</p>
<p>学会利用零碎时间</p>
<p><strong>预防意外干扰，抵制诱惑</strong></p>
<p>不要太分散精力</p>
<p>找出你的最佳时间</p>
<p>享受你的“自由”时间</p>
</blockquote>
<ul>
<li>主观时间和客观时间，做到平滑过渡。很多人就是忽略客观时间所以才老是导致拖延，时间不是跟着你的意志走的。</li>
<li>列出“非计划”时间，除开必须做的事情，剩下多少时间可以用于实现你的目标，给他排出来。</li>
<li>积极的时间约束（番茄工作法…），主要是提高专注力，人不可能24小时都是专注的，就算你说你可以那请你看看猝死的例子…</li>
</ul>
<h5 id="破法5：积极一点"><a href="#破法5：积极一点" class="headerlink" title="破法5：积极一点"></a><strong>破法5：积极一点</strong></h5><p>记住一点：不断地否定自己或者消极对待是要消耗很多能量地。</p>
<p>领导告诉了我一句话：<strong>如果你今年没觉得去年的自己是个SB那你就没有在成长</strong>，所以别动不动就沮丧、消极。</p>
<p>所以又对应上前面说的，要从一个个小成就不断地激励自己。</p>
<p> <strong>破法6：利用你的身体减轻拖延</strong> </p>
<p>锻炼，很多人一提到锻炼就会马上接一个词“身体”，其实锻炼不仅仅是锻炼身体其实还是一种脑力的、心理的活动，锻炼是一种释放，通常锻炼你是不会受其他东西影响的，比如你不能玩手机不能看电视等等…这就迫使你专注起来，并且大脑会开始想事情，有点类似冥想的意思。</p>
<p>你的大脑是比较放空的，你可以进行整理、归纳、思考等一系列活动，同时锻炼完事之后又特别爽，释放了身体和心理上的一些无用的东西。</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>开源软件的版本</title>
    <url>/2021/06/21/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<img src="/2021/06/21/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC/a.jpg" class="" title="Photo by athree23 on Pixabay">

<p>这两天不是React 18[1] duang的一下炸了吗？刚好在了解的过程中看到了React工作组的发布计划[2]</p>
<p>个人觉得是写的很清晰，把不同阶级的版本都进行了说明，在这儿简单说一下每种版本代号的含义。</p>
<h3 id="Apha"><a href="#Apha" class="headerlink" title="Apha"></a>Apha</h3><p>内部测试版，主要是针对社区内部人员发布的。α是希腊字母的第一个，表示最早的版本，一般不建议下载这个版本，这个版本包含很多BUG，功能也不全，因为主要是给开发人员和测试人员测试和找BUG用的。</p>
<h3 id="Beta"><a href="#Beta" class="headerlink" title="Beta"></a>Beta</h3><p>公开测试版。β是希腊字母的第二个，顾名思义，这个版本在alpha版之后，主要是给一些相关的社区以及忠实的用户测试用的，该版将包含最终版本的所有重大更改和新功能，但是仍然存在一些未发现的BUG，但是相对alpha版要稳定一些。所以还是为了收到反馈并发现任何遗留问题。</p>
<p>如果是负责基础能力的代码大哥们，实在着急的可以开始使用这个版本，主要是测试一下新功能以及升级方面的问题，提前入场准备。</p>
<h3 id="RC"><a href="#RC" class="headerlink" title="RC"></a>RC</h3><p>Release Candidate（候选版本），该版本不会再有新增的功能，所以是最接近最终版的版本。该版本的功能已经比较完整和稳定，rc的发布标志着最终版即将到来，rc主要是收集一下版本的稳定性以及用户满意度方面的数据。</p>
<p>这个版本其实一般用户可以下场练手了。</p>
<h3 id="Stable"><a href="#Stable" class="headerlink" title="Stable"></a>Stable</h3><p>稳定版。这个就是最终发行版，你可以在里面遨游了。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><code>[1]</code> React 18 介绍: <em><a href="https://github.com/reactwg/react-18/discussions/4">https://github.com/reactwg/react-18/discussions/4</a></em><br><code>[2]</code> React 18发布计划: <em><a href="https://github.com/reactwg/react-18/discussions/9">https://github.com/reactwg/react-18/discussions/9</a></em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么做好Presentation</title>
    <url>/2019/09/22/%E6%80%8E%E4%B9%88%E5%81%9A%E5%A5%BDPresentation/</url>
    <content><![CDATA[<p>近段时间刚好，做的分享和听的分享较多。刚好缘分就是那么奇妙，在一个网课平台刚好看到了这个网课《如何提高Presentation的展现能力》，在此做个记录。</p>
<p><strong>图1</strong>所阐述的观点，是我个人觉得做得最契合的。确实我一直认为，Presentation别弄太多文字类或者花哨的东西，PPT应该是辅助我们说明白一个事情，所以主次需要分清。</p>
<img src="/2019/09/22/%E6%80%8E%E4%B9%88%E5%81%9A%E5%A5%BDPresentation/1.png" class="" title="图1">

<p><strong>图2</strong>所说几个点</p>
<ul>
<li><p>底稿我觉得如果是很正式或者很重要的Presentation是个很好的减少风险的点。</p>
</li>
<li><p>另外关于互动，这点是很重要的，不管是眼神还是肢体还是语言，他能让讲解人和听众建立联系，如果没有互动，那就感觉像是下命令了，你们只管听我只管讲，不能有异议这样的场景特别糟糕。</p>
</li>
<li><p>时间管理特别重要，我特别厌烦那种拖沓的，慢条斯理的Presentation，让氛围很疲惫，这种效果很差，这点我也需要改进，虽然我很注意时间控制，但是也没有做到掐表的程度，但是我认为有些情况是可以掐表，比如做分享。</p>
</li>
</ul>
<img src="/2019/09/22/%E6%80%8E%E4%B9%88%E5%81%9A%E5%A5%BDPresentation/2.png" class="" title="图2">

<p><strong>图3</strong>是我最没有底气的点，Presentation事后的修正和反思做得比较少，特别是修正，要想整个Presentation比较有质量，确实这块是不可或缺的，尽量不因此留下遗憾。</p>
<img src="/2019/09/22/%E6%80%8E%E4%B9%88%E5%81%9A%E5%A5%BDPresentation/3.jpg" class="" title="图3">

<p><strong>Presentation</strong>：我觉得可解释为：具有分享、议题、同步等性质的会议。</p>
<p>图片摘自：<blockquote><footer><strong>如何提高Presentation的展现能力</strong><cite><a href="https://m.qlchat.com/topic/details?topicId=2000003738397093">圈外同学-Andy Pan</a></cite></footer></blockquote></p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>Presentation</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么让工作更加高效</title>
    <url>/2018/12/26/%E6%80%8E%E4%B9%88%E8%AE%A9%E5%B7%A5%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88/</url>
    <content><![CDATA[<p>最近报了一个课程-<strong>告别低效，人人必备的聪明工作法</strong>,少数派出品。</p>
<p>其实很早以前就接触了相关的内容，还买了几本书，买了几个工具，其中有本书对我还是比较有用的，这本书更多强调的是工具，是术的方面，让我学会了用工具做时间管理。比如番茄钟、滴答清单等。</p>
<p>之所以再报这门课程是为因为，之前的时间管理训练做的不是很好，没有坚持下来，国外传来的四象限法、GTD、SMART、精力管理…这些很多地方出现的词语，主要还是讲思路方面的问题，对于我来说现在可能能真正落地的更合适，而这门课程里面的某些内容就是我需要的，同时想要通过这门课程让自己能更加重视提升工作效率的重要性，能提升一点也是好的。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>这个应该是我做的最差的，文件都是摆满桌面，一通找，不过后来我找到了两个工具，超级超级超级好用，<strong>Everything+Wox</strong> 这两个东西真的是帮了我的大忙，让我不至于老是风中凌乱。我是觉得这两个就已经基本上解决了我的诉求，让我能快速的找到我的文件，不过稍有遗憾的是你的大概记得住你的文件名或者文件夹名才能有用，所以做好文件的管理是基础。课程中讲了一个工具<strong>Droplt</strong>，亲测好用，能根据我的规则帮我进行文件的分门别类。你也能设置自动分类。</p>
<h2 id="高效获取信息"><a href="#高效获取信息" class="headerlink" title="高效获取信息"></a>高效获取信息</h2><ul>
<li>信息源的质量<ul>
<li>信息源的半衰期（信息的有效时间）、信息源的稀缺程度（价值高低），通常是半衰期越长，稀缺程度越高。</li>
</ul>
</li>
</ul>
<img src="/2018/12/26/%E6%80%8E%E4%B9%88%E8%AE%A9%E5%B7%A5%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88/%E4%BF%A1%E6%81%AF%E6%BA%90.png" class="">

<ul>
<li>掌握信息获取的主动权<ul>
<li>获取信息尽量是通过pull而不是push（推送，通常不是有价值的信息），pull就表示是自己主动去寻找的信息</li>
<li>避免回声效应，即老是停留在自己的认知层面，屏蔽了外面的信息。</li>
</ul>
</li>
</ul>
<h2 id="浪起来的我-效率提升工具"><a href="#浪起来的我-效率提升工具" class="headerlink" title="浪起来的我-效率提升工具"></a>浪起来的我-效率提升工具</h2><p>我这儿就笼统的分享一下我为了提升效率而使用的一套工具，有些花钱有些用的免费的，这儿说的提升效率包括工作、学习、生活上的。</p>
<p><strong>工作节奏：</strong>滴答清单付费版、ToDoist、番茄土豆</p>
<p><strong>文件搜索：</strong>Everything、Wox</p>
<p><strong>学习：</strong>记录、收藏：印象笔记付费版，Pocket（稍后阅读）</p>
<p><strong>回顾：</strong>目标笔记</p>
<p>适合自己的才是最好的，你觉得用的爽然后确实有改善那就行了。</p>
<h2 id="学习提升方法论"><a href="#学习提升方法论" class="headerlink" title="学习提升方法论"></a>学习提升方法论</h2><p>在学习记忆中始终保持必要难度是必要的，这样才能训练自己的记忆能力。</p>
<p><strong>提升知识记忆的内化效果方法</strong></p>
<p>1.复述意识&#x3D;&gt;复述学习的内容，比如用康奈尔笔记法做知识回顾</p>
<img src="/2018/12/26/%E6%80%8E%E4%B9%88%E8%AE%A9%E5%B7%A5%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88/%E5%BA%B7%E5%A5%88%E5%B0%94%E7%AC%94%E8%AE%B0%E6%B3%95.png" class="">

<p>2.间隔学习，知识交叉，不能长时间一直学习某个知识，因为这样就没有保证记忆的难度。</p>
<p>3.费曼学习法&#x3D;&gt;把学到的知识讲给非专业人士听，用于检测自身是否对知识理解不到位，然后再反过头来深化</p>
<p><strong>记忆方法-记忆宫殿</strong></p>
<p>即把需要记忆的内容，抽象成图画，最终转化为情景式的关联记忆，因为人的空间记忆能力是超强的，所以用大脑的这块区域来记忆，坚持训练，肯定对记忆力有提升。我小试了几天，发现通过想象画面来记忆真的比死记硬背更有效且更有劲。</p>
<p>课程还提到了一个工具：anki，加强记忆力的工具。</p>
<img src="/2018/12/26/%E6%80%8E%E4%B9%88%E8%AE%A9%E5%B7%A5%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88/%E8%AE%B0%E5%BF%86.png" class="">


<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><ol>
<li><p>邮件FAST法则</p>
<img src="/2018/12/26/%E6%80%8E%E4%B9%88%E8%AE%A9%E5%B7%A5%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88/fast.png" class="" title="邮件FAST法则">
</li>
<li><p>邮件ABC法则</p>
</li>
</ol>
<img src="/2018/12/26/%E6%80%8E%E4%B9%88%E8%AE%A9%E5%B7%A5%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88/abc.png" class="" title="邮件ABC法则">

<ol start="2">
<li>思维导图做会议记录</li>
</ol>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>任务管理LTF体系：List（列表，行动项） Tag（标签，标识） Filter（过滤器，搜索）<br>邮件FAST法则：Fliter（过滤） Archive（归档） Transfer（流转） Snooze（延后）</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样保持动力</title>
    <url>/2019/04/14/%E6%80%8E%E6%A0%B7%E4%BF%9D%E6%8C%81%E5%8A%A8%E5%8A%9B/</url>
    <content><![CDATA[<p>浏览medium的时候发现了一位大佬，继而发现了她的<a href="https://www.preethikasireddy.com/post/how-do-you-stay-motivated">博客</a>，继而读到了一篇关于“动力”的文章。觉得说的很到位，很契合我现在正努力改变而采用的方式，那就是先动起来。</p>
<p><strong>这儿做个搬运工也做个自我的审视。</strong></p>
<p>每天，无数人都在为动力而苦苦挣扎，或者说，缺乏动力。他们渴望做得更多，做得更好，但他们根本没有这样做的动力。</p>
<img src="/2019/04/14/%E6%80%8E%E6%A0%B7%E4%BF%9D%E6%8C%81%E5%8A%A8%E5%8A%9B/panda.jpg" class="" title="Photo by Elena Loshina on Unsplash">

<p>结果，他们最终过着平庸的生活，因为他们<em>知道</em>自己有“潜力”，但他们从未选择追求这种潜力。他们安顿在相同的套路中，发现自己希望得到比他们所收到的更多的东西。</p>
<p>必须有一个更好的解决方案，对不对？</p>
<h2 id="我对动机问题的回答"><a href="#我对动机问题的回答" class="headerlink" title="我对动机问题的回答"></a>我对动机问题的回答</h2><p>我知道我知道。您现在可能会问我：“ <em>您如何保持动力？”</em> 。我的答案很简单：</p>
<p>我不会试图简单地“保持积极性”。<strong>我采取行动，动机随之而来。</strong></p>
<p>人们似乎认为这是相反的，我们必须等待动力来使我们采取行动。但这离事实还远！</p>
<p>动机不是一种神奇的能量，它只是神奇地独自出现。这是<strong>必须</strong>通过行动创造的力量。因此，真正有动力的唯一方法就是行动。如果您所做的只是将时间浪费在如意算盘上，那么您寻找的动力就永远不会到来。</p>
<p><strong>每个人（即使是最成功的人）在完成任务时也有同样的恐惧感。其实我们也知道有要做的事情，但是却因为自己不想做而挣扎。</strong></p>
<h2 id="不要想太多"><a href="#不要想太多" class="headerlink" title="不要想太多"></a>不要想太多</h2><p>在很多时候不想动的时，你得遵从你的内心而不是你的大脑，你的大脑总是会让你不动，因为它就是你的潜意识，但是从内心你知道你是应该要动起来的。所以这个时候遵从自己的内心赶紧挪动屁股动起来。</p>
<h4 id="要点：采取行动的人有动力。"><a href="#要点：采取行动的人有动力。" class="headerlink" title="要点：采取行动的人有动力。"></a>要点：<strong>采取行动的人有动力</strong>。</h4><p>动机是当我们渴望采取行动，而我们实际上遵循这一愿望时发生的事情。如果您想获得动力，则<strong>必须</strong>采取行动。我意识到这是一个自我实现的预言，但这正是我要提出的重点。</p>
<p>当您采取行动时，就会积蓄动力。动量推动着你前进，你想采取更多的行动。该行动将产生更多动力，依此类推。这是一个良性循环：正反馈回路。</p>
<p><img src="https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5dde0768ea47032aa8fb6c21_screen-shot-2019-10-28-at-1.34.39-pm.png" alt="img"></p>
<p>如果发现自己缺乏动力，请看一下自己的行为。如果您不采取行动，是时候开始努力了。不久之后，您会发现自己比想知道的要有更多的动力！</p>
<p>另一方面，<strong>零作用意味着零动量</strong>。如果您拒绝采取行动，那么您正在创建一个充满负面事物的空间。通常，这个空间充满<strong>思想</strong>：关于您应该如何或为什么或何时采取行动的想法。您的大脑过度分析了您想要完成的工作。您会发现自己正在思考完成动作所需的所有方式以及可能会失败的所有方式。</p>
<p>恐惧和焦虑开始发作。在这一点上，您实际上已经产生了消极的动力，并且您一开始就害怕要完成的一切。您开始下滑。</p>
<h4 id="您坐下来等待动力的时间越长，就会发现的越少。"><a href="#您坐下来等待动力的时间越长，就会发现的越少。" class="headerlink" title="您坐下来等待动力的时间越长，就会发现的越少。"></a><strong>您坐下来等待动力的时间越长，就会发现的越少。</strong></h4><p>当然，并非每种情况都要求您立即投入工作而不考虑应该采取的行动。例如，假设您需要与一个浪漫的伴侣进行艰难的谈话，以结束您的恋爱关系。您害怕伤害他们，害怕伤害自己。这种恐惧削弱了您的动力，使您无意继续进行对话，即使这是100％必要的。</p>
<p>你该怎么办？您是否应该让这种对话像暴风雨云一样继续笼罩着您，直到您对它感到厌倦为止，只是在没有真正思考的情况下跳入对话？</p>
<p>没有！</p>
<p>在这种情况下，思考如何最好地进行对话实际上是有帮助的。有远见的人会使您免于伤害任何人的感情。考虑如何完成一项动作与考虑实际完成所述动作之间存在巨大差异。您可能需要花费数周，数月甚至数年的时间思考实际做某事，却一无所获。您必须意识到自己的想法：如果您发现自己偏离批判性思维而进入可怕的领域，那么该是停止停顿并<strong>采取行动</strong>的时候了！</p>
<p>让我们回到眼前的场景。设置日期和您计划与伴侣进行对话的时间。设定时间和地点会让您负责。不要让自己对这一承诺退缩-放弃只是意味着欺骗自己。</p>
<p>在您履行了这一承诺之后，然后-仅那时！-您是否应该开始考虑动作本身。</p>
<p>通过提前计划并做出承诺，您实质上改变了您的思考过程。您现在<em>不再</em>是<em>“呃，我不想进行对话”，</em>而是以<em>“好吧，我在对话中实际上会说些什么？”</em>的心态。。这是非生产性思维与生产性思维的问题。</p>
<p>看到不同？😊</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>动机的“秘密”就是行动。如果您发现自己动力不足，则可能是因为无所作为。如果您想找到动力，就需要全身心投入并开始行动！</p>
<p>大小无关紧要。实际上，我建议您<strong>将其缩小</strong>。我们经常想尽可能地“完成很多工作”，但这是一个不好的方法，因为它耗尽了我们的意志力。取而代之的是，您应该采取足够的措施来增强动力，但要在压力开始感到沉重之前就停止。这样，您便有意愿回来以后再做更多的事情。</p>
<p>现在是您采取行动的时候了。</p>
<blockquote><footer><strong>Preethi Kasireddy</strong><cite><a href="https://www.preethikasireddy.com/post/how-do-you-stay-motivated">How do you stay motivated?</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>动力</tag>
      </tags>
  </entry>
  <entry>
    <title>我希望我是&#39;猫头鹰&#39;</title>
    <url>/2018/08/28/%E6%88%91%E5%B8%8C%E6%9C%9B%E6%88%91%E6%98%AF%E7%8C%AB%E5%A4%B4%E9%B9%B0/</url>
    <content><![CDATA[<img src="/2018/08/28/%E6%88%91%E5%B8%8C%E6%9C%9B%E6%88%91%E6%98%AF%E7%8C%AB%E5%A4%B4%E9%B9%B0/DlpAaqOWsAIz97B.jpg" class="" title="来源于Street Art Magic">

<p>首先解释一下啊 ，这儿的猫头鹰表示，晚睡晚起一族，当然我就是晚睡晚起一族，那为什么我还要说我希望呢，因为我想实现的是文章中对猫头鹰的定义，很显然我还没达到那种境界，所以是希望。</p>
<p>文章中的这句话是需要划重点的。这就是我的目标，哈哈哈哈…<strong>虽然俗语说”早睡早起，健康、聪明又富有”，但有一项研究表明，”猫头鹰”跟”百灵鸟”一样健康，一样聪明，甚至更加富有。</strong></p>
<blockquote><footer><strong>为什么不应该强迫自己早睡早起？</strong><cite><a href="https://www.bbc.com/ukchina/simp/vert-cap-42339836?ocid=socialflow_twitter">www.bbc.com/ukchina/simp/vert-cap-42339836?ocid=socialflow_twitter</a></cite></footer></blockquote>

<p>其实从文章中我们可以提取到几点信息。</p>
<ol>
<li>别听风就是雨的，实践见真知。</li>
<li>外国人挺闲（褒义）的，在我看来虽然不是什么高大上的课题，但是比我们所谓的国内专家靠谱多了，别人的出发点是探索，探索才能减少无知。</li>
<li>外国人看世界都是带着疑问、好奇、较真、求知的想法的，相比这一点我们国人太容易一刀切，这就是我认为当前我们的国人在认知上和欧美people最大的差距。</li>
<li>所谓实践见真知，是基于各种实验各种样本数据而得出的，不是你去炒了个番茄炒蛋，就能得出这应该是个荤菜的道理。</li>
</ol>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>百灵鸟</strong></p>
<p>表面解释：早睡早起，深度解释请看文章。</p>
<p><strong>猫头鹰</strong></p>
<p>表面解释：晚睡晚起，深度解释请看文章。</p>
]]></content>
      <categories>
        <category>闲扯</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>抉择</title>
    <url>/2019/09/30/%E6%8A%89%E6%8B%A9/</url>
    <content><![CDATA[<p>最近看了《抉择》，虽说本身是一本企业管理的书，但是对人自身也是特别有指导意义的…</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>拖延</title>
    <url>/2020/09/01/%E6%8B%96%E5%BB%B6/</url>
    <content><![CDATA[<img src="/2020/09/01/%E6%8B%96%E5%BB%B6/a.jpg" class="" title="Photo by Jason Leung on Unsplash">

<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>you know年纪大了就想着研究研究自个 儿。</p>
<p>我这人其实工作上是真的从不拖延，正儿八经的，不过生活中就相反了。我就很想找找其中的原因。</p>
<h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>遂选了几本书，看我还能不能抢救一下：</p>
<ol>
<li>《图解心理学》</li>
<li>《心理学通识》</li>
<li>《少有人走的路》</li>
<li>《拖延心理学》</li>
<li>《理解人性》</li>
</ol>
<p>编号就是读的顺序，此篇先占位，待我都读完之后来写写收获。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>提高效率</title>
    <url>/2019/08/21/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>最近个人成长KPI抓的严，为了能心安理得的继续IT事业，不管强迫自己多花时间在个人成长上。</p>
<p>刚好瞌睡遇到枕头，这两天经少数派，关注了B站的<em><strong>锦堂生活空间</strong></em>。</p>
<p>看到他的一个视频**”我保持高效率奋斗的5大因素”**，个人感觉是对我有用的。</p>
<h3 id="一个远大的理想"><a href="#一个远大的理想" class="headerlink" title="一个远大的理想"></a>一个远大的理想</h3><ol>
<li>理想要可衡量</li>
<li>要足够大</li>
<li>分段立目标，逐个完成</li>
</ol>
<h3 id="将所在领域内的偶像贴在工作墙上"><a href="#将所在领域内的偶像贴在工作墙上" class="headerlink" title="将所在领域内的偶像贴在工作墙上"></a>将所在领域内的偶像贴在工作墙上</h3><ol>
<li>时刻提醒自己，不放松。</li>
</ol>
<h3 id="绝对不要进入自己不感兴趣的领域"><a href="#绝对不要进入自己不感兴趣的领域" class="headerlink" title="绝对不要进入自己不感兴趣的领域"></a>绝对不要进入自己不感兴趣的领域</h3><ol>
<li>没有所谓的能力不足，只有你对这件事感不感兴趣</li>
<li>一定要确保你你再做着你自己喜欢的事情</li>
</ol>
<h3 id="学习新知识的时候，必须要不断的停下来思考"><a href="#学习新知识的时候，必须要不断的停下来思考" class="headerlink" title="学习新知识的时候，必须要不断的停下来思考"></a>学习新知识的时候，必须要不断的停下来思考</h3><ol>
<li>思考自己的缺点，怎么应用到我得生活和工作中。</li>
<li>费曼学习法，怎么让自己和别人明白，复杂的知识简单化</li>
<li>将简单化的知识点以口语化写进笔记本</li>
</ol>
<h3 id="准备一个笔记本记录激励你的话或者成功人士的小视频"><a href="#准备一个笔记本记录激励你的话或者成功人士的小视频" class="headerlink" title="准备一个笔记本记录激励你的话或者成功人士的小视频"></a>准备一个笔记本记录激励你的话或者成功人士的小视频</h3><p>在开始奋斗之前花几分钟时间看激励自己的东西，让自己亢奋起来</p>
<img src="/2019/08/21/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/1.jpg" class="" title="http:&#x2F;&#x2F;tech.sina.com.cn&#x2F;csj&#x2F;2018-10-22&#x2F;doc-ifxeuwws6781626.shtml">

<h2 id="源引："><a href="#源引：" class="headerlink" title="源引："></a>源引：</h2><blockquote><footer><strong>我保持高效率奋斗的5大因素</strong><cite><a href="https://www.bilibili.com/video/av51329012">www.bilibili.com/video/av51329012</a></cite></footer></blockquote>




]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2019/04/17/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>简单记录一下我平时使用搜索套路。</p>
<img src="/2019/04/17/%E6%90%9C%E7%B4%A2/001.png" class="">

]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title>效能提升</title>
    <url>/2022/07/01/%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近了解到公司在抓研发效能这块，所以也学习学习，了解下相关内容。</p>
<p>研发效能提升</p>
<p>msup分享：</p>
<p>指标定义</p>
<p>指标是养出来的，不是一蹴而就。</p>
<p>分析模型</p>
<p>通常单个指标是不能说明问题的，需要多个指标按照一个分析模型来。</p>
<p>基于场景</p>
<p>基于场景下的实践反向验证指标的有效性</p>
<p> GSM</p>
<p> 考察尽量以团队来考核，不要以个人。<br> 不要有奖励，否则最终肯定会变形。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU1MjAzNjE4NA==&amp;mid=2247484603&amp;idx=1&amp;sn=cc6e8341e604bab54235f9691dc23046&amp;chksm=fb89768cccfeff9a3d4ac30fcdda18137869e486da4dfb9e9dddf3224e5a5f21d6bf301d746b&amp;mpshare=1&amp;scene=1&amp;srcid=0926DpH4CCppnllj3x6aUd34&amp;sharer_sharetime=1664164535153&amp;sharer_shareid=90feac59023ea9aa307820b1dbe10e7f&amp;version=4.0.16.99169&amp;platform=mac#rd">https://mp.weixin.qq.com/s?__biz=MzU1MjAzNjE4NA==&amp;mid=2247484603&amp;idx=1&amp;sn=cc6e8341e604bab54235f9691dc23046&amp;chksm=fb89768cccfeff9a3d4ac30fcdda18137869e486da4dfb9e9dddf3224e5a5f21d6bf301d746b&amp;mpshare=1&amp;scene=1&amp;srcid=0926DpH4CCppnllj3x6aUd34&amp;sharer_sharetime=1664164535153&amp;sharer_shareid=90feac59023ea9aa307820b1dbe10e7f&amp;version=4.0.16.99169&amp;platform=mac#rd</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>提效</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷</title>
    <url>/2020/12/17/%E6%95%8F%E6%8D%B7%E5%92%8B%E6%95%B4/</url>
    <content><![CDATA[<img src="/2020/12/17/%E6%95%8F%E6%8D%B7%E5%92%8B%E6%95%B4/scrum.jpg" class="" title="Photo by İrfan Simsar on Unsplash">

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前前后后经历了几个公司敏捷的做法，有些些感悟，在此表一表。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>首先咱们说一下为啥需要敏捷，因为敏捷的业务目标是<strong>更早的交付价值以及更灵活的应对变化</strong>。我认为这是之所以那么多公司或者团队想要实践敏捷的最大原因之一。</p>
<p>让我知道<strong>敏捷</strong>的公司，那是在14年我进了一家主打3D数字建模的公司，我的直接领导是公司敏捷的推崇者，当时两个研发团队也是按照敏捷走的，但是敏捷到底是个啥？当时老大给了我一本书让我自己去悟。书名好像是《Scrum敏捷软件开发》。之后大体有了个了解，至少对<code>站会、用户故事、backlog、sprint、SM、PO</code>等词有个概念。</p>
<p>那时候觉得挺新鲜因为在此之前我只知道瀑布模式。在这家公司时我对敏捷印象是最深的，因为我经历了新旧之间的碰撞，不仅是思想上的还有实操上的。因为公司还有个管评审的年长型主管A大，他刚好更偏向于瀑布模式。</p>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h4><p><strong>chapter 1 ：</strong></p>
<p>先交代一些往事，当时的我，迷茫的一逼，感觉写代码不适合我，我想要转产品，当然我说的产品不是UE性质那种产品哈，我说的是正儿八经的那种产品经理，“那种”指的是：从0到1打造适合用户且用户要买单的那种产品的产品经理。</p>
<p>刚好我的leader就有个类似经历的人，他曾经因为在上海的一个研究所交付的产品令客户不满意，他去呆了3个月，硬生生从0到1重新根据需求设计产品，最终成功交付，当时研究所的人对他的评价是，他比我更懂我得工作。不然为啥他被现在的公司拉去当了副总？你品一品他当时只是一个研发岗。</p>
<p>我虽然面试的是开发岗，刚好当时负责面试的人有事出去了，他刚好遇到了就说先跟他聊一聊，当我告诉他有意向走产品的时候，由于聊的很好，他果断把我留下来当他的助手了。所以我入职是没有经过技术面试的…。</p>
<p>入职的title是<em>产品助理</em>，前期主要干的事就是看书，用Latex写公司宣传文档和摸鱼，后期就让我跟项目，主要是做项目需求。</p>
<p>由于我们的客户多是各种工厂所以通常位置都比较偏僻，想去泡个脚都要摩托转公交再转出租的节奏。</p>
<p>犹记得当时把我一个人丢到工厂的时候，那种无助…工厂里的人通常都比较务实比较直接。被怼的体无完肤到和颜悦色，中间也就是几顿酒的事….故事太多以后写小说再用。</p>
<p>说这些是怎么个意思呢？其实没啥意思，就是说说一些背景，任何事物都是有联系的，你再细品。</p>
<p><strong>chapter 2：</strong></p>
<p>接上，在工厂第一次差不多进一个月，工作内容就是梳理各个环节各个干系人的需求，并整理成文档。</p>
<p>感觉终于告一段落之后，速度赶回北京。然后就是评审，这个时候问题就来了，我老大觉得现有的需求可以开始准备进入研发了，遇到需求问题再澄清就行，但是评审主管就不干了，说你这需求文档需要细化的地方还有挺多，不能进入研发，所以评审没过。会后两位大佬分别拉我谈了一次，一个觉得需求不够完整（瀑布），一个觉得需求已经够了（敏捷）。那为什么双方没有达成一致呢，在我看来当时我老大推崇的敏捷没有玩好，比如A提的一点，研发是敏捷了节奏都挺快，交付周期也缩短了，但是交付结果不太好，老有返工，导致一个项目迟迟不能最终验收，这就是A不赞同的根本原因，因为连客户想要什么都没有完全搞清楚。</p>
<p>对应到<strong>敏捷</strong>里的内容就是，在<strong>检视和调整</strong>两块没有足够重视。也就是下面的几个会议没有开好：</p>
<ol>
<li>Sprint 计划会议 </li>
<li>每日 Scrum 站会 </li>
<li>Sprint 评审会议 </li>
<li>Sprint 回顾会议</li>
</ol>
<p>我理解以上四个会议就是每个迭代里防止走偏的措施，但最后还是走偏了。</p>
<p><strong>chapter 3：</strong></p>
<p>现公司一进来就是敏捷，但是大多数时间也是走的不顺，有段时间还专门找了教练带着跑了几个月，效果也是一般般。</p>
<p>当时我想了想可能原因有下面几方面：</p>
<ol>
<li><p>公司是家传统意义上的软件公司，前面都是瀑布模式，虽然是新产品线但是也有很多老员工，所以不管从公司还是从人来说，这个转变是需要时间且需要强有力的刺激，<strong>很明显是时间给够了但是刺激不够</strong>。我们都知道有刺激才会有反应。</p>
</li>
<li><p>大家对敏捷的理解参差不齐，很多朋友是随波逐流，且最致命的是这类朋友基本上都认为自己是懂敏捷的，但是真的懂吗，大概率不是的或者只停留在字面上的理解（我其实也是一知半解）。</p>
<blockquote>
<p>敏捷应用其实在我看来是一系列的动作的组合，该套组合需是不断优化且需要组织严格遵守的，组合好之后，把该组合套在软件的开发周期里，然后一遍一遍的重复重复再重复。</p>
<p>另外很多人的误解是，敏捷就不用写任何文档了，在我看来不是的，必要的文档还是需要的比如设计文档。</p>
</blockquote>
</li>
</ol>
<p>前段时间公司大佬给够了刺激，比如重新梳理组织架构、丰富了工具、完善了开发&#x2F;评审流程（必要的设计文档等）、强制执行双周迭代、双周演示会等等，我的感受是团队的流转效率是有提高的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>我理解的敏捷其实是门大学问，不是只有简单的一些关键词，比如还有“以赋能和信任个人为中心的文化”这类的理念内容，持续学习中。</p>
<p>所以其实我没啥发言权，不过随便说说，也没谁管得着，反正是我自己的博客….。</p>
<p>从我的经历来看，敏捷是个好东西，但是落地也确实不容易，除了敏捷本身就代表一种变革（动作大）以外，它本身也涉及到很多关于人的因素，比如人的思维、习惯、团队文化等，但是如果因为对敏捷应用的不成功，就觉得敏捷不好用，并怀疑它的价值，不可取哈。</p>
<p>另外敏捷只是解决问题的一种方式，也不要把它捧得太高。</p>
<p><strong>任何方法或者工具都有它所适用的上下文。</strong></p>
<blockquote>
<p>我认为敏捷是解决问题的一种方式，技术越来越多成为变现的一种手段。那当然你会问谁先行呢？思维观念要变，同时也需要给搭配上不同的手段，谁先谁后并不是主要矛盾。— DXcon</p>
</blockquote>
<p><strong>敏捷的价值观</strong></p>
<blockquote>
<p>摘自&lt;说透敏捷&gt;</p>
</blockquote>
<ol>
<li>个体和交互胜过过程和工具。</li>
<li>可以工作的软件胜过面面俱到的文档。</li>
<li>客户合作胜过合同谈判。</li>
<li>响应变化胜过遵循计划。</li>
<li>虽然右项有价值，但我们更重视<strong>左项</strong>。</li>
</ol>
<p>一个公司或者团队要应用敏捷，不代表要全套接收，有可能只需要敏捷里的某块就可以，不信谣不传谣。</p>
<p>真正的敏捷应该是Be Agile而不是Do Agile。在我们强调&#x2F;争执xx方法论，xx实践的时候，我们往往在做敏捷，而不是真正的敏捷了。</p>
<h4 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h4><p>团队，除了学会传统”规划、组织、领导、控制 “的管理方式之外，还需要”激励、授权、支持、交流 “，这实际上意味着，领导者(特别是CEO)把资源分配采取分布式，而不是集中制(集中在自己手里)。这对团队&#x2F;组织&#x2F;公司，在应对复杂、即时、阶层式问题时的灵活度、适应度增加很多。</p>
<blockquote><footer><strong>coolshell</strong><cite><a href="https://coolshell.cn/articles/4951.html">软件公司的两种管理方式</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>敏捷</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷自动化测试</title>
    <url>/2018/09/29/%E6%95%8F%E6%8D%B7%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>公司组织了一次敏捷得自动化测试，先做个课堂笔记，不久后公司会推自动化测试，到时候根据实践，再具体聊聊。</p>
<p>塔克曼模型</p>
<p>需求很多时候其实是在抢占资源。</p>
<p>持续集成平台搭建</p>
<ul>
<li>Jenkins 服务器搭建</li>
<li>Gitlab 平台搭建并且与 Jenkins 整合</li>
<li>用 Git 进行版本控制的策略</li>
<li>自动化单元测试</li>
</ul>
<p>团队压力大-解决方法</p>
<ul>
<li>需求整流</li>
<li>团队从止血到造血</li>
<li>形成业务版本节奏、和团队交付节奏</li>
</ul>
<p>代码质量保证手段的建立</p>
<ul>
<li>Sonar Qube 平台搭建与培训 </li>
<li>代码评审制度建立</li>
</ul>
<p>实例化需求</p>
<ul>
<li>用户故事和验收条件的编写规范 </li>
<li>采用实例化需求的方式来梳理需求</li>
<li>采用 Cucumber 编写自动化验收测试</li>
<li>采用 Selenium 驱动用户界面测试</li>
</ul>
<p>实际迭代工作中的团队协作</p>
<ul>
<li>度量</li>
<li>测试用例可追溯性</li>
<li>缺陷周期时间</li>
<li>缺陷泄漏率</li>
<li>测试覆盖率</li>
<li>绩效考评</li>
</ul>
<p>单元测试</p>
<p>Robot Framework</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>现公司推的工具是Katalon，写Xpath可以用java等语言写。</p>
<p>前端自动化测试：</p>
<ol>
<li>用ID这类唯一性的属性标识元素，使测试用例能更少的维护，只要id在元素结构不发生大的变化都能继续用。</li>
<li>业务代码加ID，通用组件加ID，根据唯一标识写Xpath</li>
</ol>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>敏捷</category>
      </categories>
  </entry>
  <entry>
    <title>数字化</title>
    <url>/2021/02/05/%E6%95%B0%E5%AD%97%E5%8C%96/</url>
    <content><![CDATA[<img src="/2021/02/05/%E6%95%B0%E5%AD%97%E5%8C%96/1.jpg" class="" title="Photo by NASA on Unsplash">

<p>看到<a href="https://mp.weixin.qq.com/s/9g6bg6nMbj7LhyvOuKCrmg">DXCon</a>一篇文章，做个记录</p>
<h4 id="怎么理解数字化转型？"><a href="#怎么理解数字化转型？" class="headerlink" title="怎么理解数字化转型？"></a>怎么理解数字化转型？</h4><p>优化是通过把你的服务线上化，减少摩擦，提供更好的服务体验。</p>
<h4 id="那数字化转型真正转的应该是什么？"><a href="#那数字化转型真正转的应该是什么？" class="headerlink" title="那数字化转型真正转的应该是什么？"></a>那数字化转型真正转的应该是什么？</h4><p>数字化转型，最终转的是客户价值的创造。</p>
<p>通过数字化智能化的方式，使原来没有办法传递的价值，现在可以传递出去。最终的目的是创造一种模式，不管是商业模式，还是运营模式，使得能够颠覆原来没办法做到的事情，或者是原来很难做到的事情。通过数字化来达成原来不可能达成的价值创造的一种方式，最终的核心应该是要创造价值。</p>
<p><strong>通过数字化来达成原来不可能达成的价值创造的一种方式，就是数字化最终的目的应该是要创造价值。</strong></p>
<h5 id="最后来句废话"><a href="#最后来句废话" class="headerlink" title="最后来句废话"></a>最后来句废话</h5><p>我从参加工作开始几乎都是在ToB行业，刚好有两家公司就是干数字化转型的，我一开始的理解不过是从纸质媒介转到网络媒介，从线下到线上，实操经验告诉我，最终看的还是为用户创造了哪些价值，实用为主的客户你跟他扯概念鸟用没有。</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>数字化</tag>
      </tags>
  </entry>
  <entry>
    <title>斜杠</title>
    <url>/2019/11/03/%E6%96%9C%E6%9D%A0/</url>
    <content><![CDATA[<p>最近看《圆桌派》聊的一个话题<strong>斜杠：理想还是欲望？一专还是多能？</strong>。想在这儿随便说说。</p>
<p>这个词其实前两年说的比较多，当时另一个说法是一个人的<strong>标签</strong>很多。为什么出现的频率高，也流行，更多的原因是在于那其实是大大多数的梦想。</p>
<p>里面窦先生说了一下，欲望和理想的区别：一定要结果的就是欲望，热爱过程的是理想。所以对于追求<strong>斜杠</strong>，你是出于欲望还是理想？从我个人来说，我对斜杠的追求我归为欲望，因为很显然我是需要结果的，不管是物质上的还是精神上的我都是有所求的。</p>
<p>我一直认为，斜杠青年：其实是一个很奢侈的一个愿望。</p>
<img src="/2019/11/03/%E6%96%9C%E6%9D%A0/dream_big.jpg" class="" title="Photo by Randy Tarampi on Unsplash">



<p>我比较俗啊，我对斜杠的定义是，每个斜杠都应该是一份事业且他们是相互独立（跨界）的，就像《圆桌派》里说的一样你虽然干了很多份事业但是其实他们都是有关联性或者有递进性的这其实不算是斜杠，因为你始终还是在那个圈里。</p>
<p>既然是事业那就肯定会有付出和回报当然咱们谈的不仅限于钱，最起码你要花时间和精力去做，且会收到反馈。人的时间和精力都是有限的，你把有限的时间和精力花在了多个不同的行业，且都得到反馈，这才算是斜杠。</p>
<p>比如你上午卖炒河粉，下午coding，晚上酒吧驻唱。这我觉得可以说是：餐饮&#x2F;互联网&#x2F;演艺，三个斜杠。</p>
<p>所以为什么说斜杠是很奢侈的，首先你的精力要跟上，其次你的时间能自己做主，然后你还得技术过硬。当然跟现实生活中一样奢侈品再贵，也总有些人是能消费的。所以不是说斜杠就没有，只是那是很小的一部分。</p>
<p>大家别把斜杠玩坏了，也别一味的飘飘然的追求斜杠，很多时候你自己要先静一静想一想，别听风就是雨的，不仅飞不高还摔得疼。</p>
<p>就算你有这个欲望，不得现有实力和条件吗，先让自己有这些条件然后再想吧。</p>
]]></content>
      <categories>
        <category>圆桌派</category>
      </categories>
      <tags>
        <tag>欲望</tag>
      </tags>
  </entry>
  <entry>
    <title>权限</title>
    <url>/2018/07/12/%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>最近项目的0.2阶段需要加上权限功能，产品方给了一个需求文档，让我们参与共创。所以借此梳理梳理权限的东西。其实万变不离其宗，我觉得基本上权限设计都是基于RBAC模型来设计的。</p>
<p>我认为的权限应该是分为两种：</p>
<ul>
<li>应用权限。也就是我们通常说的系统权限，比如用户、角色、权限等等。</li>
<li>认证。通常说的是验证某个用户是否具有访问系统的权限，实现方案比如OAuth、OAuth2、Open API等等。</li>
</ul>
<p>权限复杂度的设计依业务场景而定，我是基本上做的都是toB，所以权限这块会相对复杂些。不同的toB系统权限设计肯定也不同。不过我觉得大体可以分为三种toB权限设计场景。私有云、私有云（对客户定制开发并部署在客户现场 的我也归为私有云）、混合云。当然我比较熟的是公有云和私有云的，混合云的我还没涉及到过，不过我觉得是混合云应该和公有云的权限设计比较接近。</p>
<p>下图我参与过的某toB平台，我理解的权限设计。</p>
<img src="/2018/07/12/%E6%9D%83%E9%99%90/01.png" class="" title="来源于我">

<p>租户那块为什么单独标注呢，租户是一个比较大的概念，通常表名一个公司或者个人。</p>
<img src="/2018/07/12/%E6%9D%83%E9%99%90/02.png" class="" title="来源于我">


<p>下面是我另外参与的私有云项目的权限设计。</p>
<img src="/2018/07/12/%E6%9D%83%E9%99%90/03.png" class="" title="来源于我">

<p>这个权限你会发现有一个<strong>域</strong>的概念，是因为我们的客户是集团性质的客户，会有总公司、分公司、事业部等概念，因为每个分公司或者事业部大体上都是独立运营的，但是他们又是属于一个集团，所以我们出现了域的概念。一个域可以理解为一个公司或者事业部但是我们不强关联，域是扁平的增加了灵活性。还有一点需要注意在这儿部门（组织）是不纳入权限的，我们使用角色来控制，为什么还需要部门，是为了让角色更丰满，部门可为角色打上标签，客户也好理解。同时也减少了复杂性。</p>
<h2 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h2><p><strong>资源</strong></p>
<p>因为要打造的是一个APM系统，所以里面会涉及到CMDB，资源这个名称就是CMDB来的当然一般我们叫CI（具体一个配置项，也叫CI实例），要详细讲就要讲到CMDB了，要讲CMDB那就复杂了，不是一两篇能说清楚的，后面有机会我会试着讲讲我理解的CMDB和CMDB在我们系统是怎么定义以及怎么用的。</p>
<p><strong>RBAC</strong></p>
<p>基于<strong>角色</strong>的访问控制，所以你会发现这个模型能满足大多数的权限设计。至少我没见过没有角色这个概念的权限设计。</p>
<p>google和博客说的更清楚</p>
<blockquote><footer><strong>唐乐 | 支付这点事</strong><cite><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTE1MDMxMg==&mid=2649242055&idx=1&sn=b930e768094212ff7b1739deb500424f&chksm=bea5604089d2e9564895eba2029967a1384c2cec3df6d2a34fbd8b1735a3aa6ca7dfcdf7bf99&mpshare=1&scene=23&srcid=0712Y6e8P4UOiFSrCwrNGcyC#rd">用户权限设计(RBAC)您熟悉吗?原理和思路全在本文</a></cite></footer></blockquote>

<blockquote><footer><strong>转</strong><cite><a href="https://blog.csdn.net/yangwenxue_admin/article/details/73936803">权限系统与RBAC模型概述</a></cite></footer></blockquote>

<blockquote><footer><strong>Java高级架构师</strong><cite><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjQyNTYyNA==&mid=2247483877&idx=1&sn=226bb46a563d1cc82416d8ae832ba2eb&chksm=ea4a1c92dd3d95845f1e4900c5be287a356f2d5c49f87a3d109dc811389a3def0e6a2c77029f&mpshare=1&scene=23&srcid=0712JgrTeiqegeVB2UTuAz63#rd">RBAC新解 - 基于资源的权限管理</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>骨架屏</title>
    <url>/2021/07/26/%E6%9E%B6%E5%B1%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/dvtng/react-loading-skeleton#readme">https://github.com/dvtng/react-loading-skeleton#readme</a></p>
<p><a href="https://github.com/kaola-fed/awesome-skeleton">https://github.com/kaola-fed/awesome-skeleton</a></p>
<p><a href="https://github.com/famanoder/dps">https://github.com/famanoder/dps</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>骨架屏</tag>
      </tags>
  </entry>
  <entry>
    <title>根因分析</title>
    <url>/2019/08/23/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近研发老大牵头组织了异常关于根因分析的讨论，目的在于让大家学会做根因分析，因为往往大家都是直接下结论（给答案），既容易发生矛盾也同时也没有解决根本问题。</p>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>1.当有问题出现时，往往根据现象再加上以往的经验或者直接拍出一个结论，这种情况在短期内的效果是可以的，但是从长期来看会掩盖掉很多底层的问题。结果就是问题该出还出，不仅没有提升团队的效率反而降低了团队的效率。</p>
<p>2.当问题出现时就代表甩锅以及互怼的开始，没有经过根因分析，上来先下个结论，开始界定责任，然后开始扯皮。</p>
<h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p><em>（什么时间</em>*-<strong>什么地点</strong>-<strong>什么产品</strong>-<strong>什么人物</strong>-<strong>发生什么故障现象</strong>-*<em>造成什么影响）</em></p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间：2019-09-02</span><br><span class="line">地点：XX现场</span><br><span class="line">产品：XX产品/XX版本</span><br><span class="line">发现人：XX现场交付人员</span><br><span class="line">故障现象描述：客服在正常登陆系统提单的时候报错，并且提交不了工单</span><br><span class="line">【帮助】如有多个故障现象，应分别描述；</span><br><span class="line">结果影响：系统XX时间不可用，导致客户非常不满，造成XXX损失</span><br></pre></td></tr></table></figure>

<h5 id="过程还原"><a href="#过程还原" class="headerlink" title="过程还原"></a>过程还原</h5><p><em>直接叙述工作过程，有问题的环节或阶段，什么人，做了什么事，当时是怎么考虑的，在这个动作后结果是什么。</em></p>
<h5 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h5><p><em>描述最终定位到的直接原因是什么。举个例子，比如某段代码编写存在<strong>XXX</strong>错误</em></p>
<h5 id="技术根因分析"><a href="#技术根因分析" class="headerlink" title="技术根因分析"></a><strong>技术根因分析</strong></h5><p><strong>引入环节：</strong></p>
<ol>
<li>产品设计是否有问题？</li>
<li>需求分析是否有问题？</li>
<li>设计环节是否有问题？</li>
<li>代码编写是否有问题？</li>
<li>其他</li>
</ol>
<p><strong>流出环节：</strong></p>
<ol>
<li>各评审环节是否有遗漏？</li>
<li>是否进行研发自测？</li>
<li>测试场景、测试用例是否覆盖全？</li>
<li>是否进行了系统测试？</li>
<li>其他？</li>
</ol>
<p><strong>确定关键根因是什么</strong>：</p>
<p>如果有多个根因在逻辑层次上相同，则取关键的原因，根因应该是具体的、客观的、在目前组织能力下可被改进的。</p>
<h5 id="管理根因分析"><a href="#管理根因分析" class="headerlink" title="管理根因分析"></a>管理根因分析</h5><ul>
<li>流程&#x2F;制度原因：</li>
<li>组织因素：</li>
<li>执行原因：</li>
</ul>
<p>【帮助】流程&#x2F;制度方面：考虑组织管理上是否有合适的流程、指导书、管理Checklist；</p>
<p>组织因素方面：考虑人员分配、个人技能、培训、组织环境等原因；</p>
<p>执行方面：考虑计划、监控、沟通方面的原因。</p>
<h5 id="纠正、预防措施"><a href="#纠正、预防措施" class="headerlink" title="纠正、预防措施"></a>纠正、预防措施</h5><table>
<thead>
<tr>
<th><strong>根本原因</strong></th>
<th><strong>措施类型</strong></th>
<th><strong>措施内容</strong></th>
<th><strong>责任人</strong></th>
<th><strong>预定完成日期</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>技术根因：</em>  <em>例如，XX特性，在大规格、灵活配置等方面需求设计不充分</em></td>
<td>纠正措施</td>
<td><em>例如：对XX特性组织进行重新设计，刷新XX方案</em></td>
<td></td>
<td><em>2018&#x2F;11&#x2F;1</em></td>
</tr>
<tr>
<td>预防措施</td>
<td><em>例如：更新××技术规范、工具、checklist等等</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>管理根因：</em>组织管理、流程方面的原因，比如xx，没有按照流程，但是最终还是交付了。</td>
<td>纠正措施</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>预防措施</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上诉的内容，关键还是在于给一个框架，让问题发生人，根据框架的引导，能比较深刻的挖掘出问题的根因，按此框架填写后，往往会伴随着评审，最终判断分析的彻底性以及合理性。</p>
<p>当然这只是一种方式，一段时间实践下来，其实是有助于减少问题发生率以及增加个人问题的处理成本从而倒逼相关人员注意到质量的重要性。</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title>梦想金山-产品王道三大法宝</title>
    <url>/2018/09/21/%E6%A2%A6%E6%83%B3%E9%87%91%E5%B1%B1-%E4%BA%A7%E5%93%81%E7%8E%8B%E9%81%93%E4%B8%89%E5%A4%A7%E6%B3%95%E5%AE%9D/</url>
    <content><![CDATA[<p>1.以用户为中心<br>2.玩者之心<br>3.”瘦身运动”</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>梦想金山</tag>
      </tags>
  </entry>
  <entry>
    <title>梦想金山-人物</title>
    <url>/2018/09/10/%E6%A2%A6%E6%83%B3%E9%87%91%E5%B1%B1-%E4%BA%BA%E7%89%A9/</url>
    <content><![CDATA[<p>求伯君自己成功的经验三点：</p>
<ol>
<li>天赋</li>
<li>个人的不懈努力</li>
<li>机遇，遇到了一个时代和一些人</li>
</ol>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>运营</tag>
      </tags>
  </entry>
  <entry>
    <title>梦想金山-优秀的程序员</title>
    <url>/2018/09/20/%E6%A2%A6%E6%83%B3%E9%87%91%E5%B1%B1-%E4%BC%98%E7%A7%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
    <content><![CDATA[<p>优秀程序员四大修为</p>
<p>1.坚韧不拔<br>2.知识全面<br>3.完美主义<br>4.团结协作</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>梦想金山</tag>
      </tags>
  </entry>
  <entry>
    <title>梦想金山-运营</title>
    <url>/2018/09/11/%E6%A2%A6%E6%83%B3%E9%87%91%E5%B1%B1-%E8%BF%90%E8%90%A5/</url>
    <content><![CDATA[<p>google的十大真理</p>
<p>金山-梦想与野心。</p>
<p>金山区别于其它中关村企业最核心的地方，金山是一家有野心的公司。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>沟通是一种博弈</title>
    <url>/2022/03/20/%E6%B2%9F%E9%80%9A%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<p>汤质老师的课程，沟通是一种博弈</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器渲染</title>
    <url>/2019/07/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>最近再看浏览器方面的内容，对于渲染这块收集到的知识做个小结，我是大自然的搬运工。</p>
<p><strong>By</strong> <a href="https://developers.google.com/web/resources/contributors/ilyagrigorik?hl=zh-cn">Ilya Grigorik</a></p>
<p>CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。</p>
<p>在前面介绍构建对象模型的章节中，我们根据 HTML 和 CSS 输入构建了 DOM 树和 CSSOM 树。 不过，它们都是独立的对象，分别网罗文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。我们该如何将两者合并，让浏览器在屏幕上渲染像素呢？</p>
<p>TL;DR</p>
<ul>
<li>DOM 树与 CSSOM 树合并后形成渲染树。</li>
<li>渲染树只包含渲染网页所需的节点。</li>
<li>布局计算每个对象的精确位置和大小。</li>
<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。</li>
</ul>
<p>第一步是让浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=zh-cn" alt="将 DOM 与 CSSOM 合并以形成渲染树"></p>
<p>为构建渲染树，浏览器大体上完成了下列工作：</p>
<ol>
<li>从 DOM 树的根节点开始遍历每个可见节点。<ul>
<li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li>
<li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点—不会出现在渲染树中，—因为有一个显式规则在该节点上设置了“display: none”属性。</li>
</ul>
</li>
<li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。</li>
<li>发射可见节点，连同其内容和计算的样式。</li>
</ol>
<p><strong>Note:</strong> 简单提一句，请注意 <code>visibility: hidden</code> 与 <code>display: none</code> 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (<code>display: none</code>) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。</p>
<p>最终输出的渲染同时包含了屏幕上的所有可见内容及其样式信息。<strong>有了渲染树，我们就可以进入“布局”阶段。</strong></p>
<p>到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备<a href="https://developers.google.com/web/fundamentals/design-and-ux/responsive?hl=zh-cn#set-the-viewport">视口</a>内的确切位置和大小—这就是“布局”阶段，也称为“自动重排”。</p>
<p>为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。让我们考虑下面这样一个简单的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/nested.html">试一下</a></p>
<p>以上网页的正文包含两个嵌套 div：第一个（父）div 将节点的显示尺寸设置为视口宽度的 50%，—父 div 包含的第二个 div—将其宽度设置为其父项的 50%；即视口宽度的 25%。</p>
<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-viewport.png?hl=zh-cn" alt="计算布局信息"></p>
<p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。</p>
<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。</p>
<p>上述步骤都需要浏览器完成大量工作，所以相当耗时。不过，Chrome DevTools 可以帮助我们对上述所有三个阶段进行深入的了解。让我们看一下最初“hello world”示例的布局阶段：</p>
<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-timeline.png?hl=zh-cn" alt="在 DevTools 中评估布局"></p>
<ul>
<li>“Layout”事件在时间线中捕获渲染树构建以及位置和尺寸计算。</li>
<li>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</li>
</ul>
<p>执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。</p>
<p>最后将在视口中看到下面的网页：</p>
<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/device-dom-small.png?hl=zh-cn" alt="完成渲染的 Hello World 网页"></p>
<p>下面简要概述了浏览器完成的步骤：</p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<p>我们的演示网页看起来可能很简单，实际上却需要完成相当多的工作。如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。</p>
<p>*<strong>优化关键渲染路径*就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。</strong> 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。</p>
<h5 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h5><blockquote><footer><strong>渲染树构建、布局及绘制</strong><cite><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn">developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a></cite></footer></blockquote>

<blockquote><footer><strong>rendering-repaint-reflowrelayout-restyle</strong><cite><a href="https://www.phpied.com/rendering-repaint-reflowrelayout-restyle/">www.phpied.com/rendering-repaint-reflowrelayout-restyle</a></cite></footer></blockquote>



]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>理解一个新事物的方法</title>
    <url>/2019/11/20/%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>最近看了李笑来先生写的《区块链小白书》对其中的理解一个新事物正确的姿势在此做一个备忘。</p>
<h3 id="1-不要滥用类比"><a href="#1-不要滥用类比" class="headerlink" title="1. 不要滥用类比"></a>1. 不要滥用类比</h3><p>你将要尝试着学习并理解的，是一个前所未有的重大创新，其中有很多你一下子难以理解透彻的概念，很少有人能一下子全都弄明白…… </p>
<p>在这样的时候，人们会不由自主地抄近路走捷径 —— 滥用类比：</p>
<blockquote>
<p>“哦！ 我明白了，这就好像是……” </p>
</blockquote>
<p>比如，你经常会看到人们挣扎着理解了半天，突然冒出一句：“哦，我懂了，比特币就是电子黄金！” <strong>类比</strong>是约等号（≈），而“<strong>这就是</strong>”是等号（&#x3D;），约等号和等号之间的差别有时甚至超过十万八千里。 比特币与电子黄金之间的关系甚至干脆就谈不上是约等于…… 全然不是一个东西。</p>
<p>在理解全新事物的时候，滥用类比的危害非常大，因为你压根就找不到什么过往已经存在的东西真的和这个创新竟然一模一样 —— 否则，它也不可能被称为创新了，是不是？</p>
<p>这种不恰当的类比被滥用多次之后，就再也没办法形成正确的理解了 —— 因为理解一个创新需要理解多个前所未有的概念，每个都做了不恰当的类比之后，多次非常不恰当的<strong>约等于</strong>拼接起来之后，无论如何都没办法达到一个与正确理解相近的效果。</p>
<p>请务必注意，每次你的脑子里不由自主地冒出 “这就好像……” 这个念头的时候，你都要把它强压回去。</p>
<h3 id="2-重复重复再重复"><a href="#2-重复重复再重复" class="headerlink" title="2. 重复重复再重复"></a>2. 重复重复再重复</h3><p>遇到暂时无法理解的概念，不要担心、不要纠结、不要停顿，你要做的事情很简单：</p>
<blockquote>
<ul>
<li>继续读下去；</li>
<li>读完之后再<strong>重复读很多次</strong>……</li>
</ul>
</blockquote>
<p>这是学习任何新知识或者在任何新领域探索的 “必杀技”。这背后有一个重要的原理：</p>
<blockquote>
<p>绝大多数难以理解的知识，是因为它内部有很多 “前置引用”。</p>
</blockquote>
<p>所谓的前置引用，就是一个在后面才能深入理解的概念竟然在此之前已经被引用了，导致的结果是学习者总是处于懵懂的状态。学校里的知识却不是这样的，学校里的知识总是线性层层递进的，理解了前面，就能理解后面…… 关于 “前置引用”。</p>
<p>“硬着头皮读完，而后重复读很多次” 这个策略，就是可以轻松突破 “前置引用” 所设置的障碍。这个技巧，事实上可以用在任何领域。</p>
<h3 id="3-借助群智的力量"><a href="#3-借助群智的力量" class="headerlink" title="3.借助群智的力量"></a>3.借助群智的力量</h3><p>快速掌握新知识，快速适应新领域，还有个重要的技巧，就是借助群智的力量。事实上，在学校里，你早就应该发现这个技巧了 —— 如果你能跟那些学霸经常聊天，经常玩耍，你就会发现总是在不经意之间，很多重点难点就那样轻而易举地被解决掉了……</p>
<p>这首先因为人是社交动物，然而更为重要的是，交流这个东西，随意的交流总是比刻意的交流更为有效 —— 因为随意的交流总是刻意解决那些连你自己都没意识到的问题…… 可偏偏，这些你自己意识不到的问题恰恰是最重要甚至最关键的问题。如果不借助这种群智的力量，很难想象还有什么办法可以解决这种隐秘的关键问题。</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
  </entry>
  <entry>
    <title>生育基金</title>
    <url>/2018/08/22/%E7%94%9F%E8%82%B2%E5%9F%BA%E9%87%91/</url>
    <content><![CDATA[<img src="/2018/08/22/%E7%94%9F%E8%82%B2%E5%9F%BA%E9%87%91/a.jpg" class="" title="来源于Street Art Magic">

<p>最近生育基金的事闹得沸沸扬扬，更有甚者，江苏的《新华日报》携手，南京大学长江产业经济研究院 刘志彪、张 晔两位砖家，发表了不但应该缴生育基金还他么说了不生就只要老了才能取。</p>
<p>我就想说，这两位究竟平时吃什么，大脑那么奔放。我觉得马光远先生评论改事件的时候有句话很到位，<strong>“老百姓不是负责交税和交配的”</strong></p>
<p>基本的问题是什么，自己心里没点数么？光让生不用养吗？养得起吗？养得好吗？能养活吗？</p>
<ol>
<li>房价？光知道贷款、卖地，搞GDP有毛用啊，老百姓得到了什么？正经住的地方都没有还生？</li>
<li>孕妇权益？孕妇敢怀孕吗？一怀孕就失业。产假够么？报销能到位么？医院收么？</li>
<li>教育？都拿来盖房子,有盖学校的地么？幼儿教育规范么，有监管么？各种补习班开着，学校干嘛的？各种作业交给家长，老师干嘛的？</li>
<li>医疗？医疗设施跟上了么，有监管么？孕妇体检能保障么？生孩子能保障吗？</li>
<li>对企业的税收有考虑放松么？政策有考虑放宽么？企业紧巴巴，员工能好过么？</li>
</ol>
<p>…….</p>
<p>一大堆根本上的问题不出方案，这种拍马屁不要脸的舔着上。</p>
]]></content>
      <categories>
        <category>闲扯</category>
      </categories>
      <tags>
        <tag>生育基金</tag>
      </tags>
  </entry>
  <entry>
    <title>精益产品开发</title>
    <url>/2022/07/25/%E7%B2%BE%E7%9B%8A%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>最近一段时间在断断续续看老板推荐的一本书《精益产品开发》</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一段时间在断断续续看老板推荐的一本书《精益产品开发》。</p>
<p>我这人不太爱看书，是因为看书要犯困，我也不知道为啥，我内心是想看书的，但是一看上就打瞌睡，太难受了，所以导致我看书的节奏是只能概看，偶尔能专注（比如遇到难理解的、有兴趣的）。</p>
<p>在这儿记个流水账啦。纯属个人观点，不喜就算了。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p> <strong>XP方法</strong></p>
<p>即极限编程，一开始以为XP是啥没听过的新东西，一查原来就是早有耳闻的极限编程。</p>
<p>这里想说一说，XP里有个点，正是我目前比较推崇且是这么做的-<strong>简单设计</strong></p>
<blockquote>
<p>极限编程鼓励从最简单的解决方式入手再通过不断重构达到更好的结果。也就是不过度设计不追求完美不刻意追求可扩展（需要申明一下当你个人都不清楚或者不确定未来的场景的情况下），以最短的时间和最简单的方式实现。</p>
</blockquote>
<p>这儿我不跟任何人抬杠，我目前就是认为“简单设计”是让我体验最好的编程方式。</p>
<p>我从中能获益两点，这两点带给我的正反馈是可以让我放弃追求完美和一定要可扩展的目标的。</p>
<ul>
<li><p>时间，通常会加快我对产出的交付，特别是当我扮演的是生产者或者叫被依赖方时，会让使用方的用户体验比较好，比如写后端的时候前端开发者会少一些抱怨和矛盾，比如写前端的时候，产品、UE会比较满意。总体来说，不仅仅只是少花了一些时间，在各方的满意度方面都会有所提升，从而最终个人幸福感得到提升。多说一句，团队为啥搞敏捷，说的直白点，很大的一个因素不就是各位消费方都想尽快看到产出吗？而不是多方动不动就墨迹工期的问题。</p>
</li>
<li><p>可靠性，因为是简单设计，所以满足当前场景的出错概念低，且易于维护。</p>
</li>
</ul>
<p><strong>聚焦价值流动效率，而不是资源利用效率。</strong><br>这一点是我一直比较坚持的观点（虽然没啥人听我的），只是不知道有这么个专业的词语“价值流动效率”，现在公司几乎我接触过的team，不管是办啥事一上来都是先聊资源问题，往往就把事情聊死了或者需要老大出面了。</p>
<p>其实我觉得，不管啥事先要搞清楚，这个事的背景，是为了解决什么问题，最终对于产品的价值的是什么。这就是我认为的价值流动效率，就是咱们得聚焦于交付的价值，而不是资源问题。</p>
<p><strong>控制在制品的数量</strong><br>其中有一节讲看板方法的实践，里面说到一个实践：控制在制品的数量。<br>个人认为，首先产品端要克制，每个迭代不要以故事数来定，而是基于故事闭环以及研发工作量，聚焦最终交付的价值</p>
<h3 id="看板"><a href="#看板" class="headerlink" title="看板"></a>看板</h3><img src="/2022/07/25/%E7%B2%BE%E7%9B%8A%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/b.png" class="" title="精益产品开发">

<h4 id="可视化价值流动"><a href="#可视化价值流动" class="headerlink" title="可视化价值流动"></a>可视化价值流动</h4><h5 id="看板系统设计的原则"><a href="#看板系统设计的原则" class="headerlink" title="看板系统设计的原则"></a>看板系统设计的原则</h5><ul>
<li><p>体现价值</p>
</li>
<li><p>反映协作</p>
</li>
<li><p>暴露问题</p>
</li>
</ul>
<ol>
<li>分析价值流动过程<ol>
<li>识别团队交付的价值类型（业务需求、技术改进等）</li>
<li>确定看板系统的基本流动单元（通常选取工作比重较大的价值类型，比如：业务需求。）</li>
<li>分析流动单元的流动步骤（分析、开发、测试等）</li>
<li>识别流动过程中的价值分解和合并（分解为多人完成再合并）</li>
</ol>
</li>
<li>选取可视化设计元素<ol>
<li>队列。形成的条件：某个状态存在一段时间的停留。比如：开发中、测试中等<ol>
<li>列的划分可以很细，具体细化到哪个级别，依赖于: <ol>
<li>工作是否会在该阶段显著停留。比如：待验证</li>
<li>使用者是否需要特别关注这些阶段。比如：自测阶段</li>
</ol>
</li>
</ol>
</li>
<li>泳道。表达流动单元的层级关系，起分割作用，常用的划分依据:<ol>
<li>处理规则的不同，如:业务需求和现场问题。</li>
<li>需要给予不同的关注，如需求的受益方不一样。</li>
</ol>
</li>
<li>区域。表示特定信息。</li>
<li>卡片及标识</li>
</ol>
</li>
<li>用看板墙建模价值流动过程</li>
</ol>
<img src="/2022/07/25/%E7%B2%BE%E7%9B%8A%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/a.png" class="" title="精益产品开发">

<h4 id="显示化流程规则"><a href="#显示化流程规则" class="headerlink" title="显示化流程规则"></a>显示化流程规则</h4><p>核心要求：团队成员对流程规则形成一致的理解和承诺。</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>精益</tag>
      </tags>
  </entry>
  <entry>
    <title>系统之美</title>
    <url>/2019/03/04/%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>系统思考</tag>
      </tags>
  </entry>
  <entry>
    <title>组织化人才管理的四大领域</title>
    <url>/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/</url>
    <content><![CDATA[<p>今天内心膨胀的以为自己是个人才，所以随心所欲的看了门课。以下记录了我觉得对我有意义的点。</p>
<img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/mohamed.jpg" class="" title="Photo by Mohamed Nohassi on Unsplash">



<p>根据业务布局和业务的洞察来理解和分析业务的变局时什么，再次基础上呢再来看搭建什么样的阵型，组织阵型来匹配业务，为了这样的一个人才搭建，需要准备怎样对人才进行赋能，这个赋能是系统性的赋能，不是对单个个体，甚至不是对团队，而是一个系统性的赋能。最后沉淀褚一套人才管理的机制，用这样的一套人才管理机制不断推动人才。</p>
<h3 id="人才"><a href="#人才" class="headerlink" title="人才"></a>人才</h3><p><strong>业务布局&#x3D;人才体积</strong></p>
<p>人才体积：人才在多大的业务空间中去发挥作用，所以业务布局决定了人才体积</p>
<p><strong>组织阵型&#x3D;密度</strong></p>
<p>人才分布的密度和人才分布的层次</p>
<p><strong>人才赋能&#x3D;人才质量</strong></p>
<p>对组织化导向的人才赋能，我组织想对我整个的人才产生怎样的一个牵引力。核心是我是要提高我得人才适应未来业务成长需求，适应未来变局的整体的能力的拉伸。</p>
<p><strong>密度&#x3D;质量&#x2F;体积</strong></p>
<p>所以单独对人才进行培训和赋能是不够的，而是要对人才的密度进行一个拉升，即提升人才质量的同时，要让业务体积处于合适的范围内。</p>
<p>人才称重：人才在组织中的重量，发挥的作用。</p>
<p>人才称重的三种方式：</p>
<ol>
<li>通过人才赋能提升人才质量</li>
<li>通过业务布局减少人才体积（冗余）</li>
<li>通过组织机构的调整来优化人才在不同组织单元中的密度，激活组织的有效性。</li>
</ol>
<h3 id="四大模型"><a href="#四大模型" class="headerlink" title="四大模型"></a>四大模型</h3><img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/1.jpg" class="">



<p>主要说说人才管理机制模型：</p>
<p>汰换、激励、约束、牵引</p>
<p>汰换：这是一个必然的过程，当你想懈怠的时候觉得无趣的时候，问问自己你对于公司的价值是什么</p>
<p>牵引：企业文化价值的输入、企业向心力的培养等</p>
<h3 id="业务变局"><a href="#业务变局" class="headerlink" title="业务变局"></a>业务变局</h3><p><strong>业务结构与人才结构</strong></p>
<p>解释，在什么情况下先发展业务还是先发展人才。</p>
<p>依赖的手段则是进行<strong>业务摸底</strong>和<strong>人才摸底（核心团队）</strong></p>
<img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/2.jpg" class="">



<h3 id="组织变阵"><a href="#组织变阵" class="headerlink" title="组织变阵"></a>组织变阵</h3><p>说明什么地方配置更加优秀的人才，合理的调整人才结构和组织结构</p>
<img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/3.jpg" class="">



<h3 id="人才赋能"><a href="#人才赋能" class="headerlink" title="人才赋能"></a>人才赋能</h3><p>迎接未来面对变局的能力</p>
<img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/4.jpg" class="">

<img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/5.jpg" class="">





<h3 id="人才管理机制"><a href="#人才管理机制" class="headerlink" title="人才管理机制"></a>人才管理机制</h3><p>通过上述内容，沉淀出一套符合自己公司的人才管理机制</p>
<img src="/2019/10/21/%E7%BB%84%E7%BB%87%E5%8C%96%E4%BA%BA%E5%87%BA%E7%AE%A1%E7%90%86%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A2%86%E5%9F%9F/6.jpg" class="">





<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从这个课我知道了人才管理不是我之前那么单纯的理解，很容易被这个词午到，人才管理其实不仅仅说的是人才管理，还包括业务布局、组织变阵、人才赋能、机制建立等因素。</p>
<p>所以我理解一下下，人才的定义是不是：专业技能过硬，有战略眼光且能适应业务未来的变局，且有组织向心力？</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>人才管理</tag>
      </tags>
  </entry>
  <entry>
    <title>绩效考核</title>
    <url>/2022/08/19/%E7%BB%A9%E6%95%88%E8%80%83%E6%A0%B8/</url>
    <content><![CDATA[<p>最近在和领导对团队运行的方案。其中有一条是关于考核的，由于团队的动态轮换性，一开始我认为需要有个考核不然团队成员可能就没法认真对待，因为会想反正过一段时间就撤了。</p>
<p>后来看到了陈皓老师写的一篇文章<a href="https://coolshell.cn/articles/17972.html%E3%80%82">https://coolshell.cn/articles/17972.html。</a></p>
<p>深表赞同，我一直就对绩效考核深恶痛绝总觉得它在否定我的付出，好像我做的所有事都不是我想做的而是绩效要求我做的。而且老感觉自己有意无意在违背自己的真实想法做事情。</p>
<p>值得警醒的是当自己成为参与规则制定的一员的时候竟然会想到用绩效考核，真是让我无地自容。值得好好深思到底自己哪儿出了问题。</p>
<h3 id="摘抄一句话："><a href="#摘抄一句话：" class="headerlink" title="摘抄一句话："></a>摘抄一句话：</h3><blockquote>
<p>用一颗平常心来面对公司给你打的分数，因为那并不代表你的整个人生。但是，你要用一颗非常严肃的心来面对自己的个人发展和成长，因为这才是真正需要认真对待的事。</p>
</blockquote>
<p>我把考核那一条往后挪了，第一条换成了目标达成路径，额外还加上了奖励机制。</p>
<p>考核在某些场景下还是需要的，但是也仅仅是作为一个信息的输入，而不是奉为圭臬。</p>
]]></content>
  </entry>
  <entry>
    <title>编写可读代码的艺术</title>
    <url>/2019/08/09/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<p>最近有个前辈大哥看我写的代码之后，温柔的推荐了我一本小书《编写可读性代码的艺术》</p>
<h2 id="表明层次的改进"><a href="#表明层次的改进" class="headerlink" title="表明层次的改进"></a>表明层次的改进</h2><p><strong>全局观注释</strong></p>
<p>当某个类或者文件使用盖住是，比如是表示系统的入口点、数据如何在系统中流动等，具有全局意义的代码，写几句精心选择的话说明该代码的意义，不宜过大的篇幅。</p>
<p><strong>总结性的注释</strong></p>
<p>对函数做的事情进行总结，让读者在深入了解细节之前就能明白该函数的主旨。</p>
<p><strong>写注释拆分成几件事：</strong></p>
<ol>
<li>不管你心里想什么，先把它写下来。</li>
<li>读一下注释，看看有没有什么地方可以改进的。</li>
<li>不断改进。</li>
</ol>
<p><strong>注释目的：</strong></p>
<ol>
<li>记录想法<ol>
<li>为什么这样写（指导性）批注。</li>
<li>代码中的缺陷，使用像TODO或者XXX等这样的标记。</li>
</ol>
</li>
</ol>
<p><strong>站在读者的立场上思考</strong></p>
<ol>
<li>预料哪些代码是读者会有疑问的，加上注释。</li>
<li>为普通读者意料之外的行为加上注释</li>
<li>用注释来总结代码块，使读者不至于迷失在细节中</li>
</ol>
<p> <strong>怎样写出言简意赅的注释？</strong></p>
<ol>
<li><p>注释保持紧凑。不超过三行</p>
</li>
<li><p>避免使用不明确的代词，比如这、那。用有意义的名词代替，比如data、userList…</p>
</li>
<li><p>精确的描述函数的行为，比如“返回有效字符的个数”，哪些使有效字符哪些使无效字符？</p>
</li>
<li><p>某些涉及到比较复杂或者不太好用文字描述的函数，用输入输出的例子进行说明。比如“格式化字符串为下拉框格式”<br> <code>Example: listToOptionTags([&#123;id:1,name:&#39;a&#39;&#125;,...]) returns [&#123;$$typeof: Symbol(react.element), type: ƒ Option(), key: &quot;daa7f2d8-bfd9-11e9-8...&#125;,...]</code></p>
</li>
<li><p>声明代码的意图，别描述字面上的意思。比如在一段for循环上写“遍历用户对象集合”，改成“以逗号分隔拼接所有用户的firstName属性”</p>
</li>
<li><p>具名函数参数，对难以理解的参数可以按照参数名对参数赋值，比如java中可以用嵌入注释的方式：</p>
<p> <code>connect(10,false); 改成 connect(/*timeout_ms=*/30,/*use_encryption=*/false)</code></p>
</li>
</ol>
<p><strong>什么地方不需要注释？</strong></p>
<ol>
<li>能从代码本身中迅速地推断的事实。</li>
<li>用来说明烂代码（比如函数名取得不明所以…）,这时考虑的应该是吧代码改好。</li>
</ol>
<h2 id="简化循环和逻辑"><a href="#简化循环和逻辑" class="headerlink" title="简化循环和逻辑"></a>简化循环和逻辑</h2><p><strong>把控制流变得易读</strong></p>
<ol>
<li><p>条件判断，比较的左侧通常是经常变化的值，右侧通常为不变化的值，比如：</p>
<p> <code>if(length&gt;10)和if(10&lt;=length)，很明显前者更易读</code></p>
</li>
<li><p>if&#x2F;else的顺序，因为if&#x2F;else的顺序可以自由变换，很多时候应该要考虑哪一种顺序更好，可以有以下准则：</p>
<ol>
<li>通常情况下先处理正逻辑而不是负逻辑，比如if(haveUser)而不是if(!haveUser)</li>
<li>先处理简单的情况，这样的好处是可视范围内应该都能看到if&#x2F;else</li>
<li>先处理有趣的或者更危险的情况，比如负逻辑 if not file…</li>
</ol>
</li>
</ol>
<p>所以有些规则是根据具体的情况而定的，需要我们自行判断该用哪一种形式，总之我们的目的是为了避免if&#x2F;else顺序变得很别扭的情况。</p>
<ol start="3">
<li><p>三目运算符</p>
<p>该表达式的可读性是存在争议的，三目表达式是一行书写，当比较内容比较简单时，使用三目会让代码看上去很紧凑和易读，不过当比较的内容比较长或者比较复杂的时候，所有代码挤在一行，这样就变得冗长了。</p>
</li>
</ol>
<p><em>关键思想：相较于追求最小化代码行数，一个更好的度量方法是最小化人们理解它的时间。</em>所以可以遵循以下原则：默认情况下都用if&#x2F;else，三目表达式只有在最简单的情况下使用。</p>
<h2 id="用自然语言描述代码"><a href="#用自然语言描述代码" class="headerlink" title="用自然语言描述代码"></a>用自然语言描述代码</h2><p>用自然语言描述程序，然后用这个描述写出更自然的代码。</p>
<p>比较适用于稍微复杂一些的场景，通过这种方式，能根据描述用的词语和过程，进而拆分出一些子问题，从而简化代码，使代码看起来更自然。</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>缩小差距</title>
    <url>/2021/05/25/%E7%BC%A9%E5%B0%8F%E5%B7%AE%E8%B7%9D/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有些膨胀了，看到了一篇介绍《缩小差距》书的文章，准备对OKR、KPI等企业考核机制做进一步了解，说不定有一天我就平步青云了呢不小心搞个世界500强的管理者当当，到时候可以参考这用用。在这儿做个记录。</p>
<p>前面还是开玩笑的，主要还是身为被考核者，想更深入的了解考核背后的一些东西。虽然内容看上去是从和消费者（顾客）角度来谈绩效，不过我认为其实可以套在公司内部技术团队里，比如上下级对应消费者与服务者的视角？或者反过来？</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>组织内的各级管理者经常会发现问题，并直接跳到解决方案里去。很多时候，这些方案并不能解决任何问题,这是因为管理者没有找到问题的根本原因。《<a href="https://book.douban.com/subject/1046260//">缩小差距</a>》这本书展现了一个近乎完美的模式，提供一个 无懈可击的思路。你会发现，探究深藏在”现实状况”和”应有水平” 之间差距的原因，是打开最佳解决方案的钥匙。</p>
<blockquote>
<p>其实这段内容不太符合我们公司，不是拍马屁，我们公司的管理层最不喜欢直接跳到解决方案里去，平常传递给我们的信息，先找根因，我之前的<a href="http://gamehu.run/2019/08/23/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/">文章</a>有写。</p>
</blockquote>
<p>书中有个高频词语<strong>GAPS</strong>。</p>
<h4 id="GAPS"><a href="#GAPS" class="headerlink" title="GAPS"></a>GAPS</h4><p>GAPS不仅仅是一种模式和策略，它更代表一种全新的企业哲学。把它融入你的管理，你会发现一切变得水到渠成。</p>
<p>决定一个组织成败与否的一个至关重要因素就是人员的绩效。 这里所说的人员包括：工作者、决策者以及与顾客相互接触的人。如果他们能够高质量地完成工作，做出正确的决策，很好地对待顾客，组织就有机会生存,并且有可能兴 旺发达。</p>
<p>有许多因素包括组织的外部和内部因素一一影响人员的绩效。这些因素中，有些具有可控性，有些则是不可控的。</p>
<p>《<a href="https://book.douban.com/subject/1046260//">缩小差距</a>》就是关于如何管理那些可控性因素的。它的主要内容是：如何找到那些对人的工作绩效具有消极影响的因素，并且消除它们。同时，《<a href="https://book.douban.com/subject/1046260//">缩小差距</a>》的内容还包括；用系统的方法揭露并纠正这些因素，以使最 终的影响变得有意义，并且可测量。</p>
<p>每个人的生命中都会有许多美妙的时刻，所有这些时刻，更多的时候，是一种完美。完美是因为，在”现实 状况”和”应有水平”之间没有差距。</p>
<p>在今天飞速变化的商业环境中，管理者在面对问题时，通常是 在没有考虑问题的真正核心的情况下“直接跳到解决方案”。本书将 通过帮助组织中任何层次的人理解”差距战略”并把它应用于工作中， 从而使他们能够避免陷人那些具有破坏性的陷阱。</p>
<h4 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h4><p><strong>商业需要&#x3D;&gt;绩效需要，绩效需要&#x3D;&gt;工作环境和能力需要</strong>。换句话说，你们公司的客户服务代表应该以怎样更多、更好、更与众不同的行动来帮助你实现商业目的。”</p>
<img src="/2021/05/25/%E7%BC%A9%E5%B0%8F%E5%B7%AE%E8%B7%9D/a.png" class="">



<h4 id="朝〃应有水平’’前进"><a href="#朝〃应有水平’’前进" class="headerlink" title="朝〃应有水平’’前进"></a>朝〃应有水平’’前进</h4><blockquote>
<p>始终是”更多、更好、更不同”    上</p>
<p>向”应有水平”看齐</p>
<p>向”应有水平”前进</p>
</blockquote>
<p>“你得确定’应有水平’是什么。’应 有水平’是你首要的焦点问题，必须为之努力。现在看来，你有两个 ‘应有水平’，</p>
<p>第一个就是我听你说的定额标准：确定标准</p>
<p>第二种是行为的’应有水平：什么是需要做得更多、更好或 更不同的，期望得行为。</p>
<h4 id="做，还是不做"><a href="#做，还是不做" class="headerlink" title="做，还是不做"></a>做，还是不做</h4><ul>
<li>问可以自由回答的问题，收集有关消费者故障的信息</li>
<li>注意聆听，并且抓住问题的实质</li>
<li>基于消费者的情绪或感觉来调整对方的反应</li>
<li>在语气上不要表现出争论性，也不要具有攻击性或辩护性</li>
<li>在交谈的过程中经常提到顾客的名字</li>
<li>看出顾客期望从公司里得到什么,明确说明公司将要采取的行 动</li>
<li>提供一个解决问题的切实可行的时间期限</li>
<li>表现出耐心并且允许顾客发泄情绪</li>
<li>引导交谈重新回到正题轨道上，以缩短整个谈话的长度</li>
<li>为任何一个客户服务代表或公司的错误道歉</li>
</ul>
<h4 id="现实就是差距"><a href="#现实就是差距" class="headerlink" title="现实就是差距"></a>现实就是差距</h4><blockquote>
<p>目前我们在做的每一件事就 相当于”现实状况” “现实状况”就是差距所在！ 分析”现实状况”！</p>
</blockquote>
<p>你们不该直接跳到解决方案。相反，你要做的是，比较”现实状况’中的工作 绩效和。应有水平’中的工作绩效，以确定差距所在。”</p>
<h4 id="造成差距的原因"><a href="#造成差距的原因" class="headerlink" title="造成差距的原因"></a>造成差距的原因</h4><img src="/2021/05/25/%E7%BC%A9%E5%B0%8F%E5%B7%AE%E8%B7%9D/b.png" class="">

<h4 id="缺少的部分"><a href="#缺少的部分" class="headerlink" title="缺少的部分"></a>缺少的部分</h4><blockquote>
<p>“这件事用简单的四个字就可以概括：弄清原因。你永远不能、也不可能直接跳到解决方案，你得挖掘原因。很多时候，它们不会直接表露在面上。而是深藏在表皮之下。”</p>
</blockquote>
<img src="/2021/05/25/%E7%BC%A9%E5%B0%8F%E5%B7%AE%E8%B7%9D/c.png" class="">

<blockquote>
<p> 从某些方面来说， 是原因约束了我们。我们曾为了解决问题而苦苦奋斗，而不从实际上 挖掘根本的原因。我们知道了’应有水平’应该是什么样的，并且要组织中心团队来揭露和分析”现实状况”,但是我们却没有弄清楚原因来消除差距。”</p>
</blockquote>
<p>对正确的人以正确的方式问正确的问题，你就能够分析’现实状况’并弄清原因。你会很好地缩短’应有水平’和’现实状况’之间的差距。</p>
<img src="/2021/05/25/%E7%BC%A9%E5%B0%8F%E5%B7%AE%E8%B7%9D/d.png" class="">

<h4 id="从原因到解决方案"><a href="#从原因到解决方案" class="headerlink" title="从原因到解决方案"></a>从原因到解决方案</h4><img src="/2021/05/25/%E7%BC%A9%E5%B0%8F%E5%B7%AE%E8%B7%9D/e.png" class="">

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
  </entry>
  <entry>
    <title>部署</title>
    <url>/2018/10/13/%E7%BD%B2/</url>
    <content><![CDATA[<p>部署方案推敲以及评审，最好有PlanB。</p>
<p>确认部署方案，相关人员和部门配合，进行演练</p>
<p>记录部署问题，优化部署方案。</p>
<p>现场部署，做好问题记录，拿回公司做分析和优化。</p>
<p><strong>一定要考虑客户的生产环境，公司做好随时支援现场的准备。</strong></p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
  </entry>
  <entry>
    <title>思考工具</title>
    <url>/2022/06/23/%E8%80%83%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>加入了 池老师的知识星球：让时间为你证明</p>
<p><a href="https://untools.co/">https://untools.co/</a></p>
]]></content>
  </entry>
  <entry>
    <title>职业层级</title>
    <url>/2018/08/29/%E8%81%8C%E4%B8%9A%E5%B1%82%E7%BA%A7/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>近段时间较焦虑， 因为职业生涯的第一个5年到了，但是回过头来看自己走过的这5年，倒是经历了很多捶打，个人成长了很多，但是在技术层面并没有多少成长，些许恐慌才下脑头又上了心头。对自己的未来没有把握太可怕了，所以要好好想想自己未来的路了。</p>
<h4 id="开始思考"><a href="#开始思考" class="headerlink" title="开始思考"></a>开始思考</h4><p>了解了腾讯、阿里的职级，本来以为职场发展的这条线够用了，直到看到了吴老师的《硅谷来信》，里面有关于职场上的内容，让我对职业层级有了更广阔的认知，对我触动很大，在此简单做的记录。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>对自己的标准会不由自主的降低以适应这个环境，减少自身与环境的冲突，在一个低标准下，自觉‘满意’的度过每一天</strong></p>
]]></content>
      <categories>
        <category>闲扯</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>强联系和弱联系</title>
    <url>/2018/06/28/%E8%81%94%E7%B3%BB%E5%92%8C%E5%BC%B1%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<p>早上地铁上啃kindle里的<strong>万万没想到</strong>，里面有个小结讲的是<strong>穷人</strong>和富人的人脉结构。为什么穷人加粗，因为我就是穷人。</p>
<p>里面有两个词语我比较深刻，<strong>强联系</strong> <strong>弱联系</strong>。</p>
<p>所谓强联系其实就是讲的是平时跟你比较近的人，当然反之平时不怎么联系甚至没见过面的则为弱联系。通常我们都愿意跟强联系的人一起做事，因为熟。但是文章里面讲到外国友人做了几个相关的实验，恰恰证明其实真正能帮到你的很多时候是弱联系的人。<em><strong>因为他们有个共同的特点就是不在你当前的社交圈内</strong></em>。这一点很重要，因为强联系的人经常混在一起，你们的想法或者做的事都差不多，所以发现不了什么新的东西。然而弱联系的意义就是把不同的社交圈子连接在一起，从圈外跟你提供有用的信息。所以人脉的关键不在于你融入了哪个圈子，而在于你能接触多少圈外的人。后面还讲了其它几个实验，得出的结论就是，虽然咱们都重视强联系，但是人们的大部分知识还是来源于弱联系。其实很好理解，因为强联系的人愿意跟我们交流我们也经常交流，话多了当然就没什么新意了。</p>
<p>还有个观点，文章是单独拿出来说的，就是别跟熟人合伙。这个其实对中国人来说尤其困难，包括我，里面说到的一点我是很认同的就是创新能力，跟熟人搭伙，创新能力肯定是没有跟弱联系搭伙强的。熟了很多东西反而有限制。</p>
<p>文章实验指出，富人越容易跟不同阶层和不同地区的人联络，而且阶层多样性比地区多样性更重要。虽然富人爱跟各种人联系，但是真正说话的时间比穷人的短。所以知道了吧，要致富先得学会别强依赖，强联系的亲朋好友，得学会接触新的圈子。其实就是信息的传递，通过弱联系，有用的有启发的肯定会比强联系的多，你想想，强联系的才几个人，弱联系的又有多少，就算按比例弱联系也是完胜嘛。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>万万没想到</tag>
      </tags>
  </entry>
  <entry>
    <title>自律(一)</title>
    <url>/2018/08/14/%E8%87%AA%E5%BE%8B(%E4%B8%80)/</url>
    <content><![CDATA[<p>在看《少有人走的路：心智成熟的旅程》这本书之前，从来没细究自律的概念，就觉得自律就是自我约束，比如一天50个俯卧撑，不能因为某天朋友叫打游戏就把这50个省了，一定得做。这就是我理解的自律，但是看了《少有人走的路》之后，书中对自律的定义，我觉得我还是太年轻了，想的太粗糙。首先这本书正文没开始之前就说了，每个人或多或少的心里都有病，只是轻重和早晚不同而已。</p>
<img src="/2018/08/14/%E8%87%AA%E5%BE%8B(%E4%B8%80)/a.jpg" class="" title="来自twitter">

<p>如果从规避、逃避问题就是人类心理疾病的根源这个点来讲的话我是认同的，至少我没发现我也不认为，这个社会上存在有人是从来没有规避和逃避过问题的。所以如果你承认自己有这样的问题，那你还是看看这本书吧，以下是我的一些摘抄，算不上笔记。</p>
<p>首先要想心智走向成熟，你得学会自律。</p>
<p><em>自律是解决人生问题最主要的工具，也是消除人生痛苦最重要的方法</em></p>
<p><strong>首先什么是自律？</strong></p>
<blockquote>
<p>所谓自律，就是主动要求自己以积极的态度去承受痛苦，解决问题。</p>
<p>自律有四个原则：<strong>推迟满足感、承担责任、忠于事实、保持平衡</strong></p>
</blockquote>
<ul>
<li><p>推迟满足感</p>
<p>  不贪图暂时的安逸，先苦后甜，重新设置人生快乐与痛苦的次序：首先，面对问题并感受痛苦;然后，解决问题并享受更大的快乐。在充满问题和痛苦的人生中，推迟满足感是唯一可行的生活方式。</p>
</li>
</ul>
<blockquote>
<p>对于这个点我是深有体会的，我妈从小就教育我，先苦后甜，所以小的时候特别想早点长大，因为太穷了生活也太痛苦了，觉得长大了应该就是甜了，当然事实是脸被打的piapia的。现在想想其实小时候的想法不就是为了逃避问题么。所以其实所谓的先苦后甜，指的不是时间的先后，而是解决问题之前和之后。所以核心在于你得面对问题并解决它才有所谓的先苦后甜。<em>不过要注意：解决问题缺乏耐心、想让问题马上解决这样的态度是不切实际的。另外根据破坏性的是希望问题自行消失，这显然是自欺欺人，问题永远都在，如果不解决它将阻碍你心智的成熟。所以唯一能做的时直面问题，并尽可能早的面对问题。</em></p>
</blockquote>
<ul>
<li><p>承担责任</p>
<p>  这是我的问题要由我来解决。<em>力图把责任推给别人或组织，就意味着我们甘愿处于附属地位，把自由和权力拱手交给命运、社会、政府、独裁者和上司。</em></p>
</li>
</ul>
<blockquote>
<p>这一点我认为是比较重要的一点，承担责任对于我，稍微值得高兴的是，我一直在努力学会承担责任并做到不逃避责任，当然这样的选择对自已是相当痛苦的。因为你会发现在如今的社会，你所在的圈子，有越来越多人的在想办法规避或者逃避责任，为什么？因为他们不愿意承担不想承担。因为承担可能就代表着认输，代表着损失，代表着受虐。所以你可以想象如果你选择了不逃避责任可能不仅仅是你承担一些痛苦，可能还会招来白眼、孤立….。所以我觉得大多数国人的生活质量是上来了一些但是心智成熟方面还是有很大的提升空间。不过我还是想说自己的问题自己解决，勇于承担该承担的责任最起码你会让自己看上去没那么<strong>逗比和拙劣</strong>。</p>
</blockquote>
<ul>
<li><p>忠于事实</p>
<p>  <em>我们要实事求是，越是了解实事处理问题就越得心应手，对事实了解的越少，思维就越是混乱。</em></p>
<p>  <em>我们对现实的观念就像是一张地图，凭借着这张地图我们才能了解人生的地形、地貌、和沟壑，指引自己的道路。如果地图准确我们就知道自己的位置也知道要到什么地方，以及怎样到达；如果地图失真，漏洞百出，我们就会迷失方向。所以我们需要让自己的地图足够准确足够完整，怎么做呢？<strong>努力程度越高地图会越大越完整，对事实认知的更加清楚，准确性就会更高</strong>。</em></p>
</li>
</ul>
<blockquote>
<p>其实这一部分还提到一个概念叫<strong>移情</strong>，这个移情可不是移情别恋的移情，书中对其的说明我大概的传递一下：一个人把年幼时对世界的感知以及对世界作出的反应方式，照搬到成年后的环境中，虽然这些方式已经不再适用于新的环境。我觉得通俗点说就是活在自己的世界逃避现实，对外界的变化视而不见听而不闻。这样的人是拒绝更新自己的地图的，那当然就会经常迷路。所以可以看出面对现实不像想象的那么简单，现如今又有多少人愿意面对现实，忠于事实，并迎接挑战呢？<em>迎接挑战是唯一能确定我们的地图是否与事实符合的方法</em>。埋头刷抖音刷头条，各种交友软件各种游戏中各种直播中扮演着牛逼哄哄的样子，沉迷于虚假的舒适中，不想奋斗不想上班不想努力，一问他会有一堆的原因，买不起房，政府没用，没有技术等等，那你都知道这么多问题围绕着你了，你他么还不想办法解决，在等什么呢？等着被抛弃被奴役？</p>
</blockquote>
<p><em>要想在组织或集体中发挥大的作用，就要注重表达意见的时间、场合和方式。换句话说，一个人应该有选择的表达意见和想法</em></p>
<ul>
<li><p>保持平衡</p>
<p>  这一条其实更多是教我们怎么基于前面几条讲的做到自律，即自律本身就是把持得当。</p>
</li>
</ul>
<blockquote>
<p>这一点没什么好说的，说白了主要还是自己把握好度，比如对待生气的事情，什么情况下改表现出发怒，什么情况下改表现出隐忍…..<br>文中有一小节讲到<strong>放弃与新生</strong>，要学会必须放弃旧的、过时的观念和习惯诸如生活环境、个人欲望、处世态度这样的东西，才能得到心智的成熟，才能获得新生。说的有点玄，不过确实是如果你始终执念于你的某些过时的观念或者习惯，容易让自己以及周边的人陷入痛苦。因为这意味着你不想放弃，哪怕那是不好的，这往往会为自己以及周边人带来痛苦或者伤害。所以需要学会在不同的人生阶段放弃某些东西，比如身为父母的阶段，要学会放弃父母的权威等。最终你获得的永远比放弃的多。</p>
</blockquote>
<h2 id="书中的部分句子"><a href="#书中的部分句子" class="headerlink" title="书中的部分句子"></a>书中的部分句子</h2><p><em>“我是个有价值的人”-像这样对自我价值的认可，是心里健康的基本前提，也是培养自律的根基。对自我价值的认可是自律的基础，因为当一个人觉得自己很有价值时，就会采取一切必要的措施来照顾自己。自律是自我的照顾，自我珍惜，而不是自暴自弃</em>。</p>
<p><em>自律能让我们承受问题带来的痛苦，并最终解决问题。</em></p>
<p><em>你不能解决问题，你就会成为问题。</em></p>
<p>*为了躲开责任带来的痛苦，数不清的人甘愿放弃权力，实则是在逃避自由   - 《逃避自由》 * </p>
]]></content>
      <categories>
        <category>读书</category>
        <category>认知</category>
      </categories>
      <tags>
        <tag>自律</tag>
      </tags>
  </entry>
  <entry>
    <title>观看之道</title>
    <url>/2018/08/01/%E8%A7%82%E7%9C%8B%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>这两天看了有人推荐的约翰·伯格在BBC的纪录片《观看之感》，这部纪录片开始通过讲艺术中的绘画（油画），然后讲解油画的内容，最后过渡到当今（70年代）社会的海报（广告）。</p>
<img src="/2018/08/01/%E8%A7%82%E7%9C%8B%E4%B9%8B%E9%81%93/001.png" class="" title="Ways of Seeing">



<p>我这人是个粗人反应也比较慢，看到最后瞬间才如醍醐灌顶般了解这个纪录片讲述的东西，想在这儿写下感想….</p>
<p>但是资历太浅写不出来，后面想通了再回来补，现在就记录下现下我的思考。</p>
<p><strong>感触</strong></p>
<p>一听到艺术都觉得那是个高层次的是在生活之上的，其实可能不是我们传颂的那样，它的内容最终都是反馈到世俗生活中的，所以这样传统的认知是值得商榷的（约翰·伯格甚至是批判这种认知），整个纪录片我得到的信息是，告诉我一个词叫“欲望”，其实不管是油画还是其复制品还是现在的海报背后都隐藏着人们对某一方面的欲望。</p>
<p>所以其实你会发现现实中很多东西其实是被设计的，在比较深层次的地方他们可能会很可怕的引导你的思维方式、你的诉求、你的认知…，表面上可能会影响你穿什么、吃什么、喜欢什么…，这让我想到了一本书《娱乐至死》，大家有兴趣可以看下我觉得很有意义的一本书。</p>
<p>节目最后伯格大叔也说了，纪录片仅代表他的观点，具体怎么看还是取决与我们自己。所以我们活着一定要多些思考，多换角度思考，多想想为什么，不要轻易听信别人，也不要懒得思考…</p>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2018/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>作为NPMD的厂商</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>详细设计</title>
    <url>/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>首先为什么需要详设？</p>
<img src="/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/001.png" class="" title="来源于我">

<p>肯定有人会喷，现在都谈敏捷了，你那是瀑布那一套了，现在谁还弄详设，然后就被鄙视了。如果是这样我就想问下，什么是敏捷？什么时候应该敏捷？先回答好了这两个问题再BB，哥也是经历过敏捷的人，13年在一家做数字工厂的创业公司，被公司副总忽悠做项目经理，当时作为一个码农的我来说，本身比较迷茫感觉天天敲代码不是我要的，觉得白富美离我太远。所以就想做产品经理，憧憬做一个响当当的产品出来，享誉中国，当然我得解释一下，此产品经理不是被玩坏的那种UE产品经理，而是正儿八经的产品经理。刚好遇到此副总，跟我聊了后就看上我了，美其名曰看上我的才，觉得我有当产品经理的潜力，然后我就飘飘然的去了。去了之后就让我先从项目经理干起，这儿的项目经理只管项目（需求调研、文档编写、项目资源协调…）不管技术。副总当时推得就是敏捷，因为本身干的是传统行业，一开始都是瀑布过来的，副总觉得瀑布有很多问题，所以准备推敏捷，我当时也是第一次接触敏捷，所以老大丢给了我一堆书，其中一本我记得是叫《敏捷项目管理》的书，然后就让我抱着啃，也恬不知耻的跟着其它项目组体验了敏捷的落地…。那段时间是我悠闲、迷茫的时光，一开始用latex跟公司弄宣传册，然后跟项目，去鸟不拉屎的地方，夏天跟客户喝着“枝江”聊着需求，其实挺怀恋的…。</p>
<img src="/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/scrum_framework.png" class="" title="来源于scrum.org">

<p> 扯远了，后来在现在的公司，公司又请人做了一次敏捷培训，内容其实跟我之前看的书差不多，只是里面有一个概念是我比较深刻的就是讲师说了一个词语叫“小瀑布”，大概意思就是取敏捷和瀑布的各一部分。为什么呢？就是因为传统的瀑布确实是太重周期太长了，而且对客户的要求高，因为瀑布都是白纸黑字写好合同定功能需求的。你想想客户如果没想好，那是不是就麻烦了。但是事实是往往客户是不可能百分百知道自己要什么的或者说不可能百分百描述清楚自己要什么的。这个时候敏捷就有优势了，敏捷在我看来其实就是工作理念的转变，讲求的是快速迭代，讲求用户参与，讲求跨职能，这样就能很大限度的避免走偏。</p>
<img src="/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/002.png" class="" title="来源于网络">

<p> 小瀑布在我们团队是咋用的呢，主要包括：</p>
<ol>
<li>首先团队是跨职能的，需求、产品、测试、研发都同属于一个团队，且团队的目标是一致的。</li>
<li>前期除了User Story，还会进行需求评审，会出UCD文档，研发会出详设。</li>
<li>Daily Scrum不强制要求。</li>
<li>没有Sprint Review</li>
</ol>
<p>为什么我们会这样是因为我们本身不是一家互联网企业，对快速响应要求没那么高，我们是一家传统的toB企业，有自己的产品，很少接项目做，有稳定的渠道，不过也存在瓶颈，在这样的情况下，做新产品，我们则采取了现在的小瀑布的形式。至少目前来讲是很适合的。</p>
<p>ok，扯得有点多了，我们还是来说说详设。</p>
<h2 id="0-1版详设"><a href="#0-1版详设" class="headerlink" title="0.1版详设"></a>0.1版详设</h2><p>因为之前的详设没有一个特别正式的模板，接着0.2功能迭代需要写详设，领导让我和另外一个同事整一个详设的样板出来，跟领导过了几次，搜集了一下意见，最终中心思想只有一个，让新旧研发、测试、技术大佬都能看明白。</p>
<p>所以最终出的模板是这样滴：</p>
<img src="/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/%E8%AF%A6%E8%AE%BE%E6%A8%A1%E6%9D%BF.png" class="" title="0.1详设模板">

<p>这个模板稍微复杂了一些，但是他的好处在于说明了上下文，说明了依赖项，说明了核心逻辑，所以基本上出来的东西大家都能看懂，也能而且能评估难度和工作量等。</p>
<h2 id="0-2版详设"><a href="#0-2版详设" class="headerlink" title="0.2版详设"></a>0.2版详设</h2><p>这版详设是在产品0.3.3迭代后出现的修改，是在0.1基础上的一些精进，精进了依赖项和核心逻辑说明。</p>
<ul>
<li>0.2把外部依赖项单独拎出来，这样能更加清晰表述自己所需要的支持，并且让对方知道。</li>
<li>0.2把核心逻辑也着重提出来，0.1核心逻辑更多在于文字描述和UML图，0.2的要求是用伪代码+UML的形式进行核心逻辑的说明，核心思想就是贴近代码让详设更加实用。</li>
</ul>
<img src="/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/004.png" class="" title="0.2详设模块">


<p><strong>详设最实用的地方</strong>：是为了让你思考更加缜密，并且获得反馈。</p>
<p><strong>未来的期望：</strong></p>
<p>当然这版详设也不是最终版，以后会持续精进，最终的目标是直接不要文档。</p>
<p>甚至我们刚进的一个架构师提出的愿景是：全部用类似单元测试的代码+注释的形式写详设，详设是否存在问题，看单元测试是否通过，我觉得是很美好的…..路很长。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>Sprint</strong></p>
<blockquote>
<p>可理解为一个迭代</p>
</blockquote>
<p><strong>Scrum</strong></p>
<blockquote>
<p>Scrum 可以理解成是一个框架，此框架让产品管理和工作技术的相对成效更加清晰地显现出来，以便您可以持续改进产品、团队和工作环境。</p>
</blockquote>
<img src="/2018/07/31/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/scrum.jpg" class="" title="来源于twitter">

<p><strong>Daily Scrum</strong></p>
<blockquote>
<p>每日站会</p>
</blockquote>
<p><strong>User Story</strong></p>
<blockquote>
<p>用户故事，可以理解为一个场景或者一条需求。</p>
</blockquote>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>详设</tag>
      </tags>
  </entry>
  <entry>
    <title>读书方法</title>
    <url>/2018/08/15/%E8%AF%BB%E4%B9%A6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近由于自己开窍，以及周围人对我的“捶打”，感觉是时候多读书了，不然以后成为头脑简单+四肢也不发达的人还不自知那就尴尬了。</p>
<p>我读书少，所以先学会读书。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="《如何阅读一本书》"><a href="#《如何阅读一本书》" class="headerlink" title="《如何阅读一本书》"></a>《如何阅读一本书》</h4><p>阅读艺术的定义：这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，<strong>以一己之力来提升自己的过程</strong>。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>
<ol>
<li><p>首先得端正你的态度：<strong>主动阅读</strong>，没有任何外力的帮助你就是要读这本书（真正的阅读）。</p>
</li>
<li><p>阅读的层次：基础阅读、检视阅读、分析阅读、主题阅读</p>
<ul>
<li><p>里面有个章节说到了一点：辅助阅读，也就是往往有时候你在读一本书的时候除了这本书以外需要借助一些外在辅助来源，比如其它相关的书，工具书、经验等</p>
</li>
<li><p>我个人觉得这几个章节核心思想就是不要妄想书读一遍就掌握精髓了，通常有点东西的书至少得来个2-3遍，是个递进的过程，其实我们的老祖宗老早就说过</p>
<blockquote>
<p>温故而知新</p>
</blockquote>
</li>
</ul>
</li>
<li><p>一定要认真看每本书正文前的内容，比如<strong>序、目录</strong>等，这会让你更有代入感和针对性。能帮你梳理你读书的顺序。</p>
</li>
<li><p>读书大体分两种</p>
<ul>
<li>为了获得资讯</li>
<li>为了增进理解</li>
</ul>
</li>
<li><p>不同类型的书有不同的读法</p>
<blockquote>
<p>比如读实用性和读哲学的书肯定不一样，前者是要说服你采用特定的思想和行动，后者主要是引起你的思考。</p>
</blockquote>
<h4 id="《张五常的读书方法》"><a href="#《张五常的读书方法》" class="headerlink" title="《张五常的读书方法》"></a>《张五常的读书方法》</h4></li>
</ol>
<p>读书是为知识而读书，不是为考试或者考核等读书，所以明确知识是读书的目的。</p>
<ol>
<li><p>以理解代替记忆</p>
<ul>
<li>明白了基本概念和含义，比死记硬背强，因为理解的前提是书中的重点、章节等是需要贯通的，同时概念等的演变和递进也是需要清楚的，所以当你真正理解的时候你是几乎不可能在一段时间内就忘记书里的内容的。</li>
<li>笔记记下不明白的比记下明白的更重要。</li>
</ul>
</li>
<li><p>思想集中才有兴趣</p>
<ul>
<li><p>兴趣不是培养出来的。只有思想能上能集中，才能产⽣兴趣。可以培养出来的是集中的能⼒。<strong>所以无论读的书与你兴趣相差多远，只要你能对之思想集中，兴趣即盎然⽽⽣</strong>。（观点我是醍醐灌顶啊）要记着，只要能集中，读书所需的时间是很少的。</p>
<ul>
<li><p>培养思想集中力，</p>
<blockquote>
<p>第⼀，分配时间——读书的时间不需多，但要连贯。</p>
<p>第⼆，不打算读书的时间要尽量离开书本—— 「饿书」可加强读书时的集中⼒。</p>
<p>第三，读书时若觉得稍有勉强，就应索性不读⽽ 等待较有⼼情的时候——厌书是⼤忌。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>问⽐答重要（此节选可能更适用讨教的场景，不过我觉得很有启发遂记录，很多人其实不知道怎么问问题）</p>
<p>发问做准备功夫，便于分清楚「知」和「不知」，也能让问题更有针对性，准备功夫大致以下的三个步骤：</p>
<ul>
<li><p>第⼀，问题可分三类——A，「是什么」（What?）；B，「怎样办」（How?）； C，「为什么」（Why?）。要先断定问题是哪⼀类。A类问的是事实；B类问的 是⽅法；C类问的是理论。问题⼀经断定是哪⼀类，就应⽴刻知道⾃⼰的「不 知」是在哪⽅⾯的，因⽽可免却混淆。</p>
</li>
<li><p>第⼆，要尽量去将问题加上特性。换⾔之，你要问的⼀点越尖越好。</p>
</li>
<li><p>第三，在问其他人之前，要先问⾃⼰问题的答案是否可轻易地在书本上找到。若然，就不应花其他人的时间。⼤致上，⽤以上 的步骤发问，答案是⾃⼰可以轻易地找到的。</p>
</li>
</ul>
</li>
<li><p>书分三读——⼤意、细节、重点</p>
<p>这块跟上面说的阅读层次有异曲同工的感觉，切忌一上来就各种做笔记和记号。</p>
<blockquote>
<p>第一读是快读，读⼤意，但求知道所读的书究竟是关于什么问题或者主题的？。跟自己有关系吗（即真的有必要去了解去读吗）？</p>
<p>第⼆读是慢读，读细 节，务求明⽩内容。可对不明白的地方做记号等</p>
<p>第三读是选读，读重点。重点或者强调的记号是在这时候加上去的，因为哪⼀点是重点要在细读后才能选出来。</p>
</blockquote>
</li>
</ol>
<p>⽽需要先经两读的主要原因，就是 若没有经过⼀快⼀慢，选重点很容易会选错了。</p>
<h3 id="试着小结一下"><a href="#试着小结一下" class="headerlink" title="试着小结一下"></a>试着小结一下</h3><p>以上的两块内容同时有提到的我认为很重要的几点：</p>
<ol>
<li>选书比读书更花时间，什么都读读一大堆，说好听是博览群书，说难听是“半壶水”。</li>
<li>读书需要分类，不同种类的书读法会有不同，不能一概而论。</li>
<li>读书一上来就咔咔咔记各种笔记，并且第一遍就要仔细读完的，最终效果大多不好，当然一些资讯类的书除外。</li>
<li>好的书通常都要读几遍。读书是一个递进的过程，理想状态下每一遍会进入不同的层次。</li>
</ol>
<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2018/08/20/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>刚好这段时间对接其他产品，刚好处理了一下跨域的问题，借此机会稍微更加了解一下跨域(Cross-origin resource sharing)。</p>
<p>搬运搬运…</p>
<h4 id="首先什么是同源策略？"><a href="#首先什么是同源策略？" class="headerlink" title="首先什么是同源策略？"></a>首先什么是同源策略？</h4><p>同源策略是一种Web浏览器安全性机制，旨在防止网站相互攻击。</p>
<p>同源策略限制一个源上的脚本访问另一源的数据。源由URI方案，域和端口号组成。</p>
<p>同源策略是一种限制性的跨域规范，它限制了网站与源域外部资源进行交互的能力。起源于多年前的策略是针对潜在的恶意跨域交互（例如，一个网站从另一个网站窃取私人数据）做出的响应。通常，它允许一个域向其他域发出请求，但不允许访问响应。</p>
<p>同源策略它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.) Cookie、LocalStorage、IndexedDB 等存储</span><br><span class="line">2.) DOM查询</span><br><span class="line">3.) AJAX 请求</span><br></pre></td></tr></table></figure>

<p>但是有三个标签是允许跨域加载资源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=XXX&gt; </span><br><span class="line"></span><br><span class="line">&lt;link href=XXX&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=XXX&gt;</span><br></pre></td></tr></table></figure>

<h4 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a><strong>常见跨域场景</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同文件或路径           允许</span><br><span class="line">http://www.domain.com/lab/c.js</span><br><span class="line"></span><br><span class="line">http://www.domain.com:8000/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同端口                不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">https://www.domain.com/b.js        同一域名，不同协议                不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://192.168.4.12/b.js           域名和域名对应相同ip              不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://x.domain.com/b.js           主域相同，子域不同                不允许</span><br><span class="line">http://domain.com/c.js</span><br><span class="line"> </span><br><span class="line">http://www.domain1.com/a.js</span><br><span class="line">http://www.domain2.com/b.js        不同域名                         不允许</span><br></pre></td></tr></table></figure>



<h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a><strong>跨域解决方案</strong></h4><p>1、 通过jsonp跨域<br>2、 iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p>
<p>比较抱歉的是我只用过nginx代理跨域、跨域资源共享（CORS）、WebSocket协议跨域…。</p>
<h4 id="什么是CORS（跨域资源共享）？"><a href="#什么是CORS（跨域资源共享）？" class="headerlink" title="什么是CORS（跨域资源共享）？"></a>什么是CORS（跨域资源共享）？</h4><p>在大多数情况下，在用户浏览器中运行的脚本仅需要访问源相同的资源（请考虑首先对服务JavaScript代码的同一后端进行API调用）。因此，JavaScript通常无法访问其他来源的资源，这对安全性而言是一件好事。但是有些情况下需要跨域请求的。例如，不同系统间的一些对接。解决该问题就需要实现CORS，跨域资源共享（CORS）是一种浏览器机制，可实现对位于给定域外部的资源的受控访问。</p>
<h4 id="CORS如何运作"><a href="#CORS如何运作" class="headerlink" title="CORS如何运作"></a>CORS如何运作</h4><p>如果不需要cookie的话，整个<code>CORS</code>通信过程都是浏览器自动完成的，前端不需要做额外的编码。<strong>浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，复杂请求还会多一次预检的请求，但我们是不用感知的</strong>。因此，实现<code>CORS</code>通信的关键是服务器开启CORS。</p>
<img src="/2018/08/20/%E8%B7%A8%E5%9F%9F/b.png" class="">



<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><footer><strong>KRISTOPHER SANDOVAL</strong><cite><a href="https://nordicapis.com/what-is-cors-cross-origin-resource-sharing/">What is CORS</a></cite></footer></blockquote>

<blockquote><footer><strong>w3c</strong><cite><a href="https://www.w3.org/TR/2014/REC-cors-20140116/">Cross-Origin Resource Sharing</a></cite></footer></blockquote>
<blockquote><footer><strong>阮一峰</strong><cite><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></cite></footer></blockquote>

<p><code>本文引用的内容，如有侵权请联系我删除，给您带来的不便我很抱歉。</code></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程是失败者游戏</title>
    <url>/2021/09/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%98%AF%E5%A4%B1%E8%B4%A5%E8%80%85%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://dev.to/thawkin3/software-engineering-is-a-loser-s-game-2k20">https://dev.to/thawkin3/software-engineering-is-a-loser-s-game-2k20</a></p>
<p>最近看到了这篇文章，当时看到标题的第一感觉是有点被冒犯到。但是细看下来觉得很有意思，引起我的很多思考。遂记录一下。</p>
<p>像我这样的人通过努力保持不愚蠢而不是努力变得非常聪明。</p>
]]></content>
  </entry>
  <entry>
    <title>问题解法咋聊(1)</title>
    <url>/2020/12/19/%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>因为团队内部经常会有问题复盘以及技术故事讨论等活动，怎么让这个讨论是有营养且找到根因，保证最终能落到具体的行动项上面。我觉得这是一门很大的学问。</p>
<p>不信你留心观察你参加相关会议或者讨论，你会发现弄了半天问题好像解了又好像没解，过程可能还会伴有撕逼和甩锅…，有句古语说得好：我在旁边坐，锅从天上来。</p>
<h4 id="那咋聊呢"><a href="#那咋聊呢" class="headerlink" title="那咋聊呢"></a>那咋聊呢</h4><h5 id="Point-1-描述问题"><a href="#Point-1-描述问题" class="headerlink" title="Point 1 描述问题"></a>Point 1 描述问题</h5><p>描述问题，切忌采用<strong>下结论</strong>的思维和话语，比如：我认为、我觉得…。</p>
<p>我们是为了解问题的，所以你只需要言简意赅的把问题说清楚，这个时候你是一个莫得感情的机器。</p>
<h6 id="怎么言简意赅呢"><a href="#怎么言简意赅呢" class="headerlink" title="怎么言简意赅呢?"></a>怎么言简意赅呢?</h6><p>站在第三视角陈述：只说现象不说结论，时间、环境、人物、操作过程、发生的现象、造成什么影响…。</p>
<p>如果有必要还可以进行一个动作：<strong>过程还原</strong></p>
<p><em>直接叙述工作过程，有问题的环节或阶段，什么人，做了什么事，当时是怎么考虑的，在这个动作后结果是什么。</em></p>
<h5 id="Point-2-根因分析"><a href="#Point-2-根因分析" class="headerlink" title="Point 2 根因分析"></a>Point 2 根因分析</h5><p>描述之后这个时候可以说说自己的看法了：<em>描述最终定位到的直接原因是什么</em></p>
<h6 id="有个模板可参考"><a href="#有个模板可参考" class="headerlink" title="有个模板可参考"></a><strong>有个模板可参考</strong></h6><p><strong>1.技术根因分析</strong></p>
<ul>
<li><p>引入环节：</p>
<blockquote>
<p>产品设计是否有问题？</p>
<p>需求分析是否有问题？</p>
<p>设计环节是否有问题？</p>
<p>代码编写是否有问题？</p>
<p>其他？</p>
</blockquote>
</li>
<li><p>流出环节：</p>
<blockquote>
<p>各评审环节是否有遗漏？</p>
<p>是否进行研发自测？</p>
<p>测试场景、测试用例是否覆盖全？</p>
<p>是否进行了系统测试？</p>
<p>其他？</p>
</blockquote>
</li>
<li><p>确定关键根因是什么：</p>
<p>如果有多个根因在逻辑层次上相同，则取关键的原因，根因应该是具体的、客观的、在目前组织能力下可被改进的。</p>
</li>
</ul>
<p><strong>2.管理根因分析</strong></p>
<ul>
<li><p>流程&#x2F;制度原因：</p>
</li>
<li><p>组织因素：</p>
</li>
<li><p>执行原因：</p>
<p>【帮助】流程&#x2F;制度方面：考虑组织管理上是否有合适的流程、指导书、管理Checklist；</p>
<p>组织因素方面：考虑人员分配、个人技能、培训、组织环境等原因；</p>
<p>执行方面：考虑计划、监控、沟通方面的原因。</p>
</li>
</ul>
<p> <font color=#4169E1 size=3 ><strong>这个活动一定要有被随便蹂躏的那种奔放和豁达！！！</strong></font></p>
<h5 id="Point-3-纠正、预防措施"><a href="#Point-3-纠正、预防措施" class="headerlink" title="Point 3 纠正、预防措施"></a>Point 3 纠正、预防措施</h5><p>分析完了之后，一定要有落地的行动项。</p>
<table>
<thead>
<tr>
<th><strong>根本原因</strong></th>
<th>措施类型</th>
<th><strong>措施内容</strong></th>
<th>责任人</th>
<th><strong>预定完成日期</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>技术根因：</em>  <em>例如，XX特性，在大规格、灵活配置等方面需求设计不充分</em></td>
<td>纠正措施</td>
<td><em>例如：对XX特性组织进行重新设计，刷新XX方案</em></td>
<td>Jack Ma</td>
<td><em>2020&#x2F;11&#x2F;1</em></td>
</tr>
<tr>
<td></td>
<td>预防措施</td>
<td><em>例如：更新××技术规范、工具、checklist等等</em></td>
<td>Pony Ma</td>
<td><em>2020&#x2F;11&#x2F;1</em></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>问题解法</tag>
      </tags>
  </entry>
  <entry>
    <title>高难度沟通</title>
    <url>/2019/09/23/%E9%9A%BE%E5%BA%A6%E6%B2%9F%E9%80%9A/</url>
    <content><![CDATA[<p>高难度沟通发生的三个场景</p>
<p>矛盾、争取、推进</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>高难度沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>项目脚手架</title>
    <url>/2018/07/17/%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<p>之前在12-Factors时提过我们在搭一个脚手架，这篇简单介绍一下，老话说得好再丑也要出来吓人嘛。</p>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><p>项目模块是基于maven做的项目生成脚手架，基于此脚手架生成 maven 项目模块， 开发人员能快速的基于模版进行开发，减少前期熟悉开发框架时间。同时 也通过此模版来统一平台开发规范，实现工程能力提升，沉淀工程规范。</p>
<img src="/2018/07/17/%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/01.png" class="" title="脚手架生成的项目">

<p><strong>结构说明</strong></p>
<ul>
<li><p>app-bom 工程依赖管理.</p>
</li>
<li><p>app-manager 工程胶合层，service 层通用能力下沉，复杂 dao 组合.</p>
</li>
<li><p>app-repository 数据操作层，与数据库进行交互.</p>
</li>
<li><p>app-rpc-api 服务向外暴露的 rpc api 接口.</p>
</li>
<li><p>app-service 服务业务逻辑实现.</p>
</li>
<li><p>app-web 服务 restful 接口.</p>
</li>
</ul>
<h2 id="maven脚手架"><a href="#maven脚手架" class="headerlink" title="maven脚手架"></a>maven脚手架</h2><img src="/2018/07/17/%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/01.png" class="" title="脚手架">]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>开荒</tag>
      </tags>
  </entry>
  <entry>
    <title>领导寄语</title>
    <url>/2020/02/03/%E9%A2%86%E5%AF%BC%E5%AF%84%E8%AF%AD/</url>
    <content><![CDATA[<img src="/2020/02/03/%E9%A2%86%E5%AF%BC%E5%AF%84%E8%AF%AD/a.png" class="" title="Photo by DJ Johnson on Unsplash">

<p>记录近两年各种机会下与事业部头部三剑客交流收获的一些真知灼见。</p>
<p><strong>关于合作</strong></p>
<blockquote>
<p>目标一致</p>
</blockquote>
<p>看上去的完美搭档其实是一个很磨人的过程，一开始恨不得一见面就呼巴掌作为打招呼的方式，最终能达成默契或者说合作，目标一致最重要的前提。</p>
<p>不管你怎么看不惯一个人，三观有多么不合，但是当你发现大家目标都是一致的时候，静下来的时候大家总会想一想，是不是我有问题，慢慢的就变得能够互相包容，所以要做成事首要条件不是考虑要找多要好的人多默契的人，关键在于你们的目标是否一致，只要目标一致你会发现你们很难分割彼此。</p>
<p>所以有目标是一件重要紧急的事。</p>
<p><strong>关于做事</strong></p>
<blockquote>
<p>干一行，爱一行，不然干不了大事。</p>
</blockquote>
<p>最深刻的一句话，我记得当时是我谈起对我现在做的事好像也没到喜欢的程度的时候，领导对我说了这句话，听后我记得当时醍醐灌顶，然后手脚冰凉，内心很奔溃，至此以后我逐渐爱上了我现在做的事，虽然还是有很厌烦的时候，不过总能爱回去。</p>
<blockquote>
<p>勇于释放自己，学会利用资源，学会影响上级。</p>
</blockquote>
<p>这句话是我最亲近的老大对我说的，当我在抱怨做事的一些困惑时。这是最有挑战的不过收获也是最大的，这句话不是教我怎么在领导面前表现，而是告诉我领导在意的是你的结果，当你结果好的时候，才会在意过程，从而改变对你的一些印象。当你做出结果时，他们会关注到的。</p>
<p><strong>关于自信</strong></p>
<blockquote>
<p>当你进入了公司就不要再因为自己的出身、学历等感到自卑，因为能进来表示公司已经认可了你，接下来你要想的是，怎么做到比别人牛逼。</p>
</blockquote>
<blockquote>
<p>否定自己是很耗能量的一件事，积极一点。</p>
</blockquote>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>docker网络问题</title>
    <url>/2023/10/23/docker%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>处理了一个现场问题，现场部署了多个agent但是就一个agent离线。</p>
<p>查了下agent所在的服务器与主业务是能telnet通的，但是进入agent容器内部则不行，不管是ping还是curl都不行。</p>
<p>首先怀疑容器的网络配置可能存在问题。检查容器的网络设置，先后检查了iptables、DNS、检查默认路由都没有异常。又因为容器外能访问，且该agent与其它2、3个agent属于同一个子网下，所以也侧面证明了，服务器的网络配置确实没问题。</p>
<p>那接下来基本确定是docker网络配置的问题了。</p>
<p>基于nsenter，验证网络问题，发现确实存在网络问题，ping docker默认网关不通。</p>
<p>现场反馈更新过agent的网络地址，随即检查daemon.json 、docker-compose.yml文件</p>
<p>发现docker-compose.yml内定义的subnet为16为子网掩码，而daemon.json为24位子网掩码，</p>
<p>因为16比24的IP范围大，这种情况下,容器获得的IP地址可能不在docker-compose网络的子网范围内,从而无法连接到该网络,造成网络通信失败。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>将docker-compose.yml和docker daemon中的子网掩码设置为相同。例如都使用24位子网掩码。
 </p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
</search>
